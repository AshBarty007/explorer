// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: pkg/pb/tickets.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ContractUniversalResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ContractUniversalResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContractUniversalResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ContractUniversalRespMultiError, or nil if none found.
func (m *ContractUniversalResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ContractUniversalResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if len(errors) > 0 {
		return ContractUniversalRespMultiError(errors)
	}

	return nil
}

// ContractUniversalRespMultiError is an error wrapping multiple validation
// errors returned by ContractUniversalResp.ValidateAll() if the designated
// constraints aren't met.
type ContractUniversalRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContractUniversalRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContractUniversalRespMultiError) AllErrors() []error { return m }

// ContractUniversalRespValidationError is the validation error returned by
// ContractUniversalResp.Validate if the designated constraints aren't met.
type ContractUniversalRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContractUniversalRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContractUniversalRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContractUniversalRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContractUniversalRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContractUniversalRespValidationError) ErrorName() string {
	return "ContractUniversalRespValidationError"
}

// Error satisfies the builtin error interface
func (e ContractUniversalRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContractUniversalResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContractUniversalRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContractUniversalRespValidationError{}

// Validate checks the field values on OwnerOfReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OwnerOfReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OwnerOfReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OwnerOfReqMultiError, or
// nil if none found.
func (m *OwnerOfReq) ValidateAll() error {
	return m.validate(true)
}

func (m *OwnerOfReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAddress()) != 42 {
		err := OwnerOfReqValidationError{
			field:  "Address",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetOrgMspID()) < 0 {
		err := OwnerOfReqValidationError{
			field:  "OrgMspID",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTokenId()) < 0 {
		err := OwnerOfReqValidationError{
			field:  "TokenId",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return OwnerOfReqMultiError(errors)
	}

	return nil
}

// OwnerOfReqMultiError is an error wrapping multiple validation errors
// returned by OwnerOfReq.ValidateAll() if the designated constraints aren't met.
type OwnerOfReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OwnerOfReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OwnerOfReqMultiError) AllErrors() []error { return m }

// OwnerOfReqValidationError is the validation error returned by
// OwnerOfReq.Validate if the designated constraints aren't met.
type OwnerOfReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OwnerOfReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OwnerOfReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OwnerOfReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OwnerOfReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OwnerOfReqValidationError) ErrorName() string { return "OwnerOfReqValidationError" }

// Error satisfies the builtin error interface
func (e OwnerOfReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOwnerOfReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OwnerOfReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OwnerOfReqValidationError{}

// Validate checks the field values on AddressData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AddressData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddressData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AddressDataMultiError, or
// nil if none found.
func (m *AddressData) ValidateAll() error {
	return m.validate(true)
}

func (m *AddressData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Address

	if len(errors) > 0 {
		return AddressDataMultiError(errors)
	}

	return nil
}

// AddressDataMultiError is an error wrapping multiple validation errors
// returned by AddressData.ValidateAll() if the designated constraints aren't met.
type AddressDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddressDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddressDataMultiError) AllErrors() []error { return m }

// AddressDataValidationError is the validation error returned by
// AddressData.Validate if the designated constraints aren't met.
type AddressDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddressDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddressDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddressDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddressDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddressDataValidationError) ErrorName() string { return "AddressDataValidationError" }

// Error satisfies the builtin error interface
func (e AddressDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddressData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddressDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddressDataValidationError{}

// Validate checks the field values on OwnerOfResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OwnerOfResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OwnerOfResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OwnerOfRespMultiError, or
// nil if none found.
func (m *OwnerOfResp) ValidateAll() error {
	return m.validate(true)
}

func (m *OwnerOfResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OwnerOfRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OwnerOfRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OwnerOfRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OwnerOfRespMultiError(errors)
	}

	return nil
}

// OwnerOfRespMultiError is an error wrapping multiple validation errors
// returned by OwnerOfResp.ValidateAll() if the designated constraints aren't met.
type OwnerOfRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OwnerOfRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OwnerOfRespMultiError) AllErrors() []error { return m }

// OwnerOfRespValidationError is the validation error returned by
// OwnerOfResp.Validate if the designated constraints aren't met.
type OwnerOfRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OwnerOfRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OwnerOfRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OwnerOfRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OwnerOfRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OwnerOfRespValidationError) ErrorName() string { return "OwnerOfRespValidationError" }

// Error satisfies the builtin error interface
func (e OwnerOfRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOwnerOfResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OwnerOfRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OwnerOfRespValidationError{}

// Validate checks the field values on TransferTokenReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TransferTokenReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransferTokenReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransferTokenReqMultiError, or nil if none found.
func (m *TransferTokenReq) ValidateAll() error {
	return m.validate(true)
}

func (m *TransferTokenReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetFromOrgMspID()) < 0 {
		err := TransferTokenReqValidationError{
			field:  "FromOrgMspID",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetFrom()) != 42 {
		err := TransferTokenReqValidationError{
			field:  "From",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetToOrgMspID()) < 0 {
		err := TransferTokenReqValidationError{
			field:  "ToOrgMspID",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTo()) != 42 {
		err := TransferTokenReqValidationError{
			field:  "To",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetTokenId()) < 0 {
		err := TransferTokenReqValidationError{
			field:  "TokenId",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for TransferType

	if len(errors) > 0 {
		return TransferTokenReqMultiError(errors)
	}

	return nil
}

// TransferTokenReqMultiError is an error wrapping multiple validation errors
// returned by TransferTokenReq.ValidateAll() if the designated constraints
// aren't met.
type TransferTokenReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferTokenReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferTokenReqMultiError) AllErrors() []error { return m }

// TransferTokenReqValidationError is the validation error returned by
// TransferTokenReq.Validate if the designated constraints aren't met.
type TransferTokenReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferTokenReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferTokenReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferTokenReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferTokenReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferTokenReqValidationError) ErrorName() string { return "TransferTokenReqValidationError" }

// Error satisfies the builtin error interface
func (e TransferTokenReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransferTokenReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferTokenReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferTokenReqValidationError{}

// Validate checks the field values on TransferTokenResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TransferTokenResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransferTokenResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransferTokenRespMultiError, or nil if none found.
func (m *TransferTokenResp) ValidateAll() error {
	return m.validate(true)
}

func (m *TransferTokenResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransferTokenRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransferTokenRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransferTokenRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TransferTokenRespMultiError(errors)
	}

	return nil
}

// TransferTokenRespMultiError is an error wrapping multiple validation errors
// returned by TransferTokenResp.ValidateAll() if the designated constraints
// aren't met.
type TransferTokenRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferTokenRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferTokenRespMultiError) AllErrors() []error { return m }

// TransferTokenRespValidationError is the validation error returned by
// TransferTokenResp.Validate if the designated constraints aren't met.
type TransferTokenRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferTokenRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferTokenRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferTokenRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferTokenRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferTokenRespValidationError) ErrorName() string {
	return "TransferTokenRespValidationError"
}

// Error satisfies the builtin error interface
func (e TransferTokenRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransferTokenResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferTokenRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferTokenRespValidationError{}

// Validate checks the field values on TicketFields with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TicketFields) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TicketFields with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TicketFieldsMultiError, or
// nil if none found.
func (m *TicketFields) ValidateAll() error {
	return m.validate(true)
}

func (m *TicketFields) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TicketType

	if all {
		switch v := interface{}(m.GetScenceInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketFieldsValidationError{
					field:  "ScenceInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketFieldsValidationError{
					field:  "ScenceInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScenceInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketFieldsValidationError{
				field:  "ScenceInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRules()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketFieldsValidationError{
					field:  "Rules",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketFieldsValidationError{
					field:  "Rules",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRules()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketFieldsValidationError{
				field:  "Rules",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetProductsItems()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketFieldsValidationError{
					field:  "ProductsItems",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketFieldsValidationError{
					field:  "ProductsItems",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProductsItems()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketFieldsValidationError{
				field:  "ProductsItems",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPrices()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketFieldsValidationError{
					field:  "Prices",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketFieldsValidationError{
					field:  "Prices",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrices()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketFieldsValidationError{
				field:  "Prices",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTicketInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketFieldsValidationError{
					field:  "TicketInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketFieldsValidationError{
					field:  "TicketInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTicketInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketFieldsValidationError{
				field:  "TicketInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TicketFieldsMultiError(errors)
	}

	return nil
}

// TicketFieldsMultiError is an error wrapping multiple validation errors
// returned by TicketFields.ValidateAll() if the designated constraints aren't met.
type TicketFieldsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TicketFieldsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TicketFieldsMultiError) AllErrors() []error { return m }

// TicketFieldsValidationError is the validation error returned by
// TicketFields.Validate if the designated constraints aren't met.
type TicketFieldsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TicketFieldsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TicketFieldsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TicketFieldsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TicketFieldsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TicketFieldsValidationError) ErrorName() string { return "TicketFieldsValidationError" }

// Error satisfies the builtin error interface
func (e TicketFieldsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTicketFields.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TicketFieldsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TicketFieldsValidationError{}

// Validate checks the field values on ScenceInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ScenceInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScenceInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScenceInfoMultiError, or
// nil if none found.
func (m *ScenceInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ScenceInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ScenicName

	// no validation rules for Rating

	// no validation rules for BusinessTime

	// no validation rules for Location

	// no validation rules for EnterpriseName

	// no validation rules for MerchantId

	if len(errors) > 0 {
		return ScenceInfoMultiError(errors)
	}

	return nil
}

// ScenceInfoMultiError is an error wrapping multiple validation errors
// returned by ScenceInfo.ValidateAll() if the designated constraints aren't met.
type ScenceInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScenceInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScenceInfoMultiError) AllErrors() []error { return m }

// ScenceInfoValidationError is the validation error returned by
// ScenceInfo.Validate if the designated constraints aren't met.
type ScenceInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScenceInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScenceInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScenceInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScenceInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScenceInfoValidationError) ErrorName() string { return "ScenceInfoValidationError" }

// Error satisfies the builtin error interface
func (e ScenceInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScenceInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScenceInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScenceInfoValidationError{}

// Validate checks the field values on TicketingRules with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TicketingRules) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TicketingRules with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TicketingRulesMultiError,
// or nil if none found.
func (m *TicketingRules) ValidateAll() error {
	return m.validate(true)
}

func (m *TicketingRules) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TicketingType

	// no validation rules for UsageTimeAfterPurchase

	// no validation rules for TicketingPeriod

	// no validation rules for RealNameVerification

	// no validation rules for RealNameVerificationValidation

	// no validation rules for PersonalPurchaseRestriction

	// no validation rules for TicketIssuanceImmediateVerification

	// no validation rules for WindowSaleOnly

	if len(errors) > 0 {
		return TicketingRulesMultiError(errors)
	}

	return nil
}

// TicketingRulesMultiError is an error wrapping multiple validation errors
// returned by TicketingRules.ValidateAll() if the designated constraints
// aren't met.
type TicketingRulesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TicketingRulesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TicketingRulesMultiError) AllErrors() []error { return m }

// TicketingRulesValidationError is the validation error returned by
// TicketingRules.Validate if the designated constraints aren't met.
type TicketingRulesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TicketingRulesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TicketingRulesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TicketingRulesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TicketingRulesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TicketingRulesValidationError) ErrorName() string { return "TicketingRulesValidationError" }

// Error satisfies the builtin error interface
func (e TicketingRulesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTicketingRules.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TicketingRulesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TicketingRulesValidationError{}

// Validate checks the field values on RefundRules with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RefundRules) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefundRules with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RefundRulesMultiError, or
// nil if none found.
func (m *RefundRules) ValidateAll() error {
	return m.validate(true)
}

func (m *RefundRules) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Refundable

	// no validation rules for RefundPeriodRate

	if len(errors) > 0 {
		return RefundRulesMultiError(errors)
	}

	return nil
}

// RefundRulesMultiError is an error wrapping multiple validation errors
// returned by RefundRules.ValidateAll() if the designated constraints aren't met.
type RefundRulesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefundRulesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefundRulesMultiError) AllErrors() []error { return m }

// RefundRulesValidationError is the validation error returned by
// RefundRules.Validate if the designated constraints aren't met.
type RefundRulesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefundRulesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefundRulesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefundRulesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefundRulesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefundRulesValidationError) ErrorName() string { return "RefundRulesValidationError" }

// Error satisfies the builtin error interface
func (e RefundRulesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefundRules.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefundRulesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefundRulesValidationError{}

// Validate checks the field values on CheckRules with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CheckRules) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckRules with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CheckRulesMultiError, or
// nil if none found.
func (m *CheckRules) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckRules) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RealNameVerificationIdMethod

	// no validation rules for Checkpoint

	// no validation rules for PassageWay

	// no validation rules for TimedTicketReservation

	if len(errors) > 0 {
		return CheckRulesMultiError(errors)
	}

	return nil
}

// CheckRulesMultiError is an error wrapping multiple validation errors
// returned by CheckRules.ValidateAll() if the designated constraints aren't met.
type CheckRulesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckRulesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckRulesMultiError) AllErrors() []error { return m }

// CheckRulesValidationError is the validation error returned by
// CheckRules.Validate if the designated constraints aren't met.
type CheckRulesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckRulesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckRulesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckRulesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckRulesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckRulesValidationError) ErrorName() string { return "CheckRulesValidationError" }

// Error satisfies the builtin error interface
func (e CheckRulesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckRules.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckRulesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckRulesValidationError{}

// Validate checks the field values on Rules with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Rules) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Rules with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RulesMultiError, or nil if none found.
func (m *Rules) ValidateAll() error {
	return m.validate(true)
}

func (m *Rules) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTicketingRules()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RulesValidationError{
					field:  "TicketingRules",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RulesValidationError{
					field:  "TicketingRules",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTicketingRules()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RulesValidationError{
				field:  "TicketingRules",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRefundRules()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RulesValidationError{
					field:  "RefundRules",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RulesValidationError{
					field:  "RefundRules",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefundRules()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RulesValidationError{
				field:  "RefundRules",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCheckRules()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RulesValidationError{
					field:  "CheckRules",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RulesValidationError{
					field:  "CheckRules",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCheckRules()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RulesValidationError{
				field:  "CheckRules",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RulesMultiError(errors)
	}

	return nil
}

// RulesMultiError is an error wrapping multiple validation errors returned by
// Rules.ValidateAll() if the designated constraints aren't met.
type RulesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RulesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RulesMultiError) AllErrors() []error { return m }

// RulesValidationError is the validation error returned by Rules.Validate if
// the designated constraints aren't met.
type RulesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RulesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RulesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RulesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RulesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RulesValidationError) ErrorName() string { return "RulesValidationError" }

// Error satisfies the builtin error interface
func (e RulesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRules.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RulesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RulesValidationError{}

// Validate checks the field values on Products with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Products) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Products with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProductsMultiError, or nil
// if none found.
func (m *Products) ValidateAll() error {
	return m.validate(true)
}

func (m *Products) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProductType

	// no validation rules for ProductName

	// no validation rules for ValidDuration

	// no validation rules for FirstDayActivation

	// no validation rules for DaysValidForEntry

	// no validation rules for UsageCount

	// no validation rules for SellByWeek

	// no validation rules for ProductsTimedReservation

	// no validation rules for EntryStatistics

	// no validation rules for EntryRequirements

	if len(errors) > 0 {
		return ProductsMultiError(errors)
	}

	return nil
}

// ProductsMultiError is an error wrapping multiple validation errors returned
// by Products.ValidateAll() if the designated constraints aren't met.
type ProductsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductsMultiError) AllErrors() []error { return m }

// ProductsValidationError is the validation error returned by
// Products.Validate if the designated constraints aren't met.
type ProductsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductsValidationError) ErrorName() string { return "ProductsValidationError" }

// Error satisfies the builtin error interface
func (e ProductsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProducts.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductsValidationError{}

// Validate checks the field values on Items with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Items) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Items with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ItemsMultiError, or nil if none found.
func (m *Items) ValidateAll() error {
	return m.validate(true)
}

func (m *Items) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ItemName

	// no validation rules for TicketCategory

	// no validation rules for PurchaseQuantityControl

	if len(errors) > 0 {
		return ItemsMultiError(errors)
	}

	return nil
}

// ItemsMultiError is an error wrapping multiple validation errors returned by
// Items.ValidateAll() if the designated constraints aren't met.
type ItemsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ItemsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ItemsMultiError) AllErrors() []error { return m }

// ItemsValidationError is the validation error returned by Items.Validate if
// the designated constraints aren't met.
type ItemsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ItemsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ItemsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ItemsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ItemsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ItemsValidationError) ErrorName() string { return "ItemsValidationError" }

// Error satisfies the builtin error interface
func (e ItemsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sItems.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ItemsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ItemsValidationError{}

// Validate checks the field values on Inventory with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Inventory) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Inventory with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InventoryMultiError, or nil
// if none found.
func (m *Inventory) ValidateAll() error {
	return m.validate(true)
}

func (m *Inventory) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TotalInventory

	// no validation rules for TimedInventory

	// no validation rules for PurchaseValidityDate

	// no validation rules for EntryValidityDate

	if len(errors) > 0 {
		return InventoryMultiError(errors)
	}

	return nil
}

// InventoryMultiError is an error wrapping multiple validation errors returned
// by Inventory.ValidateAll() if the designated constraints aren't met.
type InventoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InventoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InventoryMultiError) AllErrors() []error { return m }

// InventoryValidationError is the validation error returned by
// Inventory.Validate if the designated constraints aren't met.
type InventoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InventoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InventoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InventoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InventoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InventoryValidationError) ErrorName() string { return "InventoryValidationError" }

// Error satisfies the builtin error interface
func (e InventoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInventory.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InventoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InventoryValidationError{}

// Validate checks the field values on ProductsItems with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProductsItems) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductsItems with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProductsItemsMultiError, or
// nil if none found.
func (m *ProductsItems) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductsItems) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProducts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductsItemsValidationError{
					field:  "Products",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductsItemsValidationError{
					field:  "Products",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProducts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductsItemsValidationError{
				field:  "Products",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetItems()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductsItemsValidationError{
					field:  "Items",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductsItemsValidationError{
					field:  "Items",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItems()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductsItemsValidationError{
				field:  "Items",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInventory()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductsItemsValidationError{
					field:  "Inventory",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductsItemsValidationError{
					field:  "Inventory",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInventory()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductsItemsValidationError{
				field:  "Inventory",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProductsItemsMultiError(errors)
	}

	return nil
}

// ProductsItemsMultiError is an error wrapping multiple validation errors
// returned by ProductsItems.ValidateAll() if the designated constraints
// aren't met.
type ProductsItemsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductsItemsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductsItemsMultiError) AllErrors() []error { return m }

// ProductsItemsValidationError is the validation error returned by
// ProductsItems.Validate if the designated constraints aren't met.
type ProductsItemsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductsItemsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductsItemsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductsItemsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductsItemsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductsItemsValidationError) ErrorName() string { return "ProductsItemsValidationError" }

// Error satisfies the builtin error interface
func (e ProductsItemsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductsItems.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductsItemsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductsItemsValidationError{}

// Validate checks the field values on InitalInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InitalInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitalInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InitalInfoMultiError, or
// nil if none found.
func (m *InitalInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *InitalInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MarketStandardPrice

	// no validation rules for SpecialDiscountRate

	// no validation rules for DistributionDiscountRange

	if len(errors) > 0 {
		return InitalInfoMultiError(errors)
	}

	return nil
}

// InitalInfoMultiError is an error wrapping multiple validation errors
// returned by InitalInfo.ValidateAll() if the designated constraints aren't met.
type InitalInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitalInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitalInfoMultiError) AllErrors() []error { return m }

// InitalInfoValidationError is the validation error returned by
// InitalInfo.Validate if the designated constraints aren't met.
type InitalInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitalInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitalInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitalInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitalInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitalInfoValidationError) ErrorName() string { return "InitalInfoValidationError" }

// Error satisfies the builtin error interface
func (e InitalInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitalInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitalInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitalInfoValidationError{}

// Validate checks the field values on DirectSales with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DirectSales) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DirectSales with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DirectSalesMultiError, or
// nil if none found.
func (m *DirectSales) ValidateAll() error {
	return m.validate(true)
}

func (m *DirectSales) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DirectSinglePurchasePrice

	// no validation rules for DirectCombinedPurchasePrice

	if len(errors) > 0 {
		return DirectSalesMultiError(errors)
	}

	return nil
}

// DirectSalesMultiError is an error wrapping multiple validation errors
// returned by DirectSales.ValidateAll() if the designated constraints aren't met.
type DirectSalesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DirectSalesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DirectSalesMultiError) AllErrors() []error { return m }

// DirectSalesValidationError is the validation error returned by
// DirectSales.Validate if the designated constraints aren't met.
type DirectSalesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DirectSalesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DirectSalesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DirectSalesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DirectSalesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DirectSalesValidationError) ErrorName() string { return "DirectSalesValidationError" }

// Error satisfies the builtin error interface
func (e DirectSalesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDirectSales.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DirectSalesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DirectSalesValidationError{}

// Validate checks the field values on Agent with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Agent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Agent with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AgentMultiError, or nil if none found.
func (m *Agent) ValidateAll() error {
	return m.validate(true)
}

func (m *Agent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AgentSinglePurchasePrice

	// no validation rules for AgentCombinedPurchasePrice

	// no validation rules for CommissionRatio

	if len(errors) > 0 {
		return AgentMultiError(errors)
	}

	return nil
}

// AgentMultiError is an error wrapping multiple validation errors returned by
// Agent.ValidateAll() if the designated constraints aren't met.
type AgentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AgentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AgentMultiError) AllErrors() []error { return m }

// AgentValidationError is the validation error returned by Agent.Validate if
// the designated constraints aren't met.
type AgentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AgentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AgentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AgentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AgentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AgentValidationError) ErrorName() string { return "AgentValidationError" }

// Error satisfies the builtin error interface
func (e AgentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAgent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AgentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AgentValidationError{}

// Validate checks the field values on Distributor with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Distributor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Distributor with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DistributorMultiError, or
// nil if none found.
func (m *Distributor) ValidateAll() error {
	return m.validate(true)
}

func (m *Distributor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProductSalesPrice

	// no validation rules for ItemSalesPrice

	if len(errors) > 0 {
		return DistributorMultiError(errors)
	}

	return nil
}

// DistributorMultiError is an error wrapping multiple validation errors
// returned by Distributor.ValidateAll() if the designated constraints aren't met.
type DistributorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DistributorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DistributorMultiError) AllErrors() []error { return m }

// DistributorValidationError is the validation error returned by
// Distributor.Validate if the designated constraints aren't met.
type DistributorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DistributorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DistributorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DistributorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DistributorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DistributorValidationError) ErrorName() string { return "DistributorValidationError" }

// Error satisfies the builtin error interface
func (e DistributorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDistributor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DistributorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DistributorValidationError{}

// Validate checks the field values on PricingStrategy with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PricingStrategy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PricingStrategy with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PricingStrategyMultiError, or nil if none found.
func (m *PricingStrategy) ValidateAll() error {
	return m.validate(true)
}

func (m *PricingStrategy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDirectSales()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PricingStrategyValidationError{
					field:  "DirectSales",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PricingStrategyValidationError{
					field:  "DirectSales",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectSales()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PricingStrategyValidationError{
				field:  "DirectSales",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAgent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PricingStrategyValidationError{
					field:  "Agent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PricingStrategyValidationError{
					field:  "Agent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAgent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PricingStrategyValidationError{
				field:  "Agent",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDistributor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PricingStrategyValidationError{
					field:  "Distributor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PricingStrategyValidationError{
					field:  "Distributor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDistributor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PricingStrategyValidationError{
				field:  "Distributor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PricingStrategyMultiError(errors)
	}

	return nil
}

// PricingStrategyMultiError is an error wrapping multiple validation errors
// returned by PricingStrategy.ValidateAll() if the designated constraints
// aren't met.
type PricingStrategyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PricingStrategyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PricingStrategyMultiError) AllErrors() []error { return m }

// PricingStrategyValidationError is the validation error returned by
// PricingStrategy.Validate if the designated constraints aren't met.
type PricingStrategyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PricingStrategyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PricingStrategyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PricingStrategyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PricingStrategyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PricingStrategyValidationError) ErrorName() string { return "PricingStrategyValidationError" }

// Error satisfies the builtin error interface
func (e PricingStrategyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPricingStrategy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PricingStrategyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PricingStrategyValidationError{}

// Validate checks the field values on Prices with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Prices) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Prices with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PricesMultiError, or nil if none found.
func (m *Prices) ValidateAll() error {
	return m.validate(true)
}

func (m *Prices) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInitalInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PricesValidationError{
					field:  "InitalInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PricesValidationError{
					field:  "InitalInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitalInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PricesValidationError{
				field:  "InitalInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPricingStrategy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PricesValidationError{
					field:  "PricingStrategy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PricesValidationError{
					field:  "PricingStrategy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPricingStrategy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PricesValidationError{
				field:  "PricingStrategy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PricesMultiError(errors)
	}

	return nil
}

// PricesMultiError is an error wrapping multiple validation errors returned by
// Prices.ValidateAll() if the designated constraints aren't met.
type PricesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PricesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PricesMultiError) AllErrors() []error { return m }

// PricesValidationError is the validation error returned by Prices.Validate if
// the designated constraints aren't met.
type PricesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PricesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PricesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PricesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PricesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PricesValidationError) ErrorName() string { return "PricesValidationError" }

// Error satisfies the builtin error interface
func (e PricesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrices.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PricesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PricesValidationError{}

// Validate checks the field values on ItemInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ItemInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ItemInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ItemInfoMultiError, or nil
// if none found.
func (m *ItemInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ItemInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SellingPrice

	if len(errors) > 0 {
		return ItemInfoMultiError(errors)
	}

	return nil
}

// ItemInfoMultiError is an error wrapping multiple validation errors returned
// by ItemInfo.ValidateAll() if the designated constraints aren't met.
type ItemInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ItemInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ItemInfoMultiError) AllErrors() []error { return m }

// ItemInfoValidationError is the validation error returned by
// ItemInfo.Validate if the designated constraints aren't met.
type ItemInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ItemInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ItemInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ItemInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ItemInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ItemInfoValidationError) ErrorName() string { return "ItemInfoValidationError" }

// Error satisfies the builtin error interface
func (e ItemInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sItemInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ItemInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ItemInfoValidationError{}

// Validate checks the field values on UserIdentityInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserIdentityInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserIdentityInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserIdentityInfoMultiError, or nil if none found.
func (m *UserIdentityInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserIdentityInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserName

	// no validation rules for IdNumber

	if len(errors) > 0 {
		return UserIdentityInfoMultiError(errors)
	}

	return nil
}

// UserIdentityInfoMultiError is an error wrapping multiple validation errors
// returned by UserIdentityInfo.ValidateAll() if the designated constraints
// aren't met.
type UserIdentityInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserIdentityInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserIdentityInfoMultiError) AllErrors() []error { return m }

// UserIdentityInfoValidationError is the validation error returned by
// UserIdentityInfo.Validate if the designated constraints aren't met.
type UserIdentityInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserIdentityInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserIdentityInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserIdentityInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserIdentityInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserIdentityInfoValidationError) ErrorName() string { return "UserIdentityInfoValidationError" }

// Error satisfies the builtin error interface
func (e UserIdentityInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserIdentityInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserIdentityInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserIdentityInfoValidationError{}

// Validate checks the field values on TicketReceiverInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TicketReceiverInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TicketReceiverInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TicketReceiverInfoMultiError, or nil if none found.
func (m *TicketReceiverInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *TicketReceiverInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ContactPerson

	// no validation rules for ContactNumber

	// no validation rules for IdCard

	if len(errors) > 0 {
		return TicketReceiverInfoMultiError(errors)
	}

	return nil
}

// TicketReceiverInfoMultiError is an error wrapping multiple validation errors
// returned by TicketReceiverInfo.ValidateAll() if the designated constraints
// aren't met.
type TicketReceiverInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TicketReceiverInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TicketReceiverInfoMultiError) AllErrors() []error { return m }

// TicketReceiverInfoValidationError is the validation error returned by
// TicketReceiverInfo.Validate if the designated constraints aren't met.
type TicketReceiverInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TicketReceiverInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TicketReceiverInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TicketReceiverInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TicketReceiverInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TicketReceiverInfoValidationError) ErrorName() string {
	return "TicketReceiverInfoValidationError"
}

// Error satisfies the builtin error interface
func (e TicketReceiverInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTicketReceiverInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TicketReceiverInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TicketReceiverInfoValidationError{}

// Validate checks the field values on VerificationRecords with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VerificationRecords) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VerificationRecords with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VerificationRecordsMultiError, or nil if none found.
func (m *VerificationRecords) ValidateAll() error {
	return m.validate(true)
}

func (m *VerificationRecords) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for VerificationDeviceNameType

	// no validation rules for IdCardRecognitionType

	// no validation rules for VerificationTime

	// no validation rules for VerificationCount

	if len(errors) > 0 {
		return VerificationRecordsMultiError(errors)
	}

	return nil
}

// VerificationRecordsMultiError is an error wrapping multiple validation
// errors returned by VerificationRecords.ValidateAll() if the designated
// constraints aren't met.
type VerificationRecordsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VerificationRecordsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VerificationRecordsMultiError) AllErrors() []error { return m }

// VerificationRecordsValidationError is the validation error returned by
// VerificationRecords.Validate if the designated constraints aren't met.
type VerificationRecordsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VerificationRecordsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VerificationRecordsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VerificationRecordsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VerificationRecordsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VerificationRecordsValidationError) ErrorName() string {
	return "VerificationRecordsValidationError"
}

// Error satisfies the builtin error interface
func (e VerificationRecordsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerificationRecords.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VerificationRecordsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VerificationRecordsValidationError{}

// Validate checks the field values on RefundRecords with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RefundRecords) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefundRecords with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RefundRecordsMultiError, or
// nil if none found.
func (m *RefundRecords) ValidateAll() error {
	return m.validate(true)
}

func (m *RefundRecords) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RefundTime

	// no validation rules for RefundReason

	// no validation rules for RefundAmount

	if len(errors) > 0 {
		return RefundRecordsMultiError(errors)
	}

	return nil
}

// RefundRecordsMultiError is an error wrapping multiple validation errors
// returned by RefundRecords.ValidateAll() if the designated constraints
// aren't met.
type RefundRecordsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefundRecordsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefundRecordsMultiError) AllErrors() []error { return m }

// RefundRecordsValidationError is the validation error returned by
// RefundRecords.Validate if the designated constraints aren't met.
type RefundRecordsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefundRecordsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefundRecordsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefundRecordsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefundRecordsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefundRecordsValidationError) ErrorName() string { return "RefundRecordsValidationError" }

// Error satisfies the builtin error interface
func (e RefundRecordsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefundRecords.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefundRecordsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefundRecordsValidationError{}

// Validate checks the field values on TicketInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TicketInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TicketInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TicketInfoMultiError, or
// nil if none found.
func (m *TicketInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *TicketInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TicketNumber

	if all {
		switch v := interface{}(m.GetItemInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketInfoValidationError{
					field:  "ItemInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketInfoValidationError{
					field:  "ItemInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItemInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketInfoValidationError{
				field:  "ItemInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NumberOfPeople

	if all {
		switch v := interface{}(m.GetUserIdentityInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketInfoValidationError{
					field:  "UserIdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketInfoValidationError{
					field:  "UserIdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserIdentityInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketInfoValidationError{
				field:  "UserIdentityInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for EntryTime

	// no validation rules for TicketTimedReservation

	// no validation rules for TicketStatus

	if all {
		switch v := interface{}(m.GetTicketReceiverInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketInfoValidationError{
					field:  "TicketReceiverInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketInfoValidationError{
					field:  "TicketReceiverInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTicketReceiverInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketInfoValidationError{
				field:  "TicketReceiverInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetVerificationRecords()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketInfoValidationError{
					field:  "VerificationRecords",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketInfoValidationError{
					field:  "VerificationRecords",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVerificationRecords()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketInfoValidationError{
				field:  "VerificationRecords",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRefundRecords()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketInfoValidationError{
					field:  "RefundRecords",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketInfoValidationError{
					field:  "RefundRecords",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefundRecords()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketInfoValidationError{
				field:  "RefundRecords",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TicketInfoMultiError(errors)
	}

	return nil
}

// TicketInfoMultiError is an error wrapping multiple validation errors
// returned by TicketInfo.ValidateAll() if the designated constraints aren't met.
type TicketInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TicketInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TicketInfoMultiError) AllErrors() []error { return m }

// TicketInfoValidationError is the validation error returned by
// TicketInfo.Validate if the designated constraints aren't met.
type TicketInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TicketInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TicketInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TicketInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TicketInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TicketInfoValidationError) ErrorName() string { return "TicketInfoValidationError" }

// Error satisfies the builtin error interface
func (e TicketInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTicketInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TicketInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TicketInfoValidationError{}

// Validate checks the field values on MetaData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MetaData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetaData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MetaDataMultiError, or nil
// if none found.
func (m *MetaData) ValidateAll() error {
	return m.validate(true)
}

func (m *MetaData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TokenURI

	if len(errors) > 0 {
		return MetaDataMultiError(errors)
	}

	return nil
}

// MetaDataMultiError is an error wrapping multiple validation errors returned
// by MetaData.ValidateAll() if the designated constraints aren't met.
type MetaDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetaDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetaDataMultiError) AllErrors() []error { return m }

// MetaDataValidationError is the validation error returned by
// MetaData.Validate if the designated constraints aren't met.
type MetaDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetaDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetaDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetaDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetaDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetaDataValidationError) ErrorName() string { return "MetaDataValidationError" }

// Error satisfies the builtin error interface
func (e MetaDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetaData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetaDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetaDataValidationError{}

// Validate checks the field values on MintTokenReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MintTokenReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MintTokenReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MintTokenReqMultiError, or
// nil if none found.
func (m *MintTokenReq) ValidateAll() error {
	return m.validate(true)
}

func (m *MintTokenReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAddress()) != 42 {
		err := MintTokenReqValidationError{
			field:  "Address",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetTokenId()) < 0 {
		err := MintTokenReqValidationError{
			field:  "TokenId",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetaData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MintTokenReqValidationError{
					field:  "MetaData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MintTokenReqValidationError{
					field:  "MetaData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetaData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MintTokenReqValidationError{
				field:  "MetaData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetOrgMspID()) < 0 {
		err := MintTokenReqValidationError{
			field:  "OrgMspID",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetTicketFields()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MintTokenReqValidationError{
					field:  "TicketFields",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MintTokenReqValidationError{
					field:  "TicketFields",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTicketFields()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MintTokenReqValidationError{
				field:  "TicketFields",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MintTokenReqMultiError(errors)
	}

	return nil
}

// MintTokenReqMultiError is an error wrapping multiple validation errors
// returned by MintTokenReq.ValidateAll() if the designated constraints aren't met.
type MintTokenReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MintTokenReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MintTokenReqMultiError) AllErrors() []error { return m }

// MintTokenReqValidationError is the validation error returned by
// MintTokenReq.Validate if the designated constraints aren't met.
type MintTokenReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MintTokenReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MintTokenReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MintTokenReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MintTokenReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MintTokenReqValidationError) ErrorName() string { return "MintTokenReqValidationError" }

// Error satisfies the builtin error interface
func (e MintTokenReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMintTokenReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MintTokenReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MintTokenReqValidationError{}

// Validate checks the field values on MintTokenResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MintTokenResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MintTokenResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MintTokenRespMultiError, or
// nil if none found.
func (m *MintTokenResp) ValidateAll() error {
	return m.validate(true)
}

func (m *MintTokenResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MintTokenRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MintTokenRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MintTokenRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MintTokenRespMultiError(errors)
	}

	return nil
}

// MintTokenRespMultiError is an error wrapping multiple validation errors
// returned by MintTokenResp.ValidateAll() if the designated constraints
// aren't met.
type MintTokenRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MintTokenRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MintTokenRespMultiError) AllErrors() []error { return m }

// MintTokenRespValidationError is the validation error returned by
// MintTokenResp.Validate if the designated constraints aren't met.
type MintTokenRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MintTokenRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MintTokenRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MintTokenRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MintTokenRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MintTokenRespValidationError) ErrorName() string { return "MintTokenRespValidationError" }

// Error satisfies the builtin error interface
func (e MintTokenRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMintTokenResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MintTokenRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MintTokenRespValidationError{}

// Validate checks the field values on TicketFieldsRsp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TicketFieldsRsp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TicketFieldsRsp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TicketFieldsRspMultiError, or nil if none found.
func (m *TicketFieldsRsp) ValidateAll() error {
	return m.validate(true)
}

func (m *TicketFieldsRsp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ScenceName

	// no validation rules for Date

	// no validation rules for Location

	if len(errors) > 0 {
		return TicketFieldsRspMultiError(errors)
	}

	return nil
}

// TicketFieldsRspMultiError is an error wrapping multiple validation errors
// returned by TicketFieldsRsp.ValidateAll() if the designated constraints
// aren't met.
type TicketFieldsRspMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TicketFieldsRspMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TicketFieldsRspMultiError) AllErrors() []error { return m }

// TicketFieldsRspValidationError is the validation error returned by
// TicketFieldsRsp.Validate if the designated constraints aren't met.
type TicketFieldsRspValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TicketFieldsRspValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TicketFieldsRspValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TicketFieldsRspValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TicketFieldsRspValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TicketFieldsRspValidationError) ErrorName() string { return "TicketFieldsRspValidationError" }

// Error satisfies the builtin error interface
func (e TicketFieldsRspValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTicketFieldsRsp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TicketFieldsRspValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TicketFieldsRspValidationError{}

// Validate checks the field values on TokenInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TokenInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TokenInfoMultiError, or nil
// if none found.
func (m *TokenInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAddress()) != 42 {
		err := TokenInfoValidationError{
			field:  "Address",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetTokenId()) < 0 {
		err := TokenInfoValidationError{
			field:  "TokenId",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetaData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TokenInfoValidationError{
					field:  "MetaData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TokenInfoValidationError{
					field:  "MetaData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetaData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TokenInfoValidationError{
				field:  "MetaData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetOrgMspID()) < 0 {
		err := TokenInfoValidationError{
			field:  "OrgMspID",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetTicketFields()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TokenInfoValidationError{
					field:  "TicketFields",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TokenInfoValidationError{
					field:  "TicketFields",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTicketFields()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TokenInfoValidationError{
				field:  "TicketFields",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TokenInfoMultiError(errors)
	}

	return nil
}

// TokenInfoMultiError is an error wrapping multiple validation errors returned
// by TokenInfo.ValidateAll() if the designated constraints aren't met.
type TokenInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenInfoMultiError) AllErrors() []error { return m }

// TokenInfoValidationError is the validation error returned by
// TokenInfo.Validate if the designated constraints aren't met.
type TokenInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenInfoValidationError) ErrorName() string { return "TokenInfoValidationError" }

// Error satisfies the builtin error interface
func (e TokenInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenInfoValidationError{}

// Validate checks the field values on BatchMintTokenReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BatchMintTokenReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchMintTokenReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchMintTokenReqMultiError, or nil if none found.
func (m *BatchMintTokenReq) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchMintTokenReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTokenList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatchMintTokenReqValidationError{
						field:  fmt.Sprintf("TokenList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatchMintTokenReqValidationError{
						field:  fmt.Sprintf("TokenList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatchMintTokenReqValidationError{
					field:  fmt.Sprintf("TokenList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BatchMintTokenReqMultiError(errors)
	}

	return nil
}

// BatchMintTokenReqMultiError is an error wrapping multiple validation errors
// returned by BatchMintTokenReq.ValidateAll() if the designated constraints
// aren't met.
type BatchMintTokenReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchMintTokenReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchMintTokenReqMultiError) AllErrors() []error { return m }

// BatchMintTokenReqValidationError is the validation error returned by
// BatchMintTokenReq.Validate if the designated constraints aren't met.
type BatchMintTokenReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchMintTokenReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchMintTokenReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchMintTokenReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchMintTokenReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchMintTokenReqValidationError) ErrorName() string {
	return "BatchMintTokenReqValidationError"
}

// Error satisfies the builtin error interface
func (e BatchMintTokenReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchMintTokenReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchMintTokenReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchMintTokenReqValidationError{}

// Validate checks the field values on BatchMintTokenResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchMintTokenResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchMintTokenResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchMintTokenRespMultiError, or nil if none found.
func (m *BatchMintTokenResp) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchMintTokenResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatchMintTokenRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatchMintTokenRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatchMintTokenRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BatchMintTokenRespMultiError(errors)
	}

	return nil
}

// BatchMintTokenRespMultiError is an error wrapping multiple validation errors
// returned by BatchMintTokenResp.ValidateAll() if the designated constraints
// aren't met.
type BatchMintTokenRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchMintTokenRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchMintTokenRespMultiError) AllErrors() []error { return m }

// BatchMintTokenRespValidationError is the validation error returned by
// BatchMintTokenResp.Validate if the designated constraints aren't met.
type BatchMintTokenRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchMintTokenRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchMintTokenRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchMintTokenRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchMintTokenRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchMintTokenRespValidationError) ErrorName() string {
	return "BatchMintTokenRespValidationError"
}

// Error satisfies the builtin error interface
func (e BatchMintTokenRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchMintTokenResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchMintTokenRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchMintTokenRespValidationError{}

// Validate checks the field values on GetTokenInfoReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetTokenInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTokenInfoReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTokenInfoReqMultiError, or nil if none found.
func (m *GetTokenInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTokenInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAddress()) != 42 {
		err := GetTokenInfoReqValidationError{
			field:  "Address",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetOrgMspID()) < 0 {
		err := GetTokenInfoReqValidationError{
			field:  "OrgMspID",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTokenId()) < 0 {
		err := GetTokenInfoReqValidationError{
			field:  "TokenId",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetTokenInfoReqMultiError(errors)
	}

	return nil
}

// GetTokenInfoReqMultiError is an error wrapping multiple validation errors
// returned by GetTokenInfoReq.ValidateAll() if the designated constraints
// aren't met.
type GetTokenInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTokenInfoReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTokenInfoReqMultiError) AllErrors() []error { return m }

// GetTokenInfoReqValidationError is the validation error returned by
// GetTokenInfoReq.Validate if the designated constraints aren't met.
type GetTokenInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTokenInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTokenInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTokenInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTokenInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTokenInfoReqValidationError) ErrorName() string { return "GetTokenInfoReqValidationError" }

// Error satisfies the builtin error interface
func (e GetTokenInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTokenInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTokenInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTokenInfoReqValidationError{}

// Validate checks the field values on TokenData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TokenData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TokenDataMultiError, or nil
// if none found.
func (m *TokenData) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTokenInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TokenDataValidationError{
					field:  "TokenInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TokenDataValidationError{
					field:  "TokenInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTokenInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TokenDataValidationError{
				field:  "TokenInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TokenDataMultiError(errors)
	}

	return nil
}

// TokenDataMultiError is an error wrapping multiple validation errors returned
// by TokenData.ValidateAll() if the designated constraints aren't met.
type TokenDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenDataMultiError) AllErrors() []error { return m }

// TokenDataValidationError is the validation error returned by
// TokenData.Validate if the designated constraints aren't met.
type TokenDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenDataValidationError) ErrorName() string { return "TokenDataValidationError" }

// Error satisfies the builtin error interface
func (e TokenDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenDataValidationError{}

// Validate checks the field values on GetTokenInfoResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetTokenInfoResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTokenInfoResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTokenInfoRespMultiError, or nil if none found.
func (m *GetTokenInfoResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTokenInfoResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTokenInfoRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTokenInfoRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTokenInfoRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTokenInfoRespMultiError(errors)
	}

	return nil
}

// GetTokenInfoRespMultiError is an error wrapping multiple validation errors
// returned by GetTokenInfoResp.ValidateAll() if the designated constraints
// aren't met.
type GetTokenInfoRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTokenInfoRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTokenInfoRespMultiError) AllErrors() []error { return m }

// GetTokenInfoRespValidationError is the validation error returned by
// GetTokenInfoResp.Validate if the designated constraints aren't met.
type GetTokenInfoRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTokenInfoRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTokenInfoRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTokenInfoRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTokenInfoRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTokenInfoRespValidationError) ErrorName() string { return "GetTokenInfoRespValidationError" }

// Error satisfies the builtin error interface
func (e GetTokenInfoRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTokenInfoResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTokenInfoRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTokenInfoRespValidationError{}

// Validate checks the field values on GetTokenBalanceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTokenBalanceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTokenBalanceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTokenBalanceReqMultiError, or nil if none found.
func (m *GetTokenBalanceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTokenBalanceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAddress()) != 42 {
		err := GetTokenBalanceReqValidationError{
			field:  "Address",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetOrgMspID()) < 0 {
		err := GetTokenBalanceReqValidationError{
			field:  "OrgMspID",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetTokenBalanceReqMultiError(errors)
	}

	return nil
}

// GetTokenBalanceReqMultiError is an error wrapping multiple validation errors
// returned by GetTokenBalanceReq.ValidateAll() if the designated constraints
// aren't met.
type GetTokenBalanceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTokenBalanceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTokenBalanceReqMultiError) AllErrors() []error { return m }

// GetTokenBalanceReqValidationError is the validation error returned by
// GetTokenBalanceReq.Validate if the designated constraints aren't met.
type GetTokenBalanceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTokenBalanceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTokenBalanceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTokenBalanceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTokenBalanceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTokenBalanceReqValidationError) ErrorName() string {
	return "GetTokenBalanceReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetTokenBalanceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTokenBalanceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTokenBalanceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTokenBalanceReqValidationError{}

// Validate checks the field values on BalanceData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BalanceData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BalanceData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BalanceDataMultiError, or
// nil if none found.
func (m *BalanceData) ValidateAll() error {
	return m.validate(true)
}

func (m *BalanceData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Balance

	if len(errors) > 0 {
		return BalanceDataMultiError(errors)
	}

	return nil
}

// BalanceDataMultiError is an error wrapping multiple validation errors
// returned by BalanceData.ValidateAll() if the designated constraints aren't met.
type BalanceDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BalanceDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BalanceDataMultiError) AllErrors() []error { return m }

// BalanceDataValidationError is the validation error returned by
// BalanceData.Validate if the designated constraints aren't met.
type BalanceDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BalanceDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BalanceDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BalanceDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BalanceDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BalanceDataValidationError) ErrorName() string { return "BalanceDataValidationError" }

// Error satisfies the builtin error interface
func (e BalanceDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBalanceData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BalanceDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BalanceDataValidationError{}

// Validate checks the field values on GetTokenBalanceResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTokenBalanceResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTokenBalanceResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTokenBalanceRespMultiError, or nil if none found.
func (m *GetTokenBalanceResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTokenBalanceResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTokenBalanceRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTokenBalanceRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTokenBalanceRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTokenBalanceRespMultiError(errors)
	}

	return nil
}

// GetTokenBalanceRespMultiError is an error wrapping multiple validation
// errors returned by GetTokenBalanceResp.ValidateAll() if the designated
// constraints aren't met.
type GetTokenBalanceRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTokenBalanceRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTokenBalanceRespMultiError) AllErrors() []error { return m }

// GetTokenBalanceRespValidationError is the validation error returned by
// GetTokenBalanceResp.Validate if the designated constraints aren't met.
type GetTokenBalanceRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTokenBalanceRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTokenBalanceRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTokenBalanceRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTokenBalanceRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTokenBalanceRespValidationError) ErrorName() string {
	return "GetTokenBalanceRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetTokenBalanceRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTokenBalanceResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTokenBalanceRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTokenBalanceRespValidationError{}

// Validate checks the field values on VerifyTicketReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *VerifyTicketReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VerifyTicketReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VerifyTicketReqMultiError, or nil if none found.
func (m *VerifyTicketReq) ValidateAll() error {
	return m.validate(true)
}

func (m *VerifyTicketReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAddress()) != 42 {
		err := VerifyTicketReqValidationError{
			field:  "Address",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetOrgMspID()) < 0 {
		err := VerifyTicketReqValidationError{
			field:  "OrgMspID",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTokenId()) < 0 {
		err := VerifyTicketReqValidationError{
			field:  "TokenId",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return VerifyTicketReqMultiError(errors)
	}

	return nil
}

// VerifyTicketReqMultiError is an error wrapping multiple validation errors
// returned by VerifyTicketReq.ValidateAll() if the designated constraints
// aren't met.
type VerifyTicketReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VerifyTicketReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VerifyTicketReqMultiError) AllErrors() []error { return m }

// VerifyTicketReqValidationError is the validation error returned by
// VerifyTicketReq.Validate if the designated constraints aren't met.
type VerifyTicketReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VerifyTicketReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VerifyTicketReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VerifyTicketReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VerifyTicketReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VerifyTicketReqValidationError) ErrorName() string { return "VerifyTicketReqValidationError" }

// Error satisfies the builtin error interface
func (e VerifyTicketReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerifyTicketReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VerifyTicketReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VerifyTicketReqValidationError{}

// Validate checks the field values on TxDataV1 with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TxDataV1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TxDataV1 with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TxDataV1MultiError, or nil
// if none found.
func (m *TxDataV1) ValidateAll() error {
	return m.validate(true)
}

func (m *TxDataV1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TxId

	if len(errors) > 0 {
		return TxDataV1MultiError(errors)
	}

	return nil
}

// TxDataV1MultiError is an error wrapping multiple validation errors returned
// by TxDataV1.ValidateAll() if the designated constraints aren't met.
type TxDataV1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TxDataV1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TxDataV1MultiError) AllErrors() []error { return m }

// TxDataV1ValidationError is the validation error returned by
// TxDataV1.Validate if the designated constraints aren't met.
type TxDataV1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TxDataV1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TxDataV1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TxDataV1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TxDataV1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TxDataV1ValidationError) ErrorName() string { return "TxDataV1ValidationError" }

// Error satisfies the builtin error interface
func (e TxDataV1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTxDataV1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TxDataV1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TxDataV1ValidationError{}

// Validate checks the field values on VerifyTicketResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *VerifyTicketResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VerifyTicketResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VerifyTicketRespMultiError, or nil if none found.
func (m *VerifyTicketResp) ValidateAll() error {
	return m.validate(true)
}

func (m *VerifyTicketResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VerifyTicketRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VerifyTicketRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VerifyTicketRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return VerifyTicketRespMultiError(errors)
	}

	return nil
}

// VerifyTicketRespMultiError is an error wrapping multiple validation errors
// returned by VerifyTicketResp.ValidateAll() if the designated constraints
// aren't met.
type VerifyTicketRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VerifyTicketRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VerifyTicketRespMultiError) AllErrors() []error { return m }

// VerifyTicketRespValidationError is the validation error returned by
// VerifyTicketResp.Validate if the designated constraints aren't met.
type VerifyTicketRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VerifyTicketRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VerifyTicketRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VerifyTicketRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VerifyTicketRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VerifyTicketRespValidationError) ErrorName() string { return "VerifyTicketRespValidationError" }

// Error satisfies the builtin error interface
func (e VerifyTicketRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerifyTicketResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VerifyTicketRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VerifyTicketRespValidationError{}

// Validate checks the field values on UpdateTicketStatusReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTicketStatusReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTicketStatusReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTicketStatusReqMultiError, or nil if none found.
func (m *UpdateTicketStatusReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTicketStatusReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAddress()) != 42 {
		err := UpdateTicketStatusReqValidationError{
			field:  "Address",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetOrgMspID()) < 0 {
		err := UpdateTicketStatusReqValidationError{
			field:  "OrgMspID",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTokenId()) < 0 {
		err := UpdateTicketStatusReqValidationError{
			field:  "TokenId",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNewStatus()) < 0 {
		err := UpdateTicketStatusReqValidationError{
			field:  "NewStatus",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateTicketStatusReqMultiError(errors)
	}

	return nil
}

// UpdateTicketStatusReqMultiError is an error wrapping multiple validation
// errors returned by UpdateTicketStatusReq.ValidateAll() if the designated
// constraints aren't met.
type UpdateTicketStatusReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTicketStatusReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTicketStatusReqMultiError) AllErrors() []error { return m }

// UpdateTicketStatusReqValidationError is the validation error returned by
// UpdateTicketStatusReq.Validate if the designated constraints aren't met.
type UpdateTicketStatusReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTicketStatusReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTicketStatusReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTicketStatusReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTicketStatusReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTicketStatusReqValidationError) ErrorName() string {
	return "UpdateTicketStatusReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTicketStatusReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTicketStatusReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTicketStatusReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTicketStatusReqValidationError{}

// Validate checks the field values on UpdateTicketStatusResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTicketStatusResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTicketStatusResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTicketStatusRespMultiError, or nil if none found.
func (m *UpdateTicketStatusResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTicketStatusResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateTicketStatusRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateTicketStatusRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateTicketStatusRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateTicketStatusRespMultiError(errors)
	}

	return nil
}

// UpdateTicketStatusRespMultiError is an error wrapping multiple validation
// errors returned by UpdateTicketStatusResp.ValidateAll() if the designated
// constraints aren't met.
type UpdateTicketStatusRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTicketStatusRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTicketStatusRespMultiError) AllErrors() []error { return m }

// UpdateTicketStatusRespValidationError is the validation error returned by
// UpdateTicketStatusResp.Validate if the designated constraints aren't met.
type UpdateTicketStatusRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTicketStatusRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTicketStatusRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTicketStatusRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTicketStatusRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTicketStatusRespValidationError) ErrorName() string {
	return "UpdateTicketStatusRespValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTicketStatusRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTicketStatusResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTicketStatusRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTicketStatusRespValidationError{}

// Validate checks the field values on UpdateProductSalesPriceReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateProductSalesPriceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateProductSalesPriceReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateProductSalesPriceReqMultiError, or nil if none found.
func (m *UpdateProductSalesPriceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateProductSalesPriceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAddress()) != 42 {
		err := UpdateProductSalesPriceReqValidationError{
			field:  "Address",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetOrgMspID()) < 0 {
		err := UpdateProductSalesPriceReqValidationError{
			field:  "OrgMspID",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTokenId()) < 0 {
		err := UpdateProductSalesPriceReqValidationError{
			field:  "TokenId",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNewPrice()) < 0 {
		err := UpdateProductSalesPriceReqValidationError{
			field:  "NewPrice",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateProductSalesPriceReqMultiError(errors)
	}

	return nil
}

// UpdateProductSalesPriceReqMultiError is an error wrapping multiple
// validation errors returned by UpdateProductSalesPriceReq.ValidateAll() if
// the designated constraints aren't met.
type UpdateProductSalesPriceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateProductSalesPriceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateProductSalesPriceReqMultiError) AllErrors() []error { return m }

// UpdateProductSalesPriceReqValidationError is the validation error returned
// by UpdateProductSalesPriceReq.Validate if the designated constraints aren't met.
type UpdateProductSalesPriceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateProductSalesPriceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateProductSalesPriceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateProductSalesPriceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateProductSalesPriceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateProductSalesPriceReqValidationError) ErrorName() string {
	return "UpdateProductSalesPriceReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateProductSalesPriceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateProductSalesPriceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateProductSalesPriceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateProductSalesPriceReqValidationError{}

// Validate checks the field values on UpdateProductSalesPriceResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateProductSalesPriceResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateProductSalesPriceResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateProductSalesPriceRespMultiError, or nil if none found.
func (m *UpdateProductSalesPriceResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateProductSalesPriceResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateProductSalesPriceRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateProductSalesPriceRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateProductSalesPriceRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateProductSalesPriceRespMultiError(errors)
	}

	return nil
}

// UpdateProductSalesPriceRespMultiError is an error wrapping multiple
// validation errors returned by UpdateProductSalesPriceResp.ValidateAll() if
// the designated constraints aren't met.
type UpdateProductSalesPriceRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateProductSalesPriceRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateProductSalesPriceRespMultiError) AllErrors() []error { return m }

// UpdateProductSalesPriceRespValidationError is the validation error returned
// by UpdateProductSalesPriceResp.Validate if the designated constraints
// aren't met.
type UpdateProductSalesPriceRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateProductSalesPriceRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateProductSalesPriceRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateProductSalesPriceRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateProductSalesPriceRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateProductSalesPriceRespValidationError) ErrorName() string {
	return "UpdateProductSalesPriceRespValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateProductSalesPriceRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateProductSalesPriceResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateProductSalesPriceRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateProductSalesPriceRespValidationError{}

// Validate checks the field values on UpdateTicketInfoReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTicketInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTicketInfoReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTicketInfoReqMultiError, or nil if none found.
func (m *UpdateTicketInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTicketInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAddress()) != 42 {
		err := UpdateTicketInfoReqValidationError{
			field:  "Address",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetOrgMspID()) < 0 {
		err := UpdateTicketInfoReqValidationError{
			field:  "OrgMspID",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTokenId()) < 0 {
		err := UpdateTicketInfoReqValidationError{
			field:  "TokenId",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetTicketFields()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateTicketInfoReqValidationError{
					field:  "TicketFields",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateTicketInfoReqValidationError{
					field:  "TicketFields",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTicketFields()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateTicketInfoReqValidationError{
				field:  "TicketFields",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateTicketInfoReqMultiError(errors)
	}

	return nil
}

// UpdateTicketInfoReqMultiError is an error wrapping multiple validation
// errors returned by UpdateTicketInfoReq.ValidateAll() if the designated
// constraints aren't met.
type UpdateTicketInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTicketInfoReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTicketInfoReqMultiError) AllErrors() []error { return m }

// UpdateTicketInfoReqValidationError is the validation error returned by
// UpdateTicketInfoReq.Validate if the designated constraints aren't met.
type UpdateTicketInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTicketInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTicketInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTicketInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTicketInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTicketInfoReqValidationError) ErrorName() string {
	return "UpdateTicketInfoReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTicketInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTicketInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTicketInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTicketInfoReqValidationError{}

// Validate checks the field values on UpdateTicketInfoResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTicketInfoResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTicketInfoResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTicketInfoRespMultiError, or nil if none found.
func (m *UpdateTicketInfoResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTicketInfoResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateTicketInfoRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateTicketInfoRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateTicketInfoRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateTicketInfoRespMultiError(errors)
	}

	return nil
}

// UpdateTicketInfoRespMultiError is an error wrapping multiple validation
// errors returned by UpdateTicketInfoResp.ValidateAll() if the designated
// constraints aren't met.
type UpdateTicketInfoRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTicketInfoRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTicketInfoRespMultiError) AllErrors() []error { return m }

// UpdateTicketInfoRespValidationError is the validation error returned by
// UpdateTicketInfoResp.Validate if the designated constraints aren't met.
type UpdateTicketInfoRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTicketInfoRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTicketInfoRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTicketInfoRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTicketInfoRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTicketInfoRespValidationError) ErrorName() string {
	return "UpdateTicketInfoRespValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTicketInfoRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTicketInfoResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTicketInfoRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTicketInfoRespValidationError{}
