// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: pkg/pb/tickets_v2.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ParamError with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ParamError) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParamError with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ParamErrorMultiError, or
// nil if none found.
func (m *ParamError) ValidateAll() error {
	return m.validate(true)
}

func (m *ParamError) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Param

	// no validation rules for Error

	if len(errors) > 0 {
		return ParamErrorMultiError(errors)
	}

	return nil
}

// ParamErrorMultiError is an error wrapping multiple validation errors
// returned by ParamError.ValidateAll() if the designated constraints aren't met.
type ParamErrorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParamErrorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParamErrorMultiError) AllErrors() []error { return m }

// ParamErrorValidationError is the validation error returned by
// ParamError.Validate if the designated constraints aren't met.
type ParamErrorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParamErrorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParamErrorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParamErrorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParamErrorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParamErrorValidationError) ErrorName() string { return "ParamErrorValidationError" }

// Error satisfies the builtin error interface
func (e ParamErrorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParamError.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParamErrorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParamErrorValidationError{}

// Validate checks the field values on RequestMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RequestMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RequestMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RequestMessageMultiError,
// or nil if none found.
func (m *RequestMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *RequestMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestId

	// no validation rules for SerialNumber

	// no validation rules for ReferenceDate

	// no validation rules for MessageType

	switch v := m.Data.(type) {
	case *RequestMessage_TicketCheck:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTicketCheck()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "TicketCheck",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "TicketCheck",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTicketCheck()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "TicketCheck",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_CreateStock:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCreateStock()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "CreateStock",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "CreateStock",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreateStock()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "CreateStock",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_SetSelfPriceInfo:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetSelfPriceInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "SetSelfPriceInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "SetSelfPriceInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetSelfPriceInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "SetSelfPriceInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_TicketIssuance:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTicketIssuance()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "TicketIssuance",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "TicketIssuance",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTicketIssuance()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "TicketIssuance",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_GenerateTicketIssuance:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGenerateTicketIssuance()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "GenerateTicketIssuance",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "GenerateTicketIssuance",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGenerateTicketIssuance()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "GenerateTicketIssuance",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_Verification:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetVerification()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "Verification",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "Verification",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetVerification()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "Verification",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_OrderInfo:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOrderInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "OrderInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "OrderInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOrderInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "OrderInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_DistributeRefundCreate:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDistributeRefundCreate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "DistributeRefundCreate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "DistributeRefundCreate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDistributeRefundCreate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "DistributeRefundCreate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_DistributionOrderInfo:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDistributionOrderInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "DistributionOrderInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "DistributionOrderInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDistributionOrderInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "DistributionOrderInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_BlockOrderRefund:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBlockOrderRefund()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "BlockOrderRefund",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "BlockOrderRefund",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBlockOrderRefund()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "BlockOrderRefund",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_QueryTicketRecordReq:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetQueryTicketRecordReq()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "QueryTicketRecordReq",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "QueryTicketRecordReq",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetQueryTicketRecordReq()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "QueryTicketRecordReq",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_TicketStatus:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTicketStatus()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "TicketStatus",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "TicketStatus",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTicketStatus()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "TicketStatus",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_RepayRollBack:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRepayRollBack()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "RepayRollBack",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "RepayRollBack",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRepayRollBack()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "RepayRollBack",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_StockBatchInfoUpdate:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStockBatchInfoUpdate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "StockBatchInfoUpdate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "StockBatchInfoUpdate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStockBatchInfoUpdate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "StockBatchInfoUpdate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_QueryStockOptRecords:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetQueryStockOptRecords()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "QueryStockOptRecords",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "QueryStockOptRecords",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetQueryStockOptRecords()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "QueryStockOptRecords",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_ProjectBiddingRequest:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetProjectBiddingRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "ProjectBiddingRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "ProjectBiddingRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetProjectBiddingRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "ProjectBiddingRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_InstrumentTicketRequest:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetInstrumentTicketRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "InstrumentTicketRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "InstrumentTicketRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInstrumentTicketRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "InstrumentTicketRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_QueryAnnouncementOptRecordsRequest:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetQueryAnnouncementOptRecordsRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "QueryAnnouncementOptRecordsRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "QueryAnnouncementOptRecordsRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetQueryAnnouncementOptRecordsRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "QueryAnnouncementOptRecordsRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_MarginOrderRequest:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMarginOrderRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "MarginOrderRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "MarginOrderRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMarginOrderRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "MarginOrderRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_MarginOrderOverRequest:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMarginOrderOverRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "MarginOrderOverRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "MarginOrderOverRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMarginOrderOverRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "MarginOrderOverRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_CreditAssessment:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCreditAssessment()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "CreditAssessment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "CreditAssessment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreditAssessment()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "CreditAssessment",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_LoanApplication:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLoanApplication()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "LoanApplication",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "LoanApplication",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLoanApplication()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "LoanApplication",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_LoanApprovalPayment:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLoanApprovalPayment()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "LoanApprovalPayment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "LoanApprovalPayment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLoanApprovalPayment()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "LoanApprovalPayment",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_LoanRequest:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLoanRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "LoanRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "LoanRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLoanRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "LoanRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_LoanReviewDenied:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLoanReviewDenied()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "LoanReviewDenied",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "LoanReviewDenied",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLoanReviewDenied()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "LoanReviewDenied",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_LoanReviewApproved:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLoanReviewApproved()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "LoanReviewApproved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "LoanReviewApproved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLoanReviewApproved()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "LoanReviewApproved",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_LoanReapply:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLoanReapply()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "LoanReapply",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "LoanReapply",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLoanReapply()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "LoanReapply",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_PaymentScheduleGeneration:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPaymentScheduleGeneration()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "PaymentScheduleGeneration",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "PaymentScheduleGeneration",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPaymentScheduleGeneration()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "PaymentScheduleGeneration",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_RepaymentApplication:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRepaymentApplication()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "RepaymentApplication",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "RepaymentApplication",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRepaymentApplication()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "RepaymentApplication",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_RepaymentApproved:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRepaymentApproved()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "RepaymentApproved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "RepaymentApproved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRepaymentApproved()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "RepaymentApproved",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_RepaymentDenied:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRepaymentDenied()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "RepaymentDenied",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "RepaymentDenied",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRepaymentDenied()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "RepaymentDenied",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_RepaymentReapply:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRepaymentReapply()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "RepaymentReapply",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "RepaymentReapply",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRepaymentReapply()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "RepaymentReapply",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_InstrumentOrderRequest:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetInstrumentOrderRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "InstrumentOrderRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "InstrumentOrderRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInstrumentOrderRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "InstrumentOrderRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_QueryInstrumentOrderRecordRequest:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetQueryInstrumentOrderRecordRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "QueryInstrumentOrderRecordRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "QueryInstrumentOrderRecordRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetQueryInstrumentOrderRecordRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "QueryInstrumentOrderRecordRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_ConvertToInvoiceRequest:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConvertToInvoiceRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "ConvertToInvoiceRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "ConvertToInvoiceRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConvertToInvoiceRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "ConvertToInvoiceRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_RefundBalanceRequest:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRefundBalanceRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "RefundBalanceRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "RefundBalanceRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRefundBalanceRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "RefundBalanceRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_FullRefundRequest:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFullRefundRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "FullRefundRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "FullRefundRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFullRefundRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "FullRefundRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_TradeChargeRequest:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTradeChargeRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "TradeChargeRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "TradeChargeRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTradeChargeRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "TradeChargeRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_TradeChargeRecord:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTradeChargeRecord()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "TradeChargeRecord",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "TradeChargeRecord",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTradeChargeRecord()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "TradeChargeRecord",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestMessage_VoucherBlockchainRequest:
		if v == nil {
			err := RequestMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetVoucherBlockchainRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "VoucherBlockchainRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestMessageValidationError{
						field:  "VoucherBlockchainRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetVoucherBlockchainRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestMessageValidationError{
					field:  "VoucherBlockchainRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return RequestMessageMultiError(errors)
	}

	return nil
}

// RequestMessageMultiError is an error wrapping multiple validation errors
// returned by RequestMessage.ValidateAll() if the designated constraints
// aren't met.
type RequestMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestMessageMultiError) AllErrors() []error { return m }

// RequestMessageValidationError is the validation error returned by
// RequestMessage.Validate if the designated constraints aren't met.
type RequestMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestMessageValidationError) ErrorName() string { return "RequestMessageValidationError" }

// Error satisfies the builtin error interface
func (e RequestMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestMessageValidationError{}

// Validate checks the field values on ResponseMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ResponseMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResponseMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResponseMessageMultiError, or nil if none found.
func (m *ResponseMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *ResponseMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestId

	// no validation rules for Code

	// no validation rules for Message

	for idx, item := range m.GetParamErrors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  fmt.Sprintf("ParamErrors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  fmt.Sprintf("ParamErrors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  fmt.Sprintf("ParamErrors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ReferenceDate

	// no validation rules for MessageType

	switch v := m.Data.(type) {
	case *ResponseMessage_TicketCheck:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTicketCheck()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "TicketCheck",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "TicketCheck",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTicketCheck()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "TicketCheck",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_CreateStock:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCreateStock()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "CreateStock",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "CreateStock",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreateStock()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "CreateStock",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_SetSelfPriceInfo:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetSelfPriceInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "SetSelfPriceInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "SetSelfPriceInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetSelfPriceInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "SetSelfPriceInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_TicketIssuance:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTicketIssuance()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "TicketIssuance",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "TicketIssuance",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTicketIssuance()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "TicketIssuance",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_Generate_Ticket_Issuance:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGenerate_Ticket_Issuance()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "Generate_Ticket_Issuance",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "Generate_Ticket_Issuance",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGenerate_Ticket_Issuance()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "Generate_Ticket_Issuance",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_Verification:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetVerification()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "Verification",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "Verification",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetVerification()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "Verification",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_OrderInfo:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOrderInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "OrderInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "OrderInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOrderInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "OrderInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_TicketStatusResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTicketStatusResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "TicketStatusResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "TicketStatusResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTicketStatusResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "TicketStatusResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_DistributeRefundCreate:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDistributeRefundCreate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "DistributeRefundCreate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "DistributeRefundCreate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDistributeRefundCreate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "DistributeRefundCreate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_DistributionOrderInfoResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDistributionOrderInfoResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "DistributionOrderInfoResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "DistributionOrderInfoResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDistributionOrderInfoResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "DistributionOrderInfoResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_BlockOrderRefundResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBlockOrderRefundResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "BlockOrderRefundResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "BlockOrderRefundResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBlockOrderRefundResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "BlockOrderRefundResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_QueryTicketRecordRes:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetQueryTicketRecordRes()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "QueryTicketRecordRes",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "QueryTicketRecordRes",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetQueryTicketRecordRes()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "QueryTicketRecordRes",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_TicketStatusPushResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTicketStatusPushResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "TicketStatusPushResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "TicketStatusPushResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTicketStatusPushResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "TicketStatusPushResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_RepayRollBackResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRepayRollBackResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "RepayRollBackResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "RepayRollBackResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRepayRollBackResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "RepayRollBackResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_StockBatchInfoUpdateResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStockBatchInfoUpdateResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "StockBatchInfoUpdateResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "StockBatchInfoUpdateResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStockBatchInfoUpdateResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "StockBatchInfoUpdateResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_QueryStockOptRecordsResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetQueryStockOptRecordsResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "QueryStockOptRecordsResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "QueryStockOptRecordsResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetQueryStockOptRecordsResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "QueryStockOptRecordsResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_ProjectBiddingResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetProjectBiddingResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "ProjectBiddingResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "ProjectBiddingResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetProjectBiddingResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "ProjectBiddingResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_InstrumentTicketResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetInstrumentTicketResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "InstrumentTicketResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "InstrumentTicketResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInstrumentTicketResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "InstrumentTicketResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_QueryAnnouncementOptRecordsResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetQueryAnnouncementOptRecordsResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "QueryAnnouncementOptRecordsResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "QueryAnnouncementOptRecordsResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetQueryAnnouncementOptRecordsResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "QueryAnnouncementOptRecordsResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_MarginOrderResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMarginOrderResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "MarginOrderResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "MarginOrderResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMarginOrderResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "MarginOrderResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_MarginOrderOverResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMarginOrderOverResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "MarginOrderOverResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "MarginOrderOverResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMarginOrderOverResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "MarginOrderOverResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_CreditAssessmentResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCreditAssessmentResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "CreditAssessmentResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "CreditAssessmentResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreditAssessmentResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "CreditAssessmentResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_LoanApplicationResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLoanApplicationResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "LoanApplicationResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "LoanApplicationResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLoanApplicationResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "LoanApplicationResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_LoanApprovalPaymentResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLoanApprovalPaymentResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "LoanApprovalPaymentResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "LoanApprovalPaymentResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLoanApprovalPaymentResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "LoanApprovalPaymentResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_LoanRequestResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLoanRequestResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "LoanRequestResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "LoanRequestResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLoanRequestResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "LoanRequestResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_LoanReviewDeniedResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLoanReviewDeniedResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "LoanReviewDeniedResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "LoanReviewDeniedResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLoanReviewDeniedResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "LoanReviewDeniedResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_LoanReviewApprovedResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLoanReviewApprovedResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "LoanReviewApprovedResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "LoanReviewApprovedResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLoanReviewApprovedResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "LoanReviewApprovedResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_LoanReapplyResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLoanReapplyResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "LoanReapplyResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "LoanReapplyResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLoanReapplyResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "LoanReapplyResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_PaymentScheduleGenerationResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPaymentScheduleGenerationResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "PaymentScheduleGenerationResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "PaymentScheduleGenerationResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPaymentScheduleGenerationResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "PaymentScheduleGenerationResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_RepaymentApplicationResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRepaymentApplicationResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "RepaymentApplicationResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "RepaymentApplicationResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRepaymentApplicationResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "RepaymentApplicationResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_RepaymentApprovedResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRepaymentApprovedResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "RepaymentApprovedResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "RepaymentApprovedResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRepaymentApprovedResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "RepaymentApprovedResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_RepaymentDeniedResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRepaymentDeniedResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "RepaymentDeniedResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "RepaymentDeniedResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRepaymentDeniedResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "RepaymentDeniedResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_RepaymentReapplyResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRepaymentReapplyResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "RepaymentReapplyResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "RepaymentReapplyResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRepaymentReapplyResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "RepaymentReapplyResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_InstrumentOrderResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetInstrumentOrderResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "InstrumentOrderResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "InstrumentOrderResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInstrumentOrderResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "InstrumentOrderResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_QueryInstrumentOrderRecordResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetQueryInstrumentOrderRecordResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "QueryInstrumentOrderRecordResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "QueryInstrumentOrderRecordResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetQueryInstrumentOrderRecordResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "QueryInstrumentOrderRecordResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_ConvertToInvoiceResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConvertToInvoiceResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "ConvertToInvoiceResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "ConvertToInvoiceResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConvertToInvoiceResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "ConvertToInvoiceResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_RefundBalanceResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRefundBalanceResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "RefundBalanceResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "RefundBalanceResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRefundBalanceResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "RefundBalanceResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_FullRefundResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFullRefundResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "FullRefundResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "FullRefundResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFullRefundResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "FullRefundResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_TradeChargeResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTradeChargeResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "TradeChargeResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "TradeChargeResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTradeChargeResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "TradeChargeResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_TradeChargeRecordResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTradeChargeRecordResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "TradeChargeRecordResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "TradeChargeRecordResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTradeChargeRecordResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "TradeChargeRecordResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseMessage_VoucherBlockchainResponse:
		if v == nil {
			err := ResponseMessageValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetVoucherBlockchainResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "VoucherBlockchainResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseMessageValidationError{
						field:  "VoucherBlockchainResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetVoucherBlockchainResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseMessageValidationError{
					field:  "VoucherBlockchainResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ResponseMessageMultiError(errors)
	}

	return nil
}

// ResponseMessageMultiError is an error wrapping multiple validation errors
// returned by ResponseMessage.ValidateAll() if the designated constraints
// aren't met.
type ResponseMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResponseMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResponseMessageMultiError) AllErrors() []error { return m }

// ResponseMessageValidationError is the validation error returned by
// ResponseMessage.Validate if the designated constraints aren't met.
type ResponseMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResponseMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResponseMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResponseMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResponseMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResponseMessageValidationError) ErrorName() string { return "ResponseMessageValidationError" }

// Error satisfies the builtin error interface
func (e ResponseMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResponseMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResponseMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResponseMessageValidationError{}

// Validate checks the field values on TicketStatusPushRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TicketStatusPushRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TicketStatusPushRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TicketStatusPushRequestMultiError, or nil if none found.
func (m *TicketStatusPushRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TicketStatusPushRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TicketStatusPushRequestValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TicketStatusPushRequestValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TicketStatusPushRequestValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TicketStatusPushRequestMultiError(errors)
	}

	return nil
}

// TicketStatusPushRequestMultiError is an error wrapping multiple validation
// errors returned by TicketStatusPushRequest.ValidateAll() if the designated
// constraints aren't met.
type TicketStatusPushRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TicketStatusPushRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TicketStatusPushRequestMultiError) AllErrors() []error { return m }

// TicketStatusPushRequestValidationError is the validation error returned by
// TicketStatusPushRequest.Validate if the designated constraints aren't met.
type TicketStatusPushRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TicketStatusPushRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TicketStatusPushRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TicketStatusPushRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TicketStatusPushRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TicketStatusPushRequestValidationError) ErrorName() string {
	return "TicketStatusPushRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TicketStatusPushRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTicketStatusPushRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TicketStatusPushRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TicketStatusPushRequestValidationError{}

// Validate checks the field values on TicketStatusPushResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TicketStatusPushResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TicketStatusPushResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TicketStatusPushResponseMultiError, or nil if none found.
func (m *TicketStatusPushResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TicketStatusPushResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketStatusPushResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketStatusPushResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketStatusPushResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TicketStatusPushResponseMultiError(errors)
	}

	return nil
}

// TicketStatusPushResponseMultiError is an error wrapping multiple validation
// errors returned by TicketStatusPushResponse.ValidateAll() if the designated
// constraints aren't met.
type TicketStatusPushResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TicketStatusPushResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TicketStatusPushResponseMultiError) AllErrors() []error { return m }

// TicketStatusPushResponseValidationError is the validation error returned by
// TicketStatusPushResponse.Validate if the designated constraints aren't met.
type TicketStatusPushResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TicketStatusPushResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TicketStatusPushResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TicketStatusPushResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TicketStatusPushResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TicketStatusPushResponseValidationError) ErrorName() string {
	return "TicketStatusPushResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TicketStatusPushResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTicketStatusPushResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TicketStatusPushResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TicketStatusPushResponseValidationError{}

// Validate checks the field values on TicketStatusInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TicketStatusInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TicketStatusInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TicketStatusInfoMultiError, or nil if none found.
func (m *TicketStatusInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *TicketStatusInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TxId

	// no validation rules for TicketNumber

	// no validation rules for TicketStatus

	// no validation rules for UsedCount

	// no validation rules for CheckedNum

	// no validation rules for UsedDays

	if len(errors) > 0 {
		return TicketStatusInfoMultiError(errors)
	}

	return nil
}

// TicketStatusInfoMultiError is an error wrapping multiple validation errors
// returned by TicketStatusInfo.ValidateAll() if the designated constraints
// aren't met.
type TicketStatusInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TicketStatusInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TicketStatusInfoMultiError) AllErrors() []error { return m }

// TicketStatusInfoValidationError is the validation error returned by
// TicketStatusInfo.Validate if the designated constraints aren't met.
type TicketStatusInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TicketStatusInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TicketStatusInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TicketStatusInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TicketStatusInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TicketStatusInfoValidationError) ErrorName() string { return "TicketStatusInfoValidationError" }

// Error satisfies the builtin error interface
func (e TicketStatusInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTicketStatusInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TicketStatusInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TicketStatusInfoValidationError{}

// Validate checks the field values on BlockChainTicketCheckRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BlockChainTicketCheckRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlockChainTicketCheckRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BlockChainTicketCheckRequestMultiError, or nil if none found.
func (m *BlockChainTicketCheckRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BlockChainTicketCheckRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAccount()) != 42 {
		err := BlockChainTicketCheckRequestValidationError{
			field:  "Account",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetOrg()) < 0 {
		err := BlockChainTicketCheckRequestValidationError{
			field:  "Org",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CheckType

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BlockChainTicketCheckRequestValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BlockChainTicketCheckRequestValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BlockChainTicketCheckRequestValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BlockChainTicketCheckRequestMultiError(errors)
	}

	return nil
}

// BlockChainTicketCheckRequestMultiError is an error wrapping multiple
// validation errors returned by BlockChainTicketCheckRequest.ValidateAll() if
// the designated constraints aren't met.
type BlockChainTicketCheckRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlockChainTicketCheckRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlockChainTicketCheckRequestMultiError) AllErrors() []error { return m }

// BlockChainTicketCheckRequestValidationError is the validation error returned
// by BlockChainTicketCheckRequest.Validate if the designated constraints
// aren't met.
type BlockChainTicketCheckRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlockChainTicketCheckRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlockChainTicketCheckRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlockChainTicketCheckRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlockChainTicketCheckRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlockChainTicketCheckRequestValidationError) ErrorName() string {
	return "BlockChainTicketCheckRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BlockChainTicketCheckRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlockChainTicketCheckRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlockChainTicketCheckRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlockChainTicketCheckRequestValidationError{}

// Validate checks the field values on BlockChainTicketCheckResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BlockChainTicketCheckResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlockChainTicketCheckResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BlockChainTicketCheckResponseMultiError, or nil if none found.
func (m *BlockChainTicketCheckResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BlockChainTicketCheckResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockChainTicketCheckResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockChainTicketCheckResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockChainTicketCheckResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BlockChainTicketCheckResponseMultiError(errors)
	}

	return nil
}

// BlockChainTicketCheckResponseMultiError is an error wrapping multiple
// validation errors returned by BlockChainTicketCheckResponse.ValidateAll()
// if the designated constraints aren't met.
type BlockChainTicketCheckResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlockChainTicketCheckResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlockChainTicketCheckResponseMultiError) AllErrors() []error { return m }

// BlockChainTicketCheckResponseValidationError is the validation error
// returned by BlockChainTicketCheckResponse.Validate if the designated
// constraints aren't met.
type BlockChainTicketCheckResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlockChainTicketCheckResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlockChainTicketCheckResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlockChainTicketCheckResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlockChainTicketCheckResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlockChainTicketCheckResponseValidationError) ErrorName() string {
	return "BlockChainTicketCheckResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BlockChainTicketCheckResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlockChainTicketCheckResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlockChainTicketCheckResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlockChainTicketCheckResponseValidationError{}

// Validate checks the field values on TxData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TxData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TxData with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TxDataMultiError, or nil if none found.
func (m *TxData) ValidateAll() error {
	return m.validate(true)
}

func (m *TxData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TxId

	// no validation rules for BlockHeight

	// no validation rules for OnChainTime

	// no validation rules for ChainName

	if len(errors) > 0 {
		return TxDataMultiError(errors)
	}

	return nil
}

// TxDataMultiError is an error wrapping multiple validation errors returned by
// TxData.ValidateAll() if the designated constraints aren't met.
type TxDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TxDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TxDataMultiError) AllErrors() []error { return m }

// TxDataValidationError is the validation error returned by TxData.Validate if
// the designated constraints aren't met.
type TxDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TxDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TxDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TxDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TxDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TxDataValidationError) ErrorName() string { return "TxDataValidationError" }

// Error satisfies the builtin error interface
func (e TxDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTxData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TxDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TxDataValidationError{}

// Validate checks the field values on CheckData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CheckData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CheckDataMultiError, or nil
// if none found.
func (m *CheckData) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsValid

	if len(errors) > 0 {
		return CheckDataMultiError(errors)
	}

	return nil
}

// CheckDataMultiError is an error wrapping multiple validation errors returned
// by CheckData.ValidateAll() if the designated constraints aren't met.
type CheckDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckDataMultiError) AllErrors() []error { return m }

// CheckDataValidationError is the validation error returned by
// CheckData.Validate if the designated constraints aren't met.
type CheckDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckDataValidationError) ErrorName() string { return "CheckDataValidationError" }

// Error satisfies the builtin error interface
func (e CheckDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckDataValidationError{}

// Validate checks the field values on VerificationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VerificationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VerificationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VerificationResponseMultiError, or nil if none found.
func (m *VerificationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *VerificationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VerificationResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VerificationResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VerificationResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return VerificationResponseMultiError(errors)
	}

	return nil
}

// VerificationResponseMultiError is an error wrapping multiple validation
// errors returned by VerificationResponse.ValidateAll() if the designated
// constraints aren't met.
type VerificationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VerificationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VerificationResponseMultiError) AllErrors() []error { return m }

// VerificationResponseValidationError is the validation error returned by
// VerificationResponse.Validate if the designated constraints aren't met.
type VerificationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VerificationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VerificationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VerificationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VerificationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VerificationResponseValidationError) ErrorName() string {
	return "VerificationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e VerificationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerificationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VerificationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VerificationResponseValidationError{}

// Validate checks the field values on BlockTicketIssuanceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BlockTicketIssuanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlockTicketIssuanceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BlockTicketIssuanceResponseMultiError, or nil if none found.
func (m *BlockTicketIssuanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BlockTicketIssuanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockTicketIssuanceResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockTicketIssuanceResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockTicketIssuanceResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BlockTicketIssuanceResponseMultiError(errors)
	}

	return nil
}

// BlockTicketIssuanceResponseMultiError is an error wrapping multiple
// validation errors returned by BlockTicketIssuanceResponse.ValidateAll() if
// the designated constraints aren't met.
type BlockTicketIssuanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlockTicketIssuanceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlockTicketIssuanceResponseMultiError) AllErrors() []error { return m }

// BlockTicketIssuanceResponseValidationError is the validation error returned
// by BlockTicketIssuanceResponse.Validate if the designated constraints
// aren't met.
type BlockTicketIssuanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlockTicketIssuanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlockTicketIssuanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlockTicketIssuanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlockTicketIssuanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlockTicketIssuanceResponseValidationError) ErrorName() string {
	return "BlockTicketIssuanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BlockTicketIssuanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlockTicketIssuanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlockTicketIssuanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlockTicketIssuanceResponseValidationError{}

// Validate checks the field values on SetSelfPriceInfoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetSelfPriceInfoResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetSelfPriceInfoResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetSelfPriceInfoResponseMultiError, or nil if none found.
func (m *SetSelfPriceInfoResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SetSelfPriceInfoResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetSelfPriceInfoResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetSelfPriceInfoResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetSelfPriceInfoResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SetSelfPriceInfoResponseMultiError(errors)
	}

	return nil
}

// SetSelfPriceInfoResponseMultiError is an error wrapping multiple validation
// errors returned by SetSelfPriceInfoResponse.ValidateAll() if the designated
// constraints aren't met.
type SetSelfPriceInfoResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetSelfPriceInfoResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetSelfPriceInfoResponseMultiError) AllErrors() []error { return m }

// SetSelfPriceInfoResponseValidationError is the validation error returned by
// SetSelfPriceInfoResponse.Validate if the designated constraints aren't met.
type SetSelfPriceInfoResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetSelfPriceInfoResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetSelfPriceInfoResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetSelfPriceInfoResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetSelfPriceInfoResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetSelfPriceInfoResponseValidationError) ErrorName() string {
	return "SetSelfPriceInfoResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SetSelfPriceInfoResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetSelfPriceInfoResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetSelfPriceInfoResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetSelfPriceInfoResponseValidationError{}

// Validate checks the field values on CreateStockResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateStockResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateStockResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateStockResponseMultiError, or nil if none found.
func (m *CreateStockResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateStockResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateStockResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateStockResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateStockResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateStockResponseMultiError(errors)
	}

	return nil
}

// CreateStockResponseMultiError is an error wrapping multiple validation
// errors returned by CreateStockResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateStockResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateStockResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateStockResponseMultiError) AllErrors() []error { return m }

// CreateStockResponseValidationError is the validation error returned by
// CreateStockResponse.Validate if the designated constraints aren't met.
type CreateStockResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateStockResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateStockResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateStockResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateStockResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateStockResponseValidationError) ErrorName() string {
	return "CreateStockResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateStockResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateStockResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateStockResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateStockResponseValidationError{}

// Validate checks the field values on TicketStatusResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TicketStatusResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TicketStatusResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TicketStatusResponseMultiError, or nil if none found.
func (m *TicketStatusResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TicketStatusResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketStatusResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketStatusResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketStatusResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TicketStatusResponseMultiError(errors)
	}

	return nil
}

// TicketStatusResponseMultiError is an error wrapping multiple validation
// errors returned by TicketStatusResponse.ValidateAll() if the designated
// constraints aren't met.
type TicketStatusResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TicketStatusResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TicketStatusResponseMultiError) AllErrors() []error { return m }

// TicketStatusResponseValidationError is the validation error returned by
// TicketStatusResponse.Validate if the designated constraints aren't met.
type TicketStatusResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TicketStatusResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TicketStatusResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TicketStatusResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TicketStatusResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TicketStatusResponseValidationError) ErrorName() string {
	return "TicketStatusResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TicketStatusResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTicketStatusResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TicketStatusResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TicketStatusResponseValidationError{}

// Validate checks the field values on CreateStockRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateStockRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateStockRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateStockRequestMultiError, or nil if none found.
func (m *CreateStockRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateStockRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSimpleTicket()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateStockRequestValidationError{
					field:  "SimpleTicket",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateStockRequestValidationError{
					field:  "SimpleTicket",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSimpleTicket()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateStockRequestValidationError{
				field:  "SimpleTicket",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTicketIssuance()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateStockRequestValidationError{
					field:  "TicketIssuance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateStockRequestValidationError{
					field:  "TicketIssuance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTicketIssuance()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateStockRequestValidationError{
				field:  "TicketIssuance",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBlockChainTicketCheck()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateStockRequestValidationError{
					field:  "BlockChainTicketCheck",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateStockRequestValidationError{
					field:  "BlockChainTicketCheck",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBlockChainTicketCheck()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateStockRequestValidationError{
				field:  "BlockChainTicketCheck",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetStockBatchNumber()) < 0 {
		err := CreateStockRequestValidationError{
			field:  "StockBatchNumber",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAccount()) != 42 {
		err := CreateStockRequestValidationError{
			field:  "Account",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetOrg()) < 0 {
		err := CreateStockRequestValidationError{
			field:  "Org",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for BatchId

	if all {
		switch v := interface{}(m.GetIsExchange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateStockRequestValidationError{
					field:  "IsExchange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateStockRequestValidationError{
					field:  "IsExchange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsExchange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateStockRequestValidationError{
				field:  "IsExchange",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateStockRequestMultiError(errors)
	}

	return nil
}

// CreateStockRequestMultiError is an error wrapping multiple validation errors
// returned by CreateStockRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateStockRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateStockRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateStockRequestMultiError) AllErrors() []error { return m }

// CreateStockRequestValidationError is the validation error returned by
// CreateStockRequest.Validate if the designated constraints aren't met.
type CreateStockRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateStockRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateStockRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateStockRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateStockRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateStockRequestValidationError) ErrorName() string {
	return "CreateStockRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateStockRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateStockRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateStockRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateStockRequestValidationError{}

// Validate checks the field values on SimpleTicket with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SimpleTicket) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SimpleTicket with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SimpleTicketMultiError, or
// nil if none found.
func (m *SimpleTicket) ValidateAll() error {
	return m.validate(true)
}

func (m *SimpleTicket) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ScenicId

	// no validation rules for AccountId

	// no validation rules for Name

	// no validation rules for PcName

	if all {
		switch v := interface{}(m.GetIssueType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "IssueType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "IssueType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssueType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SimpleTicketValidationError{
				field:  "IssueType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "Mode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "Mode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SimpleTicketValidationError{
				field:  "Mode",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MarketPrice

	if all {
		switch v := interface{}(m.GetProType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "ProType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "ProType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SimpleTicketValidationError{
				field:  "ProType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUseType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "UseType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "UseType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUseType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SimpleTicketValidationError{
				field:  "UseType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeRestrict()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "TimeRestrict",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "TimeRestrict",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeRestrict()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SimpleTicketValidationError{
				field:  "TimeRestrict",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRestrictType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "RestrictType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "RestrictType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRestrictType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SimpleTicketValidationError{
				field:  "RestrictType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RestrictWeek

	if all {
		switch v := interface{}(m.GetValidityDay()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "ValidityDay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "ValidityDay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValidityDay()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SimpleTicketValidationError{
				field:  "ValidityDay",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIsActivate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "IsActivate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "IsActivate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsActivate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SimpleTicketValidationError{
				field:  "IsActivate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUseCount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "UseCount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "UseCount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUseCount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SimpleTicketValidationError{
				field:  "UseCount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAvailableDays()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "AvailableDays",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "AvailableDays",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAvailableDays()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SimpleTicketValidationError{
				field:  "AvailableDays",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "Sorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "Sorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SimpleTicketValidationError{
				field:  "Sorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParkStatistic()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "ParkStatistic",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "ParkStatistic",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParkStatistic()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SimpleTicketValidationError{
				field:  "ParkStatistic",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PictureUrl

	// no validation rules for OperatorId

	// no validation rules for Notice

	// no validation rules for ProRoleName

	if all {
		switch v := interface{}(m.GetTicketGoods()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "TicketGoods",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "TicketGoods",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTicketGoods()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SimpleTicketValidationError{
				field:  "TicketGoods",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTicketStock()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "TicketStock",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SimpleTicketValidationError{
					field:  "TicketStock",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTicketStock()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SimpleTicketValidationError{
				field:  "TicketStock",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SimpleTicketMultiError(errors)
	}

	return nil
}

// SimpleTicketMultiError is an error wrapping multiple validation errors
// returned by SimpleTicket.ValidateAll() if the designated constraints aren't met.
type SimpleTicketMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SimpleTicketMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SimpleTicketMultiError) AllErrors() []error { return m }

// SimpleTicketValidationError is the validation error returned by
// SimpleTicket.Validate if the designated constraints aren't met.
type SimpleTicketValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SimpleTicketValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SimpleTicketValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SimpleTicketValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SimpleTicketValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SimpleTicketValidationError) ErrorName() string { return "SimpleTicketValidationError" }

// Error satisfies the builtin error interface
func (e SimpleTicketValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSimpleTicket.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SimpleTicketValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SimpleTicketValidationError{}

// Validate checks the field values on TimeSharing with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TimeSharing) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimeSharing with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TimeSharingMultiError, or
// nil if none found.
func (m *TimeSharing) ValidateAll() error {
	return m.validate(true)
}

func (m *TimeSharing) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TicketId

	// no validation rules for BeginTime

	// no validation rules for EndTime

	// no validation rules for SimpleName

	if len(errors) > 0 {
		return TimeSharingMultiError(errors)
	}

	return nil
}

// TimeSharingMultiError is an error wrapping multiple validation errors
// returned by TimeSharing.ValidateAll() if the designated constraints aren't met.
type TimeSharingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimeSharingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimeSharingMultiError) AllErrors() []error { return m }

// TimeSharingValidationError is the validation error returned by
// TimeSharing.Validate if the designated constraints aren't met.
type TimeSharingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimeSharingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimeSharingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimeSharingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimeSharingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimeSharingValidationError) ErrorName() string { return "TimeSharingValidationError" }

// Error satisfies the builtin error interface
func (e TimeSharingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimeSharing.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimeSharingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimeSharingValidationError{}

// Validate checks the field values on BlockTicketGoods with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BlockTicketGoods) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlockTicketGoods with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BlockTicketGoodsMultiError, or nil if none found.
func (m *BlockTicketGoods) ValidateAll() error {
	return m.validate(true)
}

func (m *BlockTicketGoods) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for GoodsName

	// no validation rules for TicketId

	// no validation rules for IssueId

	// no validation rules for CheckId

	// no validation rules for RetreatId

	// no validation rules for TimeShareId

	// no validation rules for OverallDiscount

	// no validation rules for BeginDiscount

	// no validation rules for EndDiscount

	if all {
		switch v := interface{}(m.GetType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "Type",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "Type",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockTicketGoodsValidationError{
				field:  "Type",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSaleChannel()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "SaleChannel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "SaleChannel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSaleChannel()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockTicketGoodsValidationError{
				field:  "SaleChannel",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSorts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "Sorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "Sorts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSorts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockTicketGoodsValidationError{
				field:  "Sorts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for WeekendPrice

	// no validation rules for HolidayPrice

	// no validation rules for BeginPriceRange

	// no validation rules for EndPriceRange

	// no validation rules for ServiceChargeRate

	// no validation rules for RealPrice

	if all {
		switch v := interface{}(m.GetIsRealName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "IsRealName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "IsRealName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsRealName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockTicketGoodsValidationError{
				field:  "IsRealName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIsCheck()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "IsCheck",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "IsCheck",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsCheck()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockTicketGoodsValidationError{
				field:  "IsCheck",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIsTravel()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "IsTravel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "IsTravel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsTravel()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockTicketGoodsValidationError{
				field:  "IsTravel",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIsPeopleNumber()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "IsPeopleNumber",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "IsPeopleNumber",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsPeopleNumber()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockTicketGoodsValidationError{
				field:  "IsPeopleNumber",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPeopleNumber()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "PeopleNumber",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "PeopleNumber",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPeopleNumber()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockTicketGoodsValidationError{
				field:  "PeopleNumber",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMinPeople()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "MinPeople",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "MinPeople",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMinPeople()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockTicketGoodsValidationError{
				field:  "MinPeople",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMaxPeople()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "MaxPeople",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "MaxPeople",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaxPeople()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockTicketGoodsValidationError{
				field:  "MaxPeople",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for BeginTime

	// no validation rules for EndTime

	if all {
		switch v := interface{}(m.GetUseType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "UseType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "UseType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUseType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockTicketGoodsValidationError{
				field:  "UseType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetValidityDay()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "ValidityDay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "ValidityDay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValidityDay()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockTicketGoodsValidationError{
				field:  "ValidityDay",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Notice

	// no validation rules for BuyUrl

	// no validation rules for RoleName

	// no validation rules for WorkState

	// no validation rules for TemplateId

	if all {
		switch v := interface{}(m.GetRuleCheck()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "RuleCheck",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "RuleCheck",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRuleCheck()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockTicketGoodsValidationError{
				field:  "RuleCheck",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRuleIssue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "RuleIssue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "RuleIssue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRuleIssue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockTicketGoodsValidationError{
				field:  "RuleIssue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRuleRetreat()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "RuleRetreat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "RuleRetreat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRuleRetreat()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockTicketGoodsValidationError{
				field:  "RuleRetreat",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSetSelfPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "SetSelfPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "SetSelfPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSetSelfPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockTicketGoodsValidationError{
				field:  "SetSelfPrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeSharing()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "TimeSharing",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockTicketGoodsValidationError{
					field:  "TimeSharing",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeSharing()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockTicketGoodsValidationError{
				field:  "TimeSharing",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BlockTicketGoodsMultiError(errors)
	}

	return nil
}

// BlockTicketGoodsMultiError is an error wrapping multiple validation errors
// returned by BlockTicketGoods.ValidateAll() if the designated constraints
// aren't met.
type BlockTicketGoodsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlockTicketGoodsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlockTicketGoodsMultiError) AllErrors() []error { return m }

// BlockTicketGoodsValidationError is the validation error returned by
// BlockTicketGoods.Validate if the designated constraints aren't met.
type BlockTicketGoodsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlockTicketGoodsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlockTicketGoodsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlockTicketGoodsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlockTicketGoodsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlockTicketGoodsValidationError) ErrorName() string { return "BlockTicketGoodsValidationError" }

// Error satisfies the builtin error interface
func (e BlockTicketGoodsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlockTicketGoods.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlockTicketGoodsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlockTicketGoodsValidationError{}

// Validate checks the field values on RuleCheck with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RuleCheck) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuleCheck with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RuleCheckMultiError, or nil
// if none found.
func (m *RuleCheck) ValidateAll() error {
	return m.validate(true)
}

func (m *RuleCheck) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ScenicId

	// no validation rules for IdentityType

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetControlType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuleCheckValidationError{
					field:  "ControlType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuleCheckValidationError{
					field:  "ControlType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetControlType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuleCheckValidationError{
				field:  "ControlType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetProType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuleCheckValidationError{
					field:  "ProType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuleCheckValidationError{
					field:  "ProType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuleCheckValidationError{
				field:  "ProType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAdoptType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuleCheckValidationError{
					field:  "AdoptType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuleCheckValidationError{
					field:  "AdoptType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAdoptType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuleCheckValidationError{
				field:  "AdoptType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIntervalTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuleCheckValidationError{
					field:  "IntervalTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuleCheckValidationError{
					field:  "IntervalTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIntervalTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuleCheckValidationError{
				field:  "IntervalTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLimitTimes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuleCheckValidationError{
					field:  "LimitTimes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuleCheckValidationError{
					field:  "LimitTimes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLimitTimes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuleCheckValidationError{
				field:  "LimitTimes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeShareBook()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuleCheckValidationError{
					field:  "TimeShareBook",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuleCheckValidationError{
					field:  "TimeShareBook",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeShareBook()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuleCheckValidationError{
				field:  "TimeShareBook",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RuleCheckMultiError(errors)
	}

	return nil
}

// RuleCheckMultiError is an error wrapping multiple validation errors returned
// by RuleCheck.ValidateAll() if the designated constraints aren't met.
type RuleCheckMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuleCheckMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuleCheckMultiError) AllErrors() []error { return m }

// RuleCheckValidationError is the validation error returned by
// RuleCheck.Validate if the designated constraints aren't met.
type RuleCheckValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuleCheckValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuleCheckValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuleCheckValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuleCheckValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuleCheckValidationError) ErrorName() string { return "RuleCheckValidationError" }

// Error satisfies the builtin error interface
func (e RuleCheckValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuleCheck.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuleCheckValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuleCheckValidationError{}

// Validate checks the field values on RuleIssue with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RuleIssue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuleIssue with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RuleIssueMultiError, or nil
// if none found.
func (m *RuleIssue) ValidateAll() error {
	return m.validate(true)
}

func (m *RuleIssue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ScenicId

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetWay()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuleIssueValidationError{
					field:  "Way",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuleIssueValidationError{
					field:  "Way",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWay()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuleIssueValidationError{
				field:  "Way",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuleIssueValidationError{
					field:  "Type",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuleIssueValidationError{
					field:  "Type",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuleIssueValidationError{
				field:  "Type",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIsRealName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuleIssueValidationError{
					field:  "IsRealName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuleIssueValidationError{
					field:  "IsRealName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsRealName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuleIssueValidationError{
				field:  "IsRealName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UseTime

	// no validation rules for BeginTime

	// no validation rules for EndTime

	if all {
		switch v := interface{}(m.GetRealNameCheck()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuleIssueValidationError{
					field:  "RealNameCheck",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuleIssueValidationError{
					field:  "RealNameCheck",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRealNameCheck()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuleIssueValidationError{
				field:  "RealNameCheck",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOnlyOwnerBuy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuleIssueValidationError{
					field:  "OnlyOwnerBuy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuleIssueValidationError{
					field:  "OnlyOwnerBuy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOnlyOwnerBuy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuleIssueValidationError{
				field:  "OnlyOwnerBuy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRightsCheck()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuleIssueValidationError{
					field:  "RightsCheck",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuleIssueValidationError{
					field:  "RightsCheck",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRightsCheck()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuleIssueValidationError{
				field:  "RightsCheck",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RightsId

	if all {
		switch v := interface{}(m.GetIssueAndCheck()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuleIssueValidationError{
					field:  "IssueAndCheck",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuleIssueValidationError{
					field:  "IssueAndCheck",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssueAndCheck()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuleIssueValidationError{
				field:  "IssueAndCheck",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNeedApproval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuleIssueValidationError{
					field:  "NeedApproval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuleIssueValidationError{
					field:  "NeedApproval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNeedApproval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuleIssueValidationError{
				field:  "NeedApproval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ApproveId

	// no validation rules for ApproveContent

	if all {
		switch v := interface{}(m.GetRuleType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuleIssueValidationError{
					field:  "RuleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuleIssueValidationError{
					field:  "RuleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRuleType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuleIssueValidationError{
				field:  "RuleType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOnlyWindowSale()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuleIssueValidationError{
					field:  "OnlyWindowSale",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuleIssueValidationError{
					field:  "OnlyWindowSale",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOnlyWindowSale()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuleIssueValidationError{
				field:  "OnlyWindowSale",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RuleIssueMultiError(errors)
	}

	return nil
}

// RuleIssueMultiError is an error wrapping multiple validation errors returned
// by RuleIssue.ValidateAll() if the designated constraints aren't met.
type RuleIssueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuleIssueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuleIssueMultiError) AllErrors() []error { return m }

// RuleIssueValidationError is the validation error returned by
// RuleIssue.Validate if the designated constraints aren't met.
type RuleIssueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuleIssueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuleIssueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuleIssueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuleIssueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuleIssueValidationError) ErrorName() string { return "RuleIssueValidationError" }

// Error satisfies the builtin error interface
func (e RuleIssueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuleIssue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuleIssueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuleIssueValidationError{}

// Validate checks the field values on RuleRetreat with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RuleRetreat) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuleRetreat with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RuleRetreatMultiError, or
// nil if none found.
func (m *RuleRetreat) ValidateAll() error {
	return m.validate(true)
}

func (m *RuleRetreat) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ScenicId

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetIsRetreat()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuleRetreatValidationError{
					field:  "IsRetreat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuleRetreatValidationError{
					field:  "IsRetreat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsRetreat()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuleRetreatValidationError{
				field:  "IsRetreat",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DefaultRate

	if len(errors) > 0 {
		return RuleRetreatMultiError(errors)
	}

	return nil
}

// RuleRetreatMultiError is an error wrapping multiple validation errors
// returned by RuleRetreat.ValidateAll() if the designated constraints aren't met.
type RuleRetreatMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuleRetreatMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuleRetreatMultiError) AllErrors() []error { return m }

// RuleRetreatValidationError is the validation error returned by
// RuleRetreat.Validate if the designated constraints aren't met.
type RuleRetreatValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuleRetreatValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuleRetreatValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuleRetreatValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuleRetreatValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuleRetreatValidationError) ErrorName() string { return "RuleRetreatValidationError" }

// Error satisfies the builtin error interface
func (e RuleRetreatValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuleRetreat.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuleRetreatValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuleRetreatValidationError{}

// Validate checks the field values on TicketStock with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TicketStock) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TicketStock with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TicketStockMultiError, or
// nil if none found.
func (m *TicketStock) ValidateAll() error {
	return m.validate(true)
}

func (m *TicketStock) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CreditCode

	// no validation rules for ScenicId

	// no validation rules for TicketId

	// no validation rules for PurchaseBeginTime

	// no validation rules for PurchaseEndTime

	// no validation rules for EnterBeginTime

	// no validation rules for EnterEndTime

	if all {
		switch v := interface{}(m.GetTotalStock()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketStockValidationError{
					field:  "TotalStock",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketStockValidationError{
					field:  "TotalStock",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotalStock()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketStockValidationError{
				field:  "TotalStock",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Remark

	if all {
		switch v := interface{}(m.GetTicketType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketStockValidationError{
					field:  "TicketType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketStockValidationError{
					field:  "TicketType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTicketType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketStockValidationError{
				field:  "TicketType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNums()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketStockValidationError{
					field:  "Nums",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketStockValidationError{
					field:  "Nums",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNums()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketStockValidationError{
				field:  "Nums",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AccountId

	// no validation rules for OperatorId

	// no validation rules for Meta

	// no validation rules for Flag

	// no validation rules for Account

	// no validation rules for Org

	// no validation rules for ScenicName

	// no validation rules for TicketName

	if len(errors) > 0 {
		return TicketStockMultiError(errors)
	}

	return nil
}

// TicketStockMultiError is an error wrapping multiple validation errors
// returned by TicketStock.ValidateAll() if the designated constraints aren't met.
type TicketStockMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TicketStockMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TicketStockMultiError) AllErrors() []error { return m }

// TicketStockValidationError is the validation error returned by
// TicketStock.Validate if the designated constraints aren't met.
type TicketStockValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TicketStockValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TicketStockValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TicketStockValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TicketStockValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TicketStockValidationError) ErrorName() string { return "TicketStockValidationError" }

// Error satisfies the builtin error interface
func (e TicketStockValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTicketStock.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TicketStockValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TicketStockValidationError{}

// Validate checks the field values on BlockTicketIssuanceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BlockTicketIssuanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlockTicketIssuanceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BlockTicketIssuanceRequestMultiError, or nil if none found.
func (m *BlockTicketIssuanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BlockTicketIssuanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTicketData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BlockTicketIssuanceRequestValidationError{
						field:  fmt.Sprintf("TicketData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BlockTicketIssuanceRequestValidationError{
						field:  fmt.Sprintf("TicketData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BlockTicketIssuanceRequestValidationError{
					field:  fmt.Sprintf("TicketData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Phone

	// no validation rules for SourceType

	// no validation rules for OrderGroupId

	if len(errors) > 0 {
		return BlockTicketIssuanceRequestMultiError(errors)
	}

	return nil
}

// BlockTicketIssuanceRequestMultiError is an error wrapping multiple
// validation errors returned by BlockTicketIssuanceRequest.ValidateAll() if
// the designated constraints aren't met.
type BlockTicketIssuanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlockTicketIssuanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlockTicketIssuanceRequestMultiError) AllErrors() []error { return m }

// BlockTicketIssuanceRequestValidationError is the validation error returned
// by BlockTicketIssuanceRequest.Validate if the designated constraints aren't met.
type BlockTicketIssuanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlockTicketIssuanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlockTicketIssuanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlockTicketIssuanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlockTicketIssuanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlockTicketIssuanceRequestValidationError) ErrorName() string {
	return "BlockTicketIssuanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BlockTicketIssuanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlockTicketIssuanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlockTicketIssuanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlockTicketIssuanceRequestValidationError{}

// Validate checks the field values on TicketData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TicketData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TicketData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TicketDataMultiError, or
// nil if none found.
func (m *TicketData) ValidateAll() error {
	return m.validate(true)
}

func (m *TicketData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetBuyerInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TicketDataValidationError{
						field:  fmt.Sprintf("BuyerInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TicketDataValidationError{
						field:  fmt.Sprintf("BuyerInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TicketDataValidationError{
					field:  fmt.Sprintf("BuyerInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for OrderId

	if all {
		switch v := interface{}(m.GetPlayerNum()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "PlayerNum",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "PlayerNum",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlayerNum()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataValidationError{
				field:  "PlayerNum",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIssuanceType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "IssuanceType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "IssuanceType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssuanceType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataValidationError{
				field:  "IssuanceType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CheckType

	// no validation rules for PrintEncode

	// no validation rules for EnterBeginTime

	// no validation rules for EnterEndTime

	// no validation rules for OverdueTime

	if all {
		switch v := interface{}(m.GetValidityDay()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "ValidityDay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "ValidityDay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValidityDay()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataValidationError{
				field:  "ValidityDay",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ProviderId

	// no validation rules for BuyerId

	// no validation rules for ScenicId

	// no validation rules for ProId

	// no validation rules for GoodsId

	// no validation rules for IssueId

	// no validation rules for CheckId

	// no validation rules for RetreatId

	// no validation rules for StoreId

	// no validation rules for SellingPrice

	if all {
		switch v := interface{}(m.GetCancelCount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "CancelCount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "CancelCount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCancelCount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataValidationError{
				field:  "CancelCount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for EnterTime

	if all {
		switch v := interface{}(m.GetGoodsType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "GoodsType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "GoodsType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGoodsType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataValidationError{
				field:  "GoodsType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ProName

	if all {
		switch v := interface{}(m.GetProType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "ProType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "ProType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataValidationError{
				field:  "ProType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TicketTypeId

	// no validation rules for GoodsName

	// no validation rules for TimeShareId

	if all {
		switch v := interface{}(m.GetSaleChannel()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "SaleChannel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "SaleChannel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSaleChannel()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataValidationError{
				field:  "SaleChannel",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RealPrice

	if all {
		switch v := interface{}(m.GetCheckedNum()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "CheckedNum",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "CheckedNum",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCheckedNum()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataValidationError{
				field:  "CheckedNum",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIsRealName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "IsRealName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "IsRealName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsRealName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataValidationError{
				field:  "IsRealName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIsActivate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "IsActivate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "IsActivate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsActivate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataValidationError{
				field:  "IsActivate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUseType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "UseType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "UseType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUseType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataValidationError{
				field:  "UseType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUseCount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "UseCount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "UseCount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUseCount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataValidationError{
				field:  "UseCount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAvailableDays()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "AvailableDays",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "AvailableDays",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAvailableDays()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataValidationError{
				field:  "AvailableDays",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUsedCount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "UsedCount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "UsedCount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUsedCount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataValidationError{
				field:  "UsedCount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUsedDays()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "UsedDays",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "UsedDays",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUsedDays()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataValidationError{
				field:  "UsedDays",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RightsGoodsId

	// no validation rules for TicketTypeSubId

	// no validation rules for OrderProductId

	// no validation rules for Uuid

	// no validation rules for IdCard

	// no validation rules for RealQuantity

	if all {
		switch v := interface{}(m.GetTicketIssuanceSubInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "TicketIssuanceSubInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataValidationError{
					field:  "TicketIssuanceSubInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTicketIssuanceSubInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataValidationError{
				field:  "TicketIssuanceSubInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Num

	if utf8.RuneCountInString(m.GetStockBatchNumber()) < 0 {
		err := TicketDataValidationError{
			field:  "StockBatchNumber",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAccount()) != 42 {
		err := TicketDataValidationError{
			field:  "Account",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetOrg()) < 0 {
		err := TicketDataValidationError{
			field:  "Org",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Id

	// no validation rules for Sign

	if len(errors) > 0 {
		return TicketDataMultiError(errors)
	}

	return nil
}

// TicketDataMultiError is an error wrapping multiple validation errors
// returned by TicketData.ValidateAll() if the designated constraints aren't met.
type TicketDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TicketDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TicketDataMultiError) AllErrors() []error { return m }

// TicketDataValidationError is the validation error returned by
// TicketData.Validate if the designated constraints aren't met.
type TicketDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TicketDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TicketDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TicketDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TicketDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TicketDataValidationError) ErrorName() string { return "TicketDataValidationError" }

// Error satisfies the builtin error interface
func (e TicketDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTicketData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TicketDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TicketDataValidationError{}

// Validate checks the field values on SetSelfPrice with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SetSelfPrice) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetSelfPrice with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SetSelfPriceMultiError, or
// nil if none found.
func (m *SetSelfPrice) ValidateAll() error {
	return m.validate(true)
}

func (m *SetSelfPrice) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetSelfPriceValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetSelfPriceValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetSelfPriceValidationError{
				field:  "Price",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UnitId

	// no validation rules for DistributorId

	// no validation rules for GoodsId

	if len(errors) > 0 {
		return SetSelfPriceMultiError(errors)
	}

	return nil
}

// SetSelfPriceMultiError is an error wrapping multiple validation errors
// returned by SetSelfPrice.ValidateAll() if the designated constraints aren't met.
type SetSelfPriceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetSelfPriceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetSelfPriceMultiError) AllErrors() []error { return m }

// SetSelfPriceValidationError is the validation error returned by
// SetSelfPrice.Validate if the designated constraints aren't met.
type SetSelfPriceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetSelfPriceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetSelfPriceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetSelfPriceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetSelfPriceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetSelfPriceValidationError) ErrorName() string { return "SetSelfPriceValidationError" }

// Error satisfies the builtin error interface
func (e SetSelfPriceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetSelfPrice.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetSelfPriceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetSelfPriceValidationError{}

// Validate checks the field values on PriceInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PriceInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PriceInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PriceInfoMultiError, or nil
// if none found.
func (m *PriceInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *PriceInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SalePrice

	// no validation rules for ComposePrice

	// no validation rules for CommissionRate

	// no validation rules for IsCompose

	// no validation rules for SaleRenewPrice

	// no validation rules for Discount

	// no validation rules for ComposeDiscount

	// no validation rules for RenewDiscount

	if len(errors) > 0 {
		return PriceInfoMultiError(errors)
	}

	return nil
}

// PriceInfoMultiError is an error wrapping multiple validation errors returned
// by PriceInfo.ValidateAll() if the designated constraints aren't met.
type PriceInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PriceInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PriceInfoMultiError) AllErrors() []error { return m }

// PriceInfoValidationError is the validation error returned by
// PriceInfo.Validate if the designated constraints aren't met.
type PriceInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PriceInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PriceInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PriceInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PriceInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PriceInfoValidationError) ErrorName() string { return "PriceInfoValidationError" }

// Error satisfies the builtin error interface
func (e PriceInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPriceInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PriceInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PriceInfoValidationError{}

// Validate checks the field values on VerificationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VerificationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VerificationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VerificationRequestMultiError, or nil if none found.
func (m *VerificationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *VerificationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTicketCheck()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VerificationRequestValidationError{
					field:  "TicketCheck",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VerificationRequestValidationError{
					field:  "TicketCheck",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTicketCheck()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VerificationRequestValidationError{
				field:  "TicketCheck",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTicketList()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VerificationRequestValidationError{
					field:  "TicketList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VerificationRequestValidationError{
					field:  "TicketList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTicketList()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VerificationRequestValidationError{
				field:  "TicketList",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTicketCheckInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VerificationRequestValidationError{
					field:  "TicketCheckInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VerificationRequestValidationError{
					field:  "TicketCheckInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTicketCheckInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VerificationRequestValidationError{
				field:  "TicketCheckInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetStockBatchNumber()) < 0 {
		err := VerificationRequestValidationError{
			field:  "StockBatchNumber",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAccount()) != 42 {
		err := VerificationRequestValidationError{
			field:  "Account",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetOrg()) < 0 {
		err := VerificationRequestValidationError{
			field:  "Org",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return VerificationRequestMultiError(errors)
	}

	return nil
}

// VerificationRequestMultiError is an error wrapping multiple validation
// errors returned by VerificationRequest.ValidateAll() if the designated
// constraints aren't met.
type VerificationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VerificationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VerificationRequestMultiError) AllErrors() []error { return m }

// VerificationRequestValidationError is the validation error returned by
// VerificationRequest.Validate if the designated constraints aren't met.
type VerificationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VerificationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VerificationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VerificationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VerificationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VerificationRequestValidationError) ErrorName() string {
	return "VerificationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e VerificationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerificationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VerificationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VerificationRequestValidationError{}

// Validate checks the field values on TicketCheck with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TicketCheck) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TicketCheck with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TicketCheckMultiError, or
// nil if none found.
func (m *TicketCheck) ValidateAll() error {
	return m.validate(true)
}

func (m *TicketCheck) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Way

	// no validation rules for ScenicId

	// no validation rules for PointId

	// no validation rules for EquipmentName

	// no validation rules for EquipmentType

	// no validation rules for EnterTime

	// no validation rules for EquipmentId

	// no validation rules for PointName

	// no validation rules for IdName

	// no validation rules for Picture

	if all {
		switch v := interface{}(m.GetCheckType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketCheckValidationError{
					field:  "CheckType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketCheckValidationError{
					field:  "CheckType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCheckType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketCheckValidationError{
				field:  "CheckType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TicketCheckMultiError(errors)
	}

	return nil
}

// TicketCheckMultiError is an error wrapping multiple validation errors
// returned by TicketCheck.ValidateAll() if the designated constraints aren't met.
type TicketCheckMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TicketCheckMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TicketCheckMultiError) AllErrors() []error { return m }

// TicketCheckValidationError is the validation error returned by
// TicketCheck.Validate if the designated constraints aren't met.
type TicketCheckValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TicketCheckValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TicketCheckValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TicketCheckValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TicketCheckValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TicketCheckValidationError) ErrorName() string { return "TicketCheckValidationError" }

// Error satisfies the builtin error interface
func (e TicketCheckValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTicketCheck.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TicketCheckValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TicketCheckValidationError{}

// Validate checks the field values on TicketList with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TicketList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TicketList with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TicketListMultiError, or
// nil if none found.
func (m *TicketList) ValidateAll() error {
	return m.validate(true)
}

func (m *TicketList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TicketListValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TicketListValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TicketListValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for UserId

	// no validation rules for Username

	if len(errors) > 0 {
		return TicketListMultiError(errors)
	}

	return nil
}

// TicketListMultiError is an error wrapping multiple validation errors
// returned by TicketList.ValidateAll() if the designated constraints aren't met.
type TicketListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TicketListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TicketListMultiError) AllErrors() []error { return m }

// TicketListValidationError is the validation error returned by
// TicketList.Validate if the designated constraints aren't met.
type TicketListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TicketListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TicketListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TicketListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TicketListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TicketListValidationError) ErrorName() string { return "TicketListValidationError" }

// Error satisfies the builtin error interface
func (e TicketListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTicketList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TicketListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TicketListValidationError{}

// Validate checks the field values on ManualCheckNo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ManualCheckNo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ManualCheckNo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ManualCheckNoMultiError, or
// nil if none found.
func (m *ManualCheckNo) ValidateAll() error {
	return m.validate(true)
}

func (m *ManualCheckNo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TicketNumber

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ManualCheckNoValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ManualCheckNoValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ManualCheckNoValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ManualCheckNoMultiError(errors)
	}

	return nil
}

// ManualCheckNoMultiError is an error wrapping multiple validation errors
// returned by ManualCheckNo.ValidateAll() if the designated constraints
// aren't met.
type ManualCheckNoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ManualCheckNoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ManualCheckNoMultiError) AllErrors() []error { return m }

// ManualCheckNoValidationError is the validation error returned by
// ManualCheckNo.Validate if the designated constraints aren't met.
type ManualCheckNoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ManualCheckNoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ManualCheckNoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ManualCheckNoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ManualCheckNoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ManualCheckNoValidationError) ErrorName() string { return "ManualCheckNoValidationError" }

// Error satisfies the builtin error interface
func (e ManualCheckNoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sManualCheckNo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ManualCheckNoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ManualCheckNoValidationError{}

// Validate checks the field values on ManualCheckMultiUnit with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ManualCheckMultiUnit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ManualCheckMultiUnit with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ManualCheckMultiUnitMultiError, or nil if none found.
func (m *ManualCheckMultiUnit) ValidateAll() error {
	return m.validate(true)
}

func (m *ManualCheckMultiUnit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCheckCount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ManualCheckMultiUnitValidationError{
					field:  "CheckCount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ManualCheckMultiUnitValidationError{
					field:  "CheckCount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCheckCount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ManualCheckMultiUnitValidationError{
				field:  "CheckCount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IdCardNumber

	// no validation rules for UseDate

	if len(errors) > 0 {
		return ManualCheckMultiUnitMultiError(errors)
	}

	return nil
}

// ManualCheckMultiUnitMultiError is an error wrapping multiple validation
// errors returned by ManualCheckMultiUnit.ValidateAll() if the designated
// constraints aren't met.
type ManualCheckMultiUnitMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ManualCheckMultiUnitMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ManualCheckMultiUnitMultiError) AllErrors() []error { return m }

// ManualCheckMultiUnitValidationError is the validation error returned by
// ManualCheckMultiUnit.Validate if the designated constraints aren't met.
type ManualCheckMultiUnitValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ManualCheckMultiUnitValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ManualCheckMultiUnitValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ManualCheckMultiUnitValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ManualCheckMultiUnitValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ManualCheckMultiUnitValidationError) ErrorName() string {
	return "ManualCheckMultiUnitValidationError"
}

// Error satisfies the builtin error interface
func (e ManualCheckMultiUnitValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sManualCheckMultiUnit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ManualCheckMultiUnitValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ManualCheckMultiUnitValidationError{}

// Validate checks the field values on TicketCheckInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TicketCheckInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TicketCheckInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TicketCheckInfoMultiError, or nil if none found.
func (m *TicketCheckInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *TicketCheckInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Seq

	if all {
		switch v := interface{}(m.GetPassCount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketCheckInfoValidationError{
					field:  "PassCount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketCheckInfoValidationError{
					field:  "PassCount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPassCount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketCheckInfoValidationError{
				field:  "PassCount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TicketCheckInfoMultiError(errors)
	}

	return nil
}

// TicketCheckInfoMultiError is an error wrapping multiple validation errors
// returned by TicketCheckInfo.ValidateAll() if the designated constraints
// aren't met.
type TicketCheckInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TicketCheckInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TicketCheckInfoMultiError) AllErrors() []error { return m }

// TicketCheckInfoValidationError is the validation error returned by
// TicketCheckInfo.Validate if the designated constraints aren't met.
type TicketCheckInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TicketCheckInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TicketCheckInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TicketCheckInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TicketCheckInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TicketCheckInfoValidationError) ErrorName() string { return "TicketCheckInfoValidationError" }

// Error satisfies the builtin error interface
func (e TicketCheckInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTicketCheckInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TicketCheckInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TicketCheckInfoValidationError{}

// Validate checks the field values on SetSelfPriceInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetSelfPriceInfoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetSelfPriceInfoRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetSelfPriceInfoRequestMultiError, or nil if none found.
func (m *SetSelfPriceInfoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SetSelfPriceInfoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPriceInfoDetailsList()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetSelfPriceInfoRequestValidationError{
					field:  "PriceInfoDetailsList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetSelfPriceInfoRequestValidationError{
					field:  "PriceInfoDetailsList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPriceInfoDetailsList()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetSelfPriceInfoRequestValidationError{
				field:  "PriceInfoDetailsList",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SetSelfPriceInfoRequestMultiError(errors)
	}

	return nil
}

// SetSelfPriceInfoRequestMultiError is an error wrapping multiple validation
// errors returned by SetSelfPriceInfoRequest.ValidateAll() if the designated
// constraints aren't met.
type SetSelfPriceInfoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetSelfPriceInfoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetSelfPriceInfoRequestMultiError) AllErrors() []error { return m }

// SetSelfPriceInfoRequestValidationError is the validation error returned by
// SetSelfPriceInfoRequest.Validate if the designated constraints aren't met.
type SetSelfPriceInfoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetSelfPriceInfoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetSelfPriceInfoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetSelfPriceInfoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetSelfPriceInfoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetSelfPriceInfoRequestValidationError) ErrorName() string {
	return "SetSelfPriceInfoRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SetSelfPriceInfoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetSelfPriceInfoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetSelfPriceInfoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetSelfPriceInfoRequestValidationError{}

// Validate checks the field values on PriceInfoDetailsList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PriceInfoDetailsList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PriceInfoDetailsList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PriceInfoDetailsListMultiError, or nil if none found.
func (m *PriceInfoDetailsList) ValidateAll() error {
	return m.validate(true)
}

func (m *PriceInfoDetailsList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PriceInfoDetailsListValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PriceInfoDetailsListValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PriceInfoDetailsListValidationError{
				field:  "Price",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UnitId

	// no validation rules for DistributorId

	// no validation rules for GoodsId

	if utf8.RuneCountInString(m.GetStockBatchNumber()) < 0 {
		err := PriceInfoDetailsListValidationError{
			field:  "StockBatchNumber",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAccount()) != 42 {
		err := PriceInfoDetailsListValidationError{
			field:  "Account",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetOrg()) < 0 {
		err := PriceInfoDetailsListValidationError{
			field:  "Org",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Status

	// no validation rules for PriceId

	if len(errors) > 0 {
		return PriceInfoDetailsListMultiError(errors)
	}

	return nil
}

// PriceInfoDetailsListMultiError is an error wrapping multiple validation
// errors returned by PriceInfoDetailsList.ValidateAll() if the designated
// constraints aren't met.
type PriceInfoDetailsListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PriceInfoDetailsListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PriceInfoDetailsListMultiError) AllErrors() []error { return m }

// PriceInfoDetailsListValidationError is the validation error returned by
// PriceInfoDetailsList.Validate if the designated constraints aren't met.
type PriceInfoDetailsListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PriceInfoDetailsListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PriceInfoDetailsListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PriceInfoDetailsListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PriceInfoDetailsListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PriceInfoDetailsListValidationError) ErrorName() string {
	return "PriceInfoDetailsListValidationError"
}

// Error satisfies the builtin error interface
func (e PriceInfoDetailsListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPriceInfoDetailsList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PriceInfoDetailsListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PriceInfoDetailsListValidationError{}

// Validate checks the field values on PriceInfoDetails with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PriceInfoDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PriceInfoDetails with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PriceInfoDetailsMultiError, or nil if none found.
func (m *PriceInfoDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *PriceInfoDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SalePrice

	// no validation rules for ComposePrice

	// no validation rules for CommissionRate

	// no validation rules for IsCompose

	// no validation rules for SaleRenewPrice

	// no validation rules for Discount

	// no validation rules for ComposeDiscount

	// no validation rules for RenewDiscount

	if len(errors) > 0 {
		return PriceInfoDetailsMultiError(errors)
	}

	return nil
}

// PriceInfoDetailsMultiError is an error wrapping multiple validation errors
// returned by PriceInfoDetails.ValidateAll() if the designated constraints
// aren't met.
type PriceInfoDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PriceInfoDetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PriceInfoDetailsMultiError) AllErrors() []error { return m }

// PriceInfoDetailsValidationError is the validation error returned by
// PriceInfoDetails.Validate if the designated constraints aren't met.
type PriceInfoDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PriceInfoDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PriceInfoDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PriceInfoDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PriceInfoDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PriceInfoDetailsValidationError) ErrorName() string { return "PriceInfoDetailsValidationError" }

// Error satisfies the builtin error interface
func (e PriceInfoDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPriceInfoDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PriceInfoDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PriceInfoDetailsValidationError{}

// Validate checks the field values on TicketIssuanceAlone with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TicketIssuanceAlone) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TicketIssuanceAlone with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TicketIssuanceAloneMultiError, or nil if none found.
func (m *TicketIssuanceAlone) ValidateAll() error {
	return m.validate(true)
}

func (m *TicketIssuanceAlone) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTicketData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TicketIssuanceAloneValidationError{
						field:  fmt.Sprintf("TicketData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TicketIssuanceAloneValidationError{
						field:  fmt.Sprintf("TicketData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TicketIssuanceAloneValidationError{
					field:  fmt.Sprintf("TicketData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Phone

	// no validation rules for SourceType

	// no validation rules for OrderGroupId

	if len(errors) > 0 {
		return TicketIssuanceAloneMultiError(errors)
	}

	return nil
}

// TicketIssuanceAloneMultiError is an error wrapping multiple validation
// errors returned by TicketIssuanceAlone.ValidateAll() if the designated
// constraints aren't met.
type TicketIssuanceAloneMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TicketIssuanceAloneMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TicketIssuanceAloneMultiError) AllErrors() []error { return m }

// TicketIssuanceAloneValidationError is the validation error returned by
// TicketIssuanceAlone.Validate if the designated constraints aren't met.
type TicketIssuanceAloneValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TicketIssuanceAloneValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TicketIssuanceAloneValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TicketIssuanceAloneValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TicketIssuanceAloneValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TicketIssuanceAloneValidationError) ErrorName() string {
	return "TicketIssuanceAloneValidationError"
}

// Error satisfies the builtin error interface
func (e TicketIssuanceAloneValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTicketIssuanceAlone.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TicketIssuanceAloneValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TicketIssuanceAloneValidationError{}

// Validate checks the field values on TicketDataAlone with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TicketDataAlone) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TicketDataAlone with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TicketDataAloneMultiError, or nil if none found.
func (m *TicketDataAlone) ValidateAll() error {
	return m.validate(true)
}

func (m *TicketDataAlone) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetBuyerInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TicketDataAloneValidationError{
						field:  fmt.Sprintf("BuyerInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TicketDataAloneValidationError{
						field:  fmt.Sprintf("BuyerInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TicketDataAloneValidationError{
					field:  fmt.Sprintf("BuyerInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for OrderId

	if all {
		switch v := interface{}(m.GetPlayerNum()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "PlayerNum",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "PlayerNum",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlayerNum()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataAloneValidationError{
				field:  "PlayerNum",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIssuanceType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "IssuanceType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "IssuanceType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssuanceType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataAloneValidationError{
				field:  "IssuanceType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataAloneValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CheckType

	// no validation rules for PrintEncode

	// no validation rules for EnterBeginTime

	// no validation rules for EnterEndTime

	// no validation rules for OverdueTime

	if all {
		switch v := interface{}(m.GetValidityDay()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "ValidityDay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "ValidityDay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValidityDay()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataAloneValidationError{
				field:  "ValidityDay",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ProviderId

	// no validation rules for ScenicId

	// no validation rules for ProId

	// no validation rules for GoodsId

	// no validation rules for IssueId

	// no validation rules for CheckId

	// no validation rules for RetreatId

	// no validation rules for StoreId

	// no validation rules for SellingPrice

	if all {
		switch v := interface{}(m.GetCancelCount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "CancelCount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "CancelCount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCancelCount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataAloneValidationError{
				field:  "CancelCount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for EnterTime

	if all {
		switch v := interface{}(m.GetGoodsType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "GoodsType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "GoodsType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGoodsType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataAloneValidationError{
				field:  "GoodsType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ProName

	if all {
		switch v := interface{}(m.GetProType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "ProType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "ProType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataAloneValidationError{
				field:  "ProType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TicketTypeId

	// no validation rules for GoodsName

	// no validation rules for TimeShareId

	if all {
		switch v := interface{}(m.GetSaleChannel()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "SaleChannel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "SaleChannel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSaleChannel()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataAloneValidationError{
				field:  "SaleChannel",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RealPrice

	if all {
		switch v := interface{}(m.GetCheckedNum()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "CheckedNum",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "CheckedNum",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCheckedNum()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataAloneValidationError{
				field:  "CheckedNum",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIsRealName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "IsRealName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "IsRealName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsRealName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataAloneValidationError{
				field:  "IsRealName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIsActivate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "IsActivate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "IsActivate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsActivate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataAloneValidationError{
				field:  "IsActivate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUseType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "UseType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "UseType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUseType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataAloneValidationError{
				field:  "UseType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUseCount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "UseCount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "UseCount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUseCount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataAloneValidationError{
				field:  "UseCount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAvailableDays()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "AvailableDays",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "AvailableDays",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAvailableDays()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataAloneValidationError{
				field:  "AvailableDays",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUsedCount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "UsedCount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "UsedCount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUsedCount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataAloneValidationError{
				field:  "UsedCount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUsedDays()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "UsedDays",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "UsedDays",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUsedDays()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataAloneValidationError{
				field:  "UsedDays",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RightsGoodsId

	// no validation rules for TicketTypeSubId

	// no validation rules for OrderProductId

	// no validation rules for Uuid

	// no validation rules for IdCard

	// no validation rules for RealQuantity

	if all {
		switch v := interface{}(m.GetTicketIssuanceSubInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "TicketIssuanceSubInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataAloneValidationError{
					field:  "TicketIssuanceSubInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTicketIssuanceSubInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataAloneValidationError{
				field:  "TicketIssuanceSubInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Num

	if utf8.RuneCountInString(m.GetStockBatchNumber()) < 0 {
		err := TicketDataAloneValidationError{
			field:  "StockBatchNumber",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAccount()) != 42 {
		err := TicketDataAloneValidationError{
			field:  "Account",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetOrg()) < 0 {
		err := TicketDataAloneValidationError{
			field:  "Org",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TicketDataAloneMultiError(errors)
	}

	return nil
}

// TicketDataAloneMultiError is an error wrapping multiple validation errors
// returned by TicketDataAlone.ValidateAll() if the designated constraints
// aren't met.
type TicketDataAloneMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TicketDataAloneMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TicketDataAloneMultiError) AllErrors() []error { return m }

// TicketDataAloneValidationError is the validation error returned by
// TicketDataAlone.Validate if the designated constraints aren't met.
type TicketDataAloneValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TicketDataAloneValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TicketDataAloneValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TicketDataAloneValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TicketDataAloneValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TicketDataAloneValidationError) ErrorName() string { return "TicketDataAloneValidationError" }

// Error satisfies the builtin error interface
func (e TicketDataAloneValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTicketDataAlone.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TicketDataAloneValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TicketDataAloneValidationError{}

// Validate checks the field values on VerificationInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VerificationInfoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VerificationInfoRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VerificationInfoRequestMultiError, or nil if none found.
func (m *VerificationInfoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *VerificationInfoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTicketCheckVerification()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VerificationInfoRequestValidationError{
					field:  "TicketCheckVerification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VerificationInfoRequestValidationError{
					field:  "TicketCheckVerification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTicketCheckVerification()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VerificationInfoRequestValidationError{
				field:  "TicketCheckVerification",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTicketListVerification()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VerificationInfoRequestValidationError{
					field:  "TicketListVerification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VerificationInfoRequestValidationError{
					field:  "TicketListVerification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTicketListVerification()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VerificationInfoRequestValidationError{
				field:  "TicketListVerification",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTicketCheckInfoVerification()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VerificationInfoRequestValidationError{
					field:  "TicketCheckInfoVerification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VerificationInfoRequestValidationError{
					field:  "TicketCheckInfoVerification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTicketCheckInfoVerification()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VerificationInfoRequestValidationError{
				field:  "TicketCheckInfoVerification",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetStockBatchNumber()) < 0 {
		err := VerificationInfoRequestValidationError{
			field:  "StockBatchNumber",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAccount()) != 42 {
		err := VerificationInfoRequestValidationError{
			field:  "Account",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetOrg()) < 0 {
		err := VerificationInfoRequestValidationError{
			field:  "Org",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return VerificationInfoRequestMultiError(errors)
	}

	return nil
}

// VerificationInfoRequestMultiError is an error wrapping multiple validation
// errors returned by VerificationInfoRequest.ValidateAll() if the designated
// constraints aren't met.
type VerificationInfoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VerificationInfoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VerificationInfoRequestMultiError) AllErrors() []error { return m }

// VerificationInfoRequestValidationError is the validation error returned by
// VerificationInfoRequest.Validate if the designated constraints aren't met.
type VerificationInfoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VerificationInfoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VerificationInfoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VerificationInfoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VerificationInfoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VerificationInfoRequestValidationError) ErrorName() string {
	return "VerificationInfoRequestValidationError"
}

// Error satisfies the builtin error interface
func (e VerificationInfoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerificationInfoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VerificationInfoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VerificationInfoRequestValidationError{}

// Validate checks the field values on TicketCheckVerification with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TicketCheckVerification) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TicketCheckVerification with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TicketCheckVerificationMultiError, or nil if none found.
func (m *TicketCheckVerification) ValidateAll() error {
	return m.validate(true)
}

func (m *TicketCheckVerification) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Way

	// no validation rules for ScenicId

	// no validation rules for PointId

	// no validation rules for EquipmentName

	// no validation rules for EquipmentType

	// no validation rules for EnterTime

	// no validation rules for EquipmentId

	// no validation rules for PointName

	// no validation rules for IdName

	// no validation rules for Picture

	if all {
		switch v := interface{}(m.GetCheckType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketCheckVerificationValidationError{
					field:  "CheckType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketCheckVerificationValidationError{
					field:  "CheckType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCheckType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketCheckVerificationValidationError{
				field:  "CheckType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TicketCheckVerificationMultiError(errors)
	}

	return nil
}

// TicketCheckVerificationMultiError is an error wrapping multiple validation
// errors returned by TicketCheckVerification.ValidateAll() if the designated
// constraints aren't met.
type TicketCheckVerificationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TicketCheckVerificationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TicketCheckVerificationMultiError) AllErrors() []error { return m }

// TicketCheckVerificationValidationError is the validation error returned by
// TicketCheckVerification.Validate if the designated constraints aren't met.
type TicketCheckVerificationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TicketCheckVerificationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TicketCheckVerificationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TicketCheckVerificationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TicketCheckVerificationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TicketCheckVerificationValidationError) ErrorName() string {
	return "TicketCheckVerificationValidationError"
}

// Error satisfies the builtin error interface
func (e TicketCheckVerificationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTicketCheckVerification.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TicketCheckVerificationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TicketCheckVerificationValidationError{}

// Validate checks the field values on TicketListVerification with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TicketListVerification) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TicketListVerification with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TicketListVerificationMultiError, or nil if none found.
func (m *TicketListVerification) ValidateAll() error {
	return m.validate(true)
}

func (m *TicketListVerification) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TicketListVerificationValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TicketListVerificationValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TicketListVerificationValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for UserId

	// no validation rules for Username

	if len(errors) > 0 {
		return TicketListVerificationMultiError(errors)
	}

	return nil
}

// TicketListVerificationMultiError is an error wrapping multiple validation
// errors returned by TicketListVerification.ValidateAll() if the designated
// constraints aren't met.
type TicketListVerificationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TicketListVerificationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TicketListVerificationMultiError) AllErrors() []error { return m }

// TicketListVerificationValidationError is the validation error returned by
// TicketListVerification.Validate if the designated constraints aren't met.
type TicketListVerificationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TicketListVerificationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TicketListVerificationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TicketListVerificationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TicketListVerificationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TicketListVerificationValidationError) ErrorName() string {
	return "TicketListVerificationValidationError"
}

// Error satisfies the builtin error interface
func (e TicketListVerificationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTicketListVerification.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TicketListVerificationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TicketListVerificationValidationError{}

// Validate checks the field values on ManualCheckNoVerification with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ManualCheckNoVerification) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ManualCheckNoVerification with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ManualCheckNoVerificationMultiError, or nil if none found.
func (m *ManualCheckNoVerification) ValidateAll() error {
	return m.validate(true)
}

func (m *ManualCheckNoVerification) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TicketNumber

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ManualCheckNoVerificationValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ManualCheckNoVerificationValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ManualCheckNoVerificationValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ManualCheckNoVerificationMultiError(errors)
	}

	return nil
}

// ManualCheckNoVerificationMultiError is an error wrapping multiple validation
// errors returned by ManualCheckNoVerification.ValidateAll() if the
// designated constraints aren't met.
type ManualCheckNoVerificationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ManualCheckNoVerificationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ManualCheckNoVerificationMultiError) AllErrors() []error { return m }

// ManualCheckNoVerificationValidationError is the validation error returned by
// ManualCheckNoVerification.Validate if the designated constraints aren't met.
type ManualCheckNoVerificationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ManualCheckNoVerificationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ManualCheckNoVerificationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ManualCheckNoVerificationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ManualCheckNoVerificationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ManualCheckNoVerificationValidationError) ErrorName() string {
	return "ManualCheckNoVerificationValidationError"
}

// Error satisfies the builtin error interface
func (e ManualCheckNoVerificationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sManualCheckNoVerification.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ManualCheckNoVerificationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ManualCheckNoVerificationValidationError{}

// Validate checks the field values on ManualCheckMultiUnitVerification with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ManualCheckMultiUnitVerification) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ManualCheckMultiUnitVerification with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ManualCheckMultiUnitVerificationMultiError, or nil if none found.
func (m *ManualCheckMultiUnitVerification) ValidateAll() error {
	return m.validate(true)
}

func (m *ManualCheckMultiUnitVerification) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCheckCount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ManualCheckMultiUnitVerificationValidationError{
					field:  "CheckCount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ManualCheckMultiUnitVerificationValidationError{
					field:  "CheckCount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCheckCount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ManualCheckMultiUnitVerificationValidationError{
				field:  "CheckCount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IdCardNumber

	// no validation rules for UseDate

	if len(errors) > 0 {
		return ManualCheckMultiUnitVerificationMultiError(errors)
	}

	return nil
}

// ManualCheckMultiUnitVerificationMultiError is an error wrapping multiple
// validation errors returned by
// ManualCheckMultiUnitVerification.ValidateAll() if the designated
// constraints aren't met.
type ManualCheckMultiUnitVerificationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ManualCheckMultiUnitVerificationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ManualCheckMultiUnitVerificationMultiError) AllErrors() []error { return m }

// ManualCheckMultiUnitVerificationValidationError is the validation error
// returned by ManualCheckMultiUnitVerification.Validate if the designated
// constraints aren't met.
type ManualCheckMultiUnitVerificationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ManualCheckMultiUnitVerificationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ManualCheckMultiUnitVerificationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ManualCheckMultiUnitVerificationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ManualCheckMultiUnitVerificationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ManualCheckMultiUnitVerificationValidationError) ErrorName() string {
	return "ManualCheckMultiUnitVerificationValidationError"
}

// Error satisfies the builtin error interface
func (e ManualCheckMultiUnitVerificationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sManualCheckMultiUnitVerification.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ManualCheckMultiUnitVerificationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ManualCheckMultiUnitVerificationValidationError{}

// Validate checks the field values on TicketCheckInfoVerification with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TicketCheckInfoVerification) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TicketCheckInfoVerification with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TicketCheckInfoVerificationMultiError, or nil if none found.
func (m *TicketCheckInfoVerification) ValidateAll() error {
	return m.validate(true)
}

func (m *TicketCheckInfoVerification) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Seq

	if all {
		switch v := interface{}(m.GetPassCount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketCheckInfoVerificationValidationError{
					field:  "PassCount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketCheckInfoVerificationValidationError{
					field:  "PassCount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPassCount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketCheckInfoVerificationValidationError{
				field:  "PassCount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TicketCheckInfoVerificationMultiError(errors)
	}

	return nil
}

// TicketCheckInfoVerificationMultiError is an error wrapping multiple
// validation errors returned by TicketCheckInfoVerification.ValidateAll() if
// the designated constraints aren't met.
type TicketCheckInfoVerificationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TicketCheckInfoVerificationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TicketCheckInfoVerificationMultiError) AllErrors() []error { return m }

// TicketCheckInfoVerificationValidationError is the validation error returned
// by TicketCheckInfoVerification.Validate if the designated constraints
// aren't met.
type TicketCheckInfoVerificationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TicketCheckInfoVerificationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TicketCheckInfoVerificationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TicketCheckInfoVerificationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TicketCheckInfoVerificationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TicketCheckInfoVerificationValidationError) ErrorName() string {
	return "TicketCheckInfoVerificationValidationError"
}

// Error satisfies the builtin error interface
func (e TicketCheckInfoVerificationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTicketCheckInfoVerification.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TicketCheckInfoVerificationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TicketCheckInfoVerificationValidationError{}

// Validate checks the field values on OrderInfoRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *OrderInfoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderInfoRequestMultiError, or nil if none found.
func (m *OrderInfoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderInfoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrderGroupId

	// no validation rules for OrderStatus

	// no validation rules for OrderType

	// no validation rules for TotalAmount

	// no validation rules for PayAmount

	// no validation rules for PayType

	// no validation rules for SourceType

	// no validation rules for StockCertificate

	// no validation rules for TradeNo

	// no validation rules for UserId

	// no validation rules for Username

	// no validation rules for PayTime

	// no validation rules for CertId

	// no validation rules for CAccount

	// no validation rules for UserPhone

	// no validation rules for BillStatus

	for idx, item := range m.GetOrderTabData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OrderInfoRequestValidationError{
						field:  fmt.Sprintf("OrderTabData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OrderInfoRequestValidationError{
						field:  fmt.Sprintf("OrderTabData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OrderInfoRequestValidationError{
					field:  fmt.Sprintf("OrderTabData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OrderInfoRequestMultiError(errors)
	}

	return nil
}

// OrderInfoRequestMultiError is an error wrapping multiple validation errors
// returned by OrderInfoRequest.ValidateAll() if the designated constraints
// aren't met.
type OrderInfoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderInfoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderInfoRequestMultiError) AllErrors() []error { return m }

// OrderInfoRequestValidationError is the validation error returned by
// OrderInfoRequest.Validate if the designated constraints aren't met.
type OrderInfoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderInfoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderInfoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderInfoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderInfoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderInfoRequestValidationError) ErrorName() string { return "OrderInfoRequestValidationError" }

// Error satisfies the builtin error interface
func (e OrderInfoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderInfoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderInfoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderInfoRequestValidationError{}

// Validate checks the field values on OrderTabData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OrderTabData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderTabData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OrderTabDataMultiError, or
// nil if none found.
func (m *OrderTabData) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderTabData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrderId

	// no validation rules for OrderType

	// no validation rules for SellerId

	// no validation rules for SellerName

	// no validation rules for TotalAmount

	// no validation rules for PayAmount

	// no validation rules for PayType

	// no validation rules for SourceType

	// no validation rules for OrderStatus

	// no validation rules for BillType

	// no validation rules for BillNumber

	// no validation rules for TradeNo

	// no validation rules for MerchantId

	// no validation rules for StoreId

	// no validation rules for AgentId

	// no validation rules for AgentName

	// no validation rules for CommissionSettledType

	// no validation rules for UserId

	// no validation rules for Username

	// no validation rules for PayTime

	// no validation rules for ModifyTime

	// no validation rules for IsDelete

	// no validation rules for TxId

	// no validation rules for CertId

	// no validation rules for CAccount

	// no validation rules for PayPeople

	// no validation rules for Nickname

	// no validation rules for MerchantNo

	for idx, item := range m.GetOrderProductTicketData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OrderTabDataValidationError{
						field:  fmt.Sprintf("OrderProductTicketData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OrderTabDataValidationError{
						field:  fmt.Sprintf("OrderProductTicketData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OrderTabDataValidationError{
					field:  fmt.Sprintf("OrderProductTicketData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OrderTabDataMultiError(errors)
	}

	return nil
}

// OrderTabDataMultiError is an error wrapping multiple validation errors
// returned by OrderTabData.ValidateAll() if the designated constraints aren't met.
type OrderTabDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderTabDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderTabDataMultiError) AllErrors() []error { return m }

// OrderTabDataValidationError is the validation error returned by
// OrderTabData.Validate if the designated constraints aren't met.
type OrderTabDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderTabDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderTabDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderTabDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderTabDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderTabDataValidationError) ErrorName() string { return "OrderTabDataValidationError" }

// Error satisfies the builtin error interface
func (e OrderTabDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderTabData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderTabDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderTabDataValidationError{}

// Validate checks the field values on OrderProductTicketData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OrderProductTicketData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderProductTicketData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderProductTicketDataMultiError, or nil if none found.
func (m *OrderProductTicketData) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderProductTicketData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ScenicId

	// no validation rules for ScenicName

	// no validation rules for TicketType

	// no validation rules for Day

	// no validation rules for TimeShareId

	// no validation rules for TimeShare

	// no validation rules for ParentProductId

	// no validation rules for CommissionType

	// no validation rules for CommissionRate

	// no validation rules for CommissionAmount

	// no validation rules for ActualComAmount

	// no validation rules for ServiceCharge

	// no validation rules for RightsId

	// no validation rules for BdsAccount

	// no validation rules for BdsOrg

	// no validation rules for RightsGoodsId

	// no validation rules for TicketTypeId

	// no validation rules for TicketTypeSubId

	// no validation rules for CardId

	// no validation rules for RealQuantity

	for idx, item := range m.GetOrderProductTicketRnData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OrderProductTicketDataValidationError{
						field:  fmt.Sprintf("OrderProductTicketRnData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OrderProductTicketDataValidationError{
						field:  fmt.Sprintf("OrderProductTicketRnData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OrderProductTicketDataValidationError{
					field:  fmt.Sprintf("OrderProductTicketRnData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OrderProductTicketDataMultiError(errors)
	}

	return nil
}

// OrderProductTicketDataMultiError is an error wrapping multiple validation
// errors returned by OrderProductTicketData.ValidateAll() if the designated
// constraints aren't met.
type OrderProductTicketDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderProductTicketDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderProductTicketDataMultiError) AllErrors() []error { return m }

// OrderProductTicketDataValidationError is the validation error returned by
// OrderProductTicketData.Validate if the designated constraints aren't met.
type OrderProductTicketDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderProductTicketDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderProductTicketDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderProductTicketDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderProductTicketDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderProductTicketDataValidationError) ErrorName() string {
	return "OrderProductTicketDataValidationError"
}

// Error satisfies the builtin error interface
func (e OrderProductTicketDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderProductTicketData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderProductTicketDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderProductTicketDataValidationError{}

// Validate checks the field values on OrderProductTicketRnData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OrderProductTicketRnData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderProductTicketRnData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderProductTicketRnDataMultiError, or nil if none found.
func (m *OrderProductTicketRnData) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderProductTicketRnData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for OrderProductId

	// no validation rules for TicketNumber

	// no validation rules for TicketStatus

	// no validation rules for CommissionSettledStatus

	// no validation rules for IsChain

	// no validation rules for BillStatus

	// no validation rules for IssueTicketType

	if len(errors) > 0 {
		return OrderProductTicketRnDataMultiError(errors)
	}

	return nil
}

// OrderProductTicketRnDataMultiError is an error wrapping multiple validation
// errors returned by OrderProductTicketRnData.ValidateAll() if the designated
// constraints aren't met.
type OrderProductTicketRnDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderProductTicketRnDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderProductTicketRnDataMultiError) AllErrors() []error { return m }

// OrderProductTicketRnDataValidationError is the validation error returned by
// OrderProductTicketRnData.Validate if the designated constraints aren't met.
type OrderProductTicketRnDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderProductTicketRnDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderProductTicketRnDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderProductTicketRnDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderProductTicketRnDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderProductTicketRnDataValidationError) ErrorName() string {
	return "OrderProductTicketRnDataValidationError"
}

// Error satisfies the builtin error interface
func (e OrderProductTicketRnDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderProductTicketRnData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderProductTicketRnDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderProductTicketRnDataValidationError{}

// Validate checks the field values on OrderInfoResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *OrderInfoResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderInfoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderInfoResponseMultiError, or nil if none found.
func (m *OrderInfoResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderInfoResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderInfoResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderInfoResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderInfoResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OrderInfoResponseMultiError(errors)
	}

	return nil
}

// OrderInfoResponseMultiError is an error wrapping multiple validation errors
// returned by OrderInfoResponse.ValidateAll() if the designated constraints
// aren't met.
type OrderInfoResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderInfoResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderInfoResponseMultiError) AllErrors() []error { return m }

// OrderInfoResponseValidationError is the validation error returned by
// OrderInfoResponse.Validate if the designated constraints aren't met.
type OrderInfoResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderInfoResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderInfoResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderInfoResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderInfoResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderInfoResponseValidationError) ErrorName() string {
	return "OrderInfoResponseValidationError"
}

// Error satisfies the builtin error interface
func (e OrderInfoResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderInfoResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderInfoResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderInfoResponseValidationError{}

// Validate checks the field values on GenerateTicketIssuanceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateTicketIssuanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateTicketIssuanceRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GenerateTicketIssuanceRequestMultiError, or nil if none found.
func (m *GenerateTicketIssuanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateTicketIssuanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetStockBatchNumberData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GenerateTicketIssuanceRequestValidationError{
						field:  fmt.Sprintf("StockBatchNumberData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GenerateTicketIssuanceRequestValidationError{
						field:  fmt.Sprintf("StockBatchNumberData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GenerateTicketIssuanceRequestValidationError{
					field:  fmt.Sprintf("StockBatchNumberData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetGenerateTicketNumberInfoData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GenerateTicketIssuanceRequestValidationError{
						field:  fmt.Sprintf("GenerateTicketNumberInfoData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GenerateTicketIssuanceRequestValidationError{
						field:  fmt.Sprintf("GenerateTicketNumberInfoData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GenerateTicketIssuanceRequestValidationError{
					field:  fmt.Sprintf("GenerateTicketNumberInfoData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TicketIssuanceType

	// no validation rules for OrderId

	if len(errors) > 0 {
		return GenerateTicketIssuanceRequestMultiError(errors)
	}

	return nil
}

// GenerateTicketIssuanceRequestMultiError is an error wrapping multiple
// validation errors returned by GenerateTicketIssuanceRequest.ValidateAll()
// if the designated constraints aren't met.
type GenerateTicketIssuanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateTicketIssuanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateTicketIssuanceRequestMultiError) AllErrors() []error { return m }

// GenerateTicketIssuanceRequestValidationError is the validation error
// returned by GenerateTicketIssuanceRequest.Validate if the designated
// constraints aren't met.
type GenerateTicketIssuanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateTicketIssuanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateTicketIssuanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateTicketIssuanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateTicketIssuanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateTicketIssuanceRequestValidationError) ErrorName() string {
	return "GenerateTicketIssuanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateTicketIssuanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateTicketIssuanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateTicketIssuanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateTicketIssuanceRequestValidationError{}

// Validate checks the field values on StockBatchNumberData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StockBatchNumberData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StockBatchNumberData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StockBatchNumberDataMultiError, or nil if none found.
func (m *StockBatchNumberData) ValidateAll() error {
	return m.validate(true)
}

func (m *StockBatchNumberData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAccount()) != 42 {
		err := StockBatchNumberDataValidationError{
			field:  "Account",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetOrg()) < 0 {
		err := StockBatchNumberDataValidationError{
			field:  "Org",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetStockBatchNumber()) < 0 {
		err := StockBatchNumberDataValidationError{
			field:  "StockBatchNumber",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Number

	if len(errors) > 0 {
		return StockBatchNumberDataMultiError(errors)
	}

	return nil
}

// StockBatchNumberDataMultiError is an error wrapping multiple validation
// errors returned by StockBatchNumberData.ValidateAll() if the designated
// constraints aren't met.
type StockBatchNumberDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StockBatchNumberDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StockBatchNumberDataMultiError) AllErrors() []error { return m }

// StockBatchNumberDataValidationError is the validation error returned by
// StockBatchNumberData.Validate if the designated constraints aren't met.
type StockBatchNumberDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StockBatchNumberDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StockBatchNumberDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StockBatchNumberDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StockBatchNumberDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StockBatchNumberDataValidationError) ErrorName() string {
	return "StockBatchNumberDataValidationError"
}

// Error satisfies the builtin error interface
func (e StockBatchNumberDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStockBatchNumberData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StockBatchNumberDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StockBatchNumberDataValidationError{}

// Validate checks the field values on GenerateTicketNumberInfoData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateTicketNumberInfoData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateTicketNumberInfoData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GenerateTicketNumberInfoDataMultiError, or nil if none found.
func (m *GenerateTicketNumberInfoData) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateTicketNumberInfoData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EnterTime

	if all {
		switch v := interface{}(m.GetPlayerNum()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateTicketNumberInfoDataValidationError{
					field:  "PlayerNum",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateTicketNumberInfoDataValidationError{
					field:  "PlayerNum",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlayerNum()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateTicketNumberInfoDataValidationError{
				field:  "PlayerNum",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Certificate

	// no validation rules for Rand

	// no validation rules for ScenicId

	if all {
		switch v := interface{}(m.GetProType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateTicketNumberInfoDataValidationError{
					field:  "ProType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateTicketNumberInfoDataValidationError{
					field:  "ProType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateTicketNumberInfoDataValidationError{
				field:  "ProType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeShareId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateTicketNumberInfoDataValidationError{
					field:  "TimeShareId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateTicketNumberInfoDataValidationError{
					field:  "TimeShareId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeShareId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateTicketNumberInfoDataValidationError{
				field:  "TimeShareId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeShareBook()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateTicketNumberInfoDataValidationError{
					field:  "TimeShareBook",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateTicketNumberInfoDataValidationError{
					field:  "TimeShareBook",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeShareBook()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateTicketNumberInfoDataValidationError{
				field:  "TimeShareBook",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for BeginTime

	// no validation rules for EndTime

	for idx, item := range m.GetCheckPointIds() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GenerateTicketNumberInfoDataValidationError{
						field:  fmt.Sprintf("CheckPointIds[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GenerateTicketNumberInfoDataValidationError{
						field:  fmt.Sprintf("CheckPointIds[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GenerateTicketNumberInfoDataValidationError{
					field:  fmt.Sprintf("CheckPointIds[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Uuid

	if len(errors) > 0 {
		return GenerateTicketNumberInfoDataMultiError(errors)
	}

	return nil
}

// GenerateTicketNumberInfoDataMultiError is an error wrapping multiple
// validation errors returned by GenerateTicketNumberInfoData.ValidateAll() if
// the designated constraints aren't met.
type GenerateTicketNumberInfoDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateTicketNumberInfoDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateTicketNumberInfoDataMultiError) AllErrors() []error { return m }

// GenerateTicketNumberInfoDataValidationError is the validation error returned
// by GenerateTicketNumberInfoData.Validate if the designated constraints
// aren't met.
type GenerateTicketNumberInfoDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateTicketNumberInfoDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateTicketNumberInfoDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateTicketNumberInfoDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateTicketNumberInfoDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateTicketNumberInfoDataValidationError) ErrorName() string {
	return "GenerateTicketNumberInfoDataValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateTicketNumberInfoDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateTicketNumberInfoData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateTicketNumberInfoDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateTicketNumberInfoDataValidationError{}

// Validate checks the field values on GenerateTicketIssuanceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateTicketIssuanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateTicketIssuanceResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GenerateTicketIssuanceResponseMultiError, or nil if none found.
func (m *GenerateTicketIssuanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateTicketIssuanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateTicketIssuanceResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateTicketIssuanceResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateTicketIssuanceResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GenerateTicketIssuanceResponseMultiError(errors)
	}

	return nil
}

// GenerateTicketIssuanceResponseMultiError is an error wrapping multiple
// validation errors returned by GenerateTicketIssuanceResponse.ValidateAll()
// if the designated constraints aren't met.
type GenerateTicketIssuanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateTicketIssuanceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateTicketIssuanceResponseMultiError) AllErrors() []error { return m }

// GenerateTicketIssuanceResponseValidationError is the validation error
// returned by GenerateTicketIssuanceResponse.Validate if the designated
// constraints aren't met.
type GenerateTicketIssuanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateTicketIssuanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateTicketIssuanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateTicketIssuanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateTicketIssuanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateTicketIssuanceResponseValidationError) ErrorName() string {
	return "GenerateTicketIssuanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateTicketIssuanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateTicketIssuanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateTicketIssuanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateTicketIssuanceResponseValidationError{}

// Validate checks the field values on GenerateTicketIssuanceData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateTicketIssuanceData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateTicketIssuanceData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GenerateTicketIssuanceDataMultiError, or nil if none found.
func (m *GenerateTicketIssuanceData) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateTicketIssuanceData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TicketNumber

	// no validation rules for PrintEncode

	// no validation rules for Sign

	if len(errors) > 0 {
		return GenerateTicketIssuanceDataMultiError(errors)
	}

	return nil
}

// GenerateTicketIssuanceDataMultiError is an error wrapping multiple
// validation errors returned by GenerateTicketIssuanceData.ValidateAll() if
// the designated constraints aren't met.
type GenerateTicketIssuanceDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateTicketIssuanceDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateTicketIssuanceDataMultiError) AllErrors() []error { return m }

// GenerateTicketIssuanceDataValidationError is the validation error returned
// by GenerateTicketIssuanceData.Validate if the designated constraints aren't met.
type GenerateTicketIssuanceDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateTicketIssuanceDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateTicketIssuanceDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateTicketIssuanceDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateTicketIssuanceDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateTicketIssuanceDataValidationError) ErrorName() string {
	return "GenerateTicketIssuanceDataValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateTicketIssuanceDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateTicketIssuanceData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateTicketIssuanceDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateTicketIssuanceDataValidationError{}

// Validate checks the field values on DistributionOrderInfoRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DistributionOrderInfoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DistributionOrderInfoRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DistributionOrderInfoRequestMultiError, or nil if none found.
func (m *DistributionOrderInfoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DistributionOrderInfoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrderGroupId

	// no validation rules for OrderStatus

	// no validation rules for OrderType

	// no validation rules for TotalAmount

	// no validation rules for PayAmount

	// no validation rules for PayType

	// no validation rules for SourceType

	// no validation rules for StockCertificate

	// no validation rules for TradeNo

	// no validation rules for UserId

	// no validation rules for Username

	// no validation rules for PayTime

	// no validation rules for CertId

	// no validation rules for CAccount

	// no validation rules for UserPhone

	// no validation rules for BillStatus

	// no validation rules for TxId

	for idx, item := range m.GetOrderTabToBData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DistributionOrderInfoRequestValidationError{
						field:  fmt.Sprintf("OrderTabToBData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DistributionOrderInfoRequestValidationError{
						field:  fmt.Sprintf("OrderTabToBData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DistributionOrderInfoRequestValidationError{
					field:  fmt.Sprintf("OrderTabToBData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOrderTabDistributeData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DistributionOrderInfoRequestValidationError{
						field:  fmt.Sprintf("OrderTabDistributeData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DistributionOrderInfoRequestValidationError{
						field:  fmt.Sprintf("OrderTabDistributeData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DistributionOrderInfoRequestValidationError{
					field:  fmt.Sprintf("OrderTabDistributeData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DistributionOrderInfoRequestMultiError(errors)
	}

	return nil
}

// DistributionOrderInfoRequestMultiError is an error wrapping multiple
// validation errors returned by DistributionOrderInfoRequest.ValidateAll() if
// the designated constraints aren't met.
type DistributionOrderInfoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DistributionOrderInfoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DistributionOrderInfoRequestMultiError) AllErrors() []error { return m }

// DistributionOrderInfoRequestValidationError is the validation error returned
// by DistributionOrderInfoRequest.Validate if the designated constraints
// aren't met.
type DistributionOrderInfoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DistributionOrderInfoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DistributionOrderInfoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DistributionOrderInfoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DistributionOrderInfoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DistributionOrderInfoRequestValidationError) ErrorName() string {
	return "DistributionOrderInfoRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DistributionOrderInfoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDistributionOrderInfoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DistributionOrderInfoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DistributionOrderInfoRequestValidationError{}

// Validate checks the field values on OrderTabToBData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *OrderTabToBData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderTabToBData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderTabToBDataMultiError, or nil if none found.
func (m *OrderTabToBData) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderTabToBData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrderId

	// no validation rules for OrderType

	// no validation rules for SellerId

	// no validation rules for SellerName

	// no validation rules for TotalAmount

	// no validation rules for PayAmount

	// no validation rules for PayType

	// no validation rules for SourceType

	// no validation rules for OrderStatus

	// no validation rules for BillType

	// no validation rules for BillNumber

	// no validation rules for TradeNo

	// no validation rules for MerchantId

	// no validation rules for StoreId

	// no validation rules for AgentId

	// no validation rules for AgentName

	// no validation rules for CommissionSettledType

	// no validation rules for UserId

	// no validation rules for Username

	// no validation rules for PayTime

	// no validation rules for TxId

	// no validation rules for CertId

	// no validation rules for CAccount

	// no validation rules for Nickname

	// no validation rules for MerchantNo

	// no validation rules for IsChain

	if len(errors) > 0 {
		return OrderTabToBDataMultiError(errors)
	}

	return nil
}

// OrderTabToBDataMultiError is an error wrapping multiple validation errors
// returned by OrderTabToBData.ValidateAll() if the designated constraints
// aren't met.
type OrderTabToBDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderTabToBDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderTabToBDataMultiError) AllErrors() []error { return m }

// OrderTabToBDataValidationError is the validation error returned by
// OrderTabToBData.Validate if the designated constraints aren't met.
type OrderTabToBDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderTabToBDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderTabToBDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderTabToBDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderTabToBDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderTabToBDataValidationError) ErrorName() string { return "OrderTabToBDataValidationError" }

// Error satisfies the builtin error interface
func (e OrderTabToBDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderTabToBData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderTabToBDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderTabToBDataValidationError{}

// Validate checks the field values on OrderTabDistributeData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OrderTabDistributeData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderTabDistributeData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderTabDistributeDataMultiError, or nil if none found.
func (m *OrderTabDistributeData) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderTabDistributeData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrderId

	// no validation rules for BuyerId

	// no validation rules for BuyerName

	// no validation rules for SellerId

	// no validation rules for SellerName

	// no validation rules for ServiceProviderId

	// no validation rules for ServiceProviderName

	// no validation rules for IsBc

	if utf8.RuneCountInString(m.GetSellerAccount()) != 42 {
		err := OrderTabDistributeDataValidationError{
			field:  "SellerAccount",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetSellerOrg()) < 0 {
		err := OrderTabDistributeDataValidationError{
			field:  "SellerOrg",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBuyerAccount()) != 42 {
		err := OrderTabDistributeDataValidationError{
			field:  "BuyerAccount",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetBuyerOrg()) < 0 {
		err := OrderTabDistributeDataValidationError{
			field:  "BuyerOrg",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetOrderProductDistributeData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OrderTabDistributeDataValidationError{
						field:  fmt.Sprintf("OrderProductDistributeData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OrderTabDistributeDataValidationError{
						field:  fmt.Sprintf("OrderProductDistributeData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OrderTabDistributeDataValidationError{
					field:  fmt.Sprintf("OrderProductDistributeData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OrderTabDistributeDataMultiError(errors)
	}

	return nil
}

// OrderTabDistributeDataMultiError is an error wrapping multiple validation
// errors returned by OrderTabDistributeData.ValidateAll() if the designated
// constraints aren't met.
type OrderTabDistributeDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderTabDistributeDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderTabDistributeDataMultiError) AllErrors() []error { return m }

// OrderTabDistributeDataValidationError is the validation error returned by
// OrderTabDistributeData.Validate if the designated constraints aren't met.
type OrderTabDistributeDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderTabDistributeDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderTabDistributeDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderTabDistributeDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderTabDistributeDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderTabDistributeDataValidationError) ErrorName() string {
	return "OrderTabDistributeDataValidationError"
}

// Error satisfies the builtin error interface
func (e OrderTabDistributeDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderTabDistributeData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderTabDistributeDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderTabDistributeDataValidationError{}

// Validate checks the field values on OrderProductDistributeData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OrderProductDistributeData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderProductDistributeData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderProductDistributeDataMultiError, or nil if none found.
func (m *OrderProductDistributeData) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderProductDistributeData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ScenicId

	// no validation rules for ScenicName

	// no validation rules for DistributorTicketStockId

	// no validation rules for BatchId

	// no validation rules for TicketType

	// no validation rules for DayBegin

	// no validation rules for DayEnd

	// no validation rules for TimeShare

	// no validation rules for TimeShareId

	// no validation rules for UsableNum

	// no validation rules for OrderProductId

	// no validation rules for OrderId

	// no validation rules for ProductId

	// no validation rules for ProductName

	// no validation rules for ProductSkuId

	// no validation rules for ProductSkuName

	// no validation rules for ProductPrice

	// no validation rules for Num

	// no validation rules for ProductType

	if utf8.RuneCountInString(m.GetStockBatchNumber()) < 0 {
		err := OrderProductDistributeDataValidationError{
			field:  "StockBatchNumber",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AvailableRatio

	// no validation rules for ExchangeFreezeNum

	// no validation rules for AvailableTotalNum

	if len(errors) > 0 {
		return OrderProductDistributeDataMultiError(errors)
	}

	return nil
}

// OrderProductDistributeDataMultiError is an error wrapping multiple
// validation errors returned by OrderProductDistributeData.ValidateAll() if
// the designated constraints aren't met.
type OrderProductDistributeDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderProductDistributeDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderProductDistributeDataMultiError) AllErrors() []error { return m }

// OrderProductDistributeDataValidationError is the validation error returned
// by OrderProductDistributeData.Validate if the designated constraints aren't met.
type OrderProductDistributeDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderProductDistributeDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderProductDistributeDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderProductDistributeDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderProductDistributeDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderProductDistributeDataValidationError) ErrorName() string {
	return "OrderProductDistributeDataValidationError"
}

// Error satisfies the builtin error interface
func (e OrderProductDistributeDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderProductDistributeData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderProductDistributeDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderProductDistributeDataValidationError{}

// Validate checks the field values on DistributionOrderInfoResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DistributionOrderInfoResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DistributionOrderInfoResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DistributionOrderInfoResponseMultiError, or nil if none found.
func (m *DistributionOrderInfoResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DistributionOrderInfoResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DistributionOrderInfoResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DistributionOrderInfoResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DistributionOrderInfoResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DistributionOrderInfoResponseMultiError(errors)
	}

	return nil
}

// DistributionOrderInfoResponseMultiError is an error wrapping multiple
// validation errors returned by DistributionOrderInfoResponse.ValidateAll()
// if the designated constraints aren't met.
type DistributionOrderInfoResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DistributionOrderInfoResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DistributionOrderInfoResponseMultiError) AllErrors() []error { return m }

// DistributionOrderInfoResponseValidationError is the validation error
// returned by DistributionOrderInfoResponse.Validate if the designated
// constraints aren't met.
type DistributionOrderInfoResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DistributionOrderInfoResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DistributionOrderInfoResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DistributionOrderInfoResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DistributionOrderInfoResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DistributionOrderInfoResponseValidationError) ErrorName() string {
	return "DistributionOrderInfoResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DistributionOrderInfoResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDistributionOrderInfoResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DistributionOrderInfoResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DistributionOrderInfoResponseValidationError{}

// Validate checks the field values on BlockOrderRefundRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BlockOrderRefundRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlockOrderRefundRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BlockOrderRefundRequestMultiError, or nil if none found.
func (m *BlockOrderRefundRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BlockOrderRefundRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBlockRefundInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockOrderRefundRequestValidationError{
					field:  "BlockRefundInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockOrderRefundRequestValidationError{
					field:  "BlockRefundInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBlockRefundInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockOrderRefundRequestValidationError{
				field:  "BlockRefundInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetBlockOrderRefundProductTicket() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BlockOrderRefundRequestValidationError{
						field:  fmt.Sprintf("BlockOrderRefundProductTicket[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BlockOrderRefundRequestValidationError{
						field:  fmt.Sprintf("BlockOrderRefundProductTicket[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BlockOrderRefundRequestValidationError{
					field:  fmt.Sprintf("BlockOrderRefundProductTicket[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BlockOrderRefundRequestMultiError(errors)
	}

	return nil
}

// BlockOrderRefundRequestMultiError is an error wrapping multiple validation
// errors returned by BlockOrderRefundRequest.ValidateAll() if the designated
// constraints aren't met.
type BlockOrderRefundRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlockOrderRefundRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlockOrderRefundRequestMultiError) AllErrors() []error { return m }

// BlockOrderRefundRequestValidationError is the validation error returned by
// BlockOrderRefundRequest.Validate if the designated constraints aren't met.
type BlockOrderRefundRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlockOrderRefundRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlockOrderRefundRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlockOrderRefundRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlockOrderRefundRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlockOrderRefundRequestValidationError) ErrorName() string {
	return "BlockOrderRefundRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BlockOrderRefundRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlockOrderRefundRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlockOrderRefundRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlockOrderRefundRequestValidationError{}

// Validate checks the field values on BlockOrderRefundProductTicket with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BlockOrderRefundProductTicket) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlockOrderRefundProductTicket with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BlockOrderRefundProductTicketMultiError, or nil if none found.
func (m *BlockOrderRefundProductTicket) ValidateAll() error {
	return m.validate(true)
}

func (m *BlockOrderRefundProductTicket) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RefundId

	// no validation rules for OrderProductId

	// no validation rules for TicketNumber

	// no validation rules for ProductId

	// no validation rules for ProductName

	// no validation rules for ProductSkuId

	// no validation rules for ProductType

	// no validation rules for TicketType

	// no validation rules for Day

	// no validation rules for Name

	// no validation rules for Identity

	// no validation rules for SourceType

	// no validation rules for RefundAmount

	// no validation rules for RefundFee

	// no validation rules for RefundNum

	for idx, item := range m.GetDistributorTicketStockTransferInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BlockOrderRefundProductTicketValidationError{
						field:  fmt.Sprintf("DistributorTicketStockTransferInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BlockOrderRefundProductTicketValidationError{
						field:  fmt.Sprintf("DistributorTicketStockTransferInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BlockOrderRefundProductTicketValidationError{
					field:  fmt.Sprintf("DistributorTicketStockTransferInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BlockOrderRefundProductTicketMultiError(errors)
	}

	return nil
}

// BlockOrderRefundProductTicketMultiError is an error wrapping multiple
// validation errors returned by BlockOrderRefundProductTicket.ValidateAll()
// if the designated constraints aren't met.
type BlockOrderRefundProductTicketMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlockOrderRefundProductTicketMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlockOrderRefundProductTicketMultiError) AllErrors() []error { return m }

// BlockOrderRefundProductTicketValidationError is the validation error
// returned by BlockOrderRefundProductTicket.Validate if the designated
// constraints aren't met.
type BlockOrderRefundProductTicketValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlockOrderRefundProductTicketValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlockOrderRefundProductTicketValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlockOrderRefundProductTicketValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlockOrderRefundProductTicketValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlockOrderRefundProductTicketValidationError) ErrorName() string {
	return "BlockOrderRefundProductTicketValidationError"
}

// Error satisfies the builtin error interface
func (e BlockOrderRefundProductTicketValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlockOrderRefundProductTicket.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlockOrderRefundProductTicketValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlockOrderRefundProductTicketValidationError{}

// Validate checks the field values on DistributorTicketStockTransferInfoRefund
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *DistributorTicketStockTransferInfoRefund) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// DistributorTicketStockTransferInfoRefund with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// DistributorTicketStockTransferInfoRefundMultiError, or nil if none found.
func (m *DistributorTicketStockTransferInfoRefund) ValidateAll() error {
	return m.validate(true)
}

func (m *DistributorTicketStockTransferInfoRefund) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Number

	// no validation rules for BatchId

	// no validation rules for StockBatchNumber

	if utf8.RuneCountInString(m.GetAccount()) != 42 {
		err := DistributorTicketStockTransferInfoRefundValidationError{
			field:  "Account",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetOrg()) < 0 {
		err := DistributorTicketStockTransferInfoRefundValidationError{
			field:  "Org",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DistributorTicketStockTransferInfoRefundMultiError(errors)
	}

	return nil
}

// DistributorTicketStockTransferInfoRefundMultiError is an error wrapping
// multiple validation errors returned by
// DistributorTicketStockTransferInfoRefund.ValidateAll() if the designated
// constraints aren't met.
type DistributorTicketStockTransferInfoRefundMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DistributorTicketStockTransferInfoRefundMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DistributorTicketStockTransferInfoRefundMultiError) AllErrors() []error { return m }

// DistributorTicketStockTransferInfoRefundValidationError is the validation
// error returned by DistributorTicketStockTransferInfoRefund.Validate if the
// designated constraints aren't met.
type DistributorTicketStockTransferInfoRefundValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DistributorTicketStockTransferInfoRefundValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DistributorTicketStockTransferInfoRefundValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DistributorTicketStockTransferInfoRefundValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DistributorTicketStockTransferInfoRefundValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DistributorTicketStockTransferInfoRefundValidationError) ErrorName() string {
	return "DistributorTicketStockTransferInfoRefundValidationError"
}

// Error satisfies the builtin error interface
func (e DistributorTicketStockTransferInfoRefundValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDistributorTicketStockTransferInfoRefund.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DistributorTicketStockTransferInfoRefundValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DistributorTicketStockTransferInfoRefundValidationError{}

// Validate checks the field values on BlockRefundInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BlockRefundInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlockRefundInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BlockRefundInfoMultiError, or nil if none found.
func (m *BlockRefundInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *BlockRefundInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RefundId

	// no validation rules for OrderId

	// no validation rules for RefundAmount

	// no validation rules for RefundFee

	// no validation rules for RefundStatus

	// no validation rules for RefundType

	// no validation rules for TradeNo

	// no validation rules for RefundTime

	// no validation rules for Remark

	// no validation rules for FailMessage

	// no validation rules for CommissionSettledStatus

	// no validation rules for StockCertificate

	// no validation rules for ProductSkuName

	// no validation rules for UserId

	// no validation rules for Username

	// no validation rules for CertId

	// no validation rules for TxId

	// no validation rules for BillStatus

	// no validation rules for OrderGroupId

	if len(errors) > 0 {
		return BlockRefundInfoMultiError(errors)
	}

	return nil
}

// BlockRefundInfoMultiError is an error wrapping multiple validation errors
// returned by BlockRefundInfo.ValidateAll() if the designated constraints
// aren't met.
type BlockRefundInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlockRefundInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlockRefundInfoMultiError) AllErrors() []error { return m }

// BlockRefundInfoValidationError is the validation error returned by
// BlockRefundInfo.Validate if the designated constraints aren't met.
type BlockRefundInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlockRefundInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlockRefundInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlockRefundInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlockRefundInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlockRefundInfoValidationError) ErrorName() string { return "BlockRefundInfoValidationError" }

// Error satisfies the builtin error interface
func (e BlockRefundInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlockRefundInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlockRefundInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlockRefundInfoValidationError{}

// Validate checks the field values on BlockOrderRefundResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BlockOrderRefundResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlockOrderRefundResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BlockOrderRefundResponseMultiError, or nil if none found.
func (m *BlockOrderRefundResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BlockOrderRefundResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockOrderRefundResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockOrderRefundResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockOrderRefundResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BlockOrderRefundResponseMultiError(errors)
	}

	return nil
}

// BlockOrderRefundResponseMultiError is an error wrapping multiple validation
// errors returned by BlockOrderRefundResponse.ValidateAll() if the designated
// constraints aren't met.
type BlockOrderRefundResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlockOrderRefundResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlockOrderRefundResponseMultiError) AllErrors() []error { return m }

// BlockOrderRefundResponseValidationError is the validation error returned by
// BlockOrderRefundResponse.Validate if the designated constraints aren't met.
type BlockOrderRefundResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlockOrderRefundResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlockOrderRefundResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlockOrderRefundResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlockOrderRefundResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlockOrderRefundResponseValidationError) ErrorName() string {
	return "BlockOrderRefundResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BlockOrderRefundResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlockOrderRefundResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlockOrderRefundResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlockOrderRefundResponseValidationError{}

// Validate checks the field values on DistributeRefundCreateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DistributeRefundCreateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DistributeRefundCreateRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DistributeRefundCreateRequestMultiError, or nil if none found.
func (m *DistributeRefundCreateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DistributeRefundCreateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOrderRefundGroup() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DistributeRefundCreateRequestValidationError{
						field:  fmt.Sprintf("OrderRefundGroup[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DistributeRefundCreateRequestValidationError{
						field:  fmt.Sprintf("OrderRefundGroup[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DistributeRefundCreateRequestValidationError{
					field:  fmt.Sprintf("OrderRefundGroup[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOrderRefund() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DistributeRefundCreateRequestValidationError{
						field:  fmt.Sprintf("OrderRefund[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DistributeRefundCreateRequestValidationError{
						field:  fmt.Sprintf("OrderRefund[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DistributeRefundCreateRequestValidationError{
					field:  fmt.Sprintf("OrderRefund[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOrderRefundProductDistribute() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DistributeRefundCreateRequestValidationError{
						field:  fmt.Sprintf("OrderRefundProductDistribute[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DistributeRefundCreateRequestValidationError{
						field:  fmt.Sprintf("OrderRefundProductDistribute[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DistributeRefundCreateRequestValidationError{
					field:  fmt.Sprintf("OrderRefundProductDistribute[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DistributeRefundCreateRequestMultiError(errors)
	}

	return nil
}

// DistributeRefundCreateRequestMultiError is an error wrapping multiple
// validation errors returned by DistributeRefundCreateRequest.ValidateAll()
// if the designated constraints aren't met.
type DistributeRefundCreateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DistributeRefundCreateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DistributeRefundCreateRequestMultiError) AllErrors() []error { return m }

// DistributeRefundCreateRequestValidationError is the validation error
// returned by DistributeRefundCreateRequest.Validate if the designated
// constraints aren't met.
type DistributeRefundCreateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DistributeRefundCreateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DistributeRefundCreateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DistributeRefundCreateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DistributeRefundCreateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DistributeRefundCreateRequestValidationError) ErrorName() string {
	return "DistributeRefundCreateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DistributeRefundCreateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDistributeRefundCreateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DistributeRefundCreateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DistributeRefundCreateRequestValidationError{}

// Validate checks the field values on OrderRefundGroup with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *OrderRefundGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderRefundGroup with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderRefundGroupMultiError, or nil if none found.
func (m *OrderRefundGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderRefundGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrderRefundGroupId

	// no validation rules for OrderGroupId

	// no validation rules for OrderRefundId

	// no validation rules for CreateTime

	if len(errors) > 0 {
		return OrderRefundGroupMultiError(errors)
	}

	return nil
}

// OrderRefundGroupMultiError is an error wrapping multiple validation errors
// returned by OrderRefundGroup.ValidateAll() if the designated constraints
// aren't met.
type OrderRefundGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderRefundGroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderRefundGroupMultiError) AllErrors() []error { return m }

// OrderRefundGroupValidationError is the validation error returned by
// OrderRefundGroup.Validate if the designated constraints aren't met.
type OrderRefundGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderRefundGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderRefundGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderRefundGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderRefundGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderRefundGroupValidationError) ErrorName() string { return "OrderRefundGroupValidationError" }

// Error satisfies the builtin error interface
func (e OrderRefundGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderRefundGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderRefundGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderRefundGroupValidationError{}

// Validate checks the field values on OrderRefund with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OrderRefund) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderRefund with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OrderRefundMultiError, or
// nil if none found.
func (m *OrderRefund) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderRefund) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RefundId

	// no validation rules for OrderId

	// no validation rules for RefundAmount

	// no validation rules for RefundFee

	// no validation rules for RefundStatus

	// no validation rules for RefundType

	// no validation rules for TradeNo

	// no validation rules for RefundTime

	// no validation rules for CreateTime

	// no validation rules for Remark

	// no validation rules for FailMessage

	// no validation rules for UserId

	// no validation rules for Username

	// no validation rules for CommissionSettledStatus

	// no validation rules for StockCertificate

	// no validation rules for ProductSkuName

	// no validation rules for CertId

	// no validation rules for TxId

	// no validation rules for SellerAccount

	// no validation rules for SellerOrg

	// no validation rules for BuyerAccount

	// no validation rules for BuyerOrg

	if len(errors) > 0 {
		return OrderRefundMultiError(errors)
	}

	return nil
}

// OrderRefundMultiError is an error wrapping multiple validation errors
// returned by OrderRefund.ValidateAll() if the designated constraints aren't met.
type OrderRefundMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderRefundMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderRefundMultiError) AllErrors() []error { return m }

// OrderRefundValidationError is the validation error returned by
// OrderRefund.Validate if the designated constraints aren't met.
type OrderRefundValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderRefundValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderRefundValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderRefundValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderRefundValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderRefundValidationError) ErrorName() string { return "OrderRefundValidationError" }

// Error satisfies the builtin error interface
func (e OrderRefundValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderRefund.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderRefundValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderRefundValidationError{}

// Validate checks the field values on OrderRefundProductDistribute with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OrderRefundProductDistribute) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderRefundProductDistribute with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderRefundProductDistributeMultiError, or nil if none found.
func (m *OrderRefundProductDistribute) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderRefundProductDistribute) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RefundId

	// no validation rules for OrderProductId

	// no validation rules for Num

	// no validation rules for ProductId

	// no validation rules for ProductName

	// no validation rules for ProductSkuId

	// no validation rules for ProductType

	// no validation rules for ProductPrice

	// no validation rules for DayBegin

	// no validation rules for DayEnd

	// no validation rules for TimeShare

	// no validation rules for ScenicId

	// no validation rules for ScenicName

	// no validation rules for BatchId

	// no validation rules for DistributeTicketStockId

	// no validation rules for TimeShareId

	if len(errors) > 0 {
		return OrderRefundProductDistributeMultiError(errors)
	}

	return nil
}

// OrderRefundProductDistributeMultiError is an error wrapping multiple
// validation errors returned by OrderRefundProductDistribute.ValidateAll() if
// the designated constraints aren't met.
type OrderRefundProductDistributeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderRefundProductDistributeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderRefundProductDistributeMultiError) AllErrors() []error { return m }

// OrderRefundProductDistributeValidationError is the validation error returned
// by OrderRefundProductDistribute.Validate if the designated constraints
// aren't met.
type OrderRefundProductDistributeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderRefundProductDistributeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderRefundProductDistributeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderRefundProductDistributeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderRefundProductDistributeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderRefundProductDistributeValidationError) ErrorName() string {
	return "OrderRefundProductDistributeValidationError"
}

// Error satisfies the builtin error interface
func (e OrderRefundProductDistributeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderRefundProductDistribute.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderRefundProductDistributeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderRefundProductDistributeValidationError{}

// Validate checks the field values on DistributeRefundCreateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DistributeRefundCreateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DistributeRefundCreateResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DistributeRefundCreateResponseMultiError, or nil if none found.
func (m *DistributeRefundCreateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DistributeRefundCreateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DistributeRefundCreateResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DistributeRefundCreateResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DistributeRefundCreateResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DistributeRefundCreateResponseMultiError(errors)
	}

	return nil
}

// DistributeRefundCreateResponseMultiError is an error wrapping multiple
// validation errors returned by DistributeRefundCreateResponse.ValidateAll()
// if the designated constraints aren't met.
type DistributeRefundCreateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DistributeRefundCreateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DistributeRefundCreateResponseMultiError) AllErrors() []error { return m }

// DistributeRefundCreateResponseValidationError is the validation error
// returned by DistributeRefundCreateResponse.Validate if the designated
// constraints aren't met.
type DistributeRefundCreateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DistributeRefundCreateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DistributeRefundCreateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DistributeRefundCreateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DistributeRefundCreateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DistributeRefundCreateResponseValidationError) ErrorName() string {
	return "DistributeRefundCreateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DistributeRefundCreateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDistributeRefundCreateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DistributeRefundCreateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DistributeRefundCreateResponseValidationError{}

// Validate checks the field values on QueryTicketOptRecordsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryTicketOptRecordsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryTicketOptRecordsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryTicketOptRecordsRequestMultiError, or nil if none found.
func (m *QueryTicketOptRecordsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryTicketOptRecordsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TicketId

	if len(errors) > 0 {
		return QueryTicketOptRecordsRequestMultiError(errors)
	}

	return nil
}

// QueryTicketOptRecordsRequestMultiError is an error wrapping multiple
// validation errors returned by QueryTicketOptRecordsRequest.ValidateAll() if
// the designated constraints aren't met.
type QueryTicketOptRecordsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryTicketOptRecordsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryTicketOptRecordsRequestMultiError) AllErrors() []error { return m }

// QueryTicketOptRecordsRequestValidationError is the validation error returned
// by QueryTicketOptRecordsRequest.Validate if the designated constraints
// aren't met.
type QueryTicketOptRecordsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryTicketOptRecordsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryTicketOptRecordsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryTicketOptRecordsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryTicketOptRecordsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryTicketOptRecordsRequestValidationError) ErrorName() string {
	return "QueryTicketOptRecordsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryTicketOptRecordsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryTicketOptRecordsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryTicketOptRecordsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryTicketOptRecordsRequestValidationError{}

// Validate checks the field values on QueryTicketOptRecordsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryTicketOptRecordsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryTicketOptRecordsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// QueryTicketOptRecordsResponseMultiError, or nil if none found.
func (m *QueryTicketOptRecordsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryTicketOptRecordsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTicketOperatingRecord() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryTicketOptRecordsResponseValidationError{
						field:  fmt.Sprintf("TicketOperatingRecord[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryTicketOptRecordsResponseValidationError{
						field:  fmt.Sprintf("TicketOperatingRecord[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryTicketOptRecordsResponseValidationError{
					field:  fmt.Sprintf("TicketOperatingRecord[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return QueryTicketOptRecordsResponseMultiError(errors)
	}

	return nil
}

// QueryTicketOptRecordsResponseMultiError is an error wrapping multiple
// validation errors returned by QueryTicketOptRecordsResponse.ValidateAll()
// if the designated constraints aren't met.
type QueryTicketOptRecordsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryTicketOptRecordsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryTicketOptRecordsResponseMultiError) AllErrors() []error { return m }

// QueryTicketOptRecordsResponseValidationError is the validation error
// returned by QueryTicketOptRecordsResponse.Validate if the designated
// constraints aren't met.
type QueryTicketOptRecordsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryTicketOptRecordsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryTicketOptRecordsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryTicketOptRecordsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryTicketOptRecordsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryTicketOptRecordsResponseValidationError) ErrorName() string {
	return "QueryTicketOptRecordsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryTicketOptRecordsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryTicketOptRecordsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryTicketOptRecordsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryTicketOptRecordsResponseValidationError{}

// Validate checks the field values on TicketOperatingRecord with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TicketOperatingRecord) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TicketOperatingRecord with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TicketOperatingRecordMultiError, or nil if none found.
func (m *TicketOperatingRecord) ValidateAll() error {
	return m.validate(true)
}

func (m *TicketOperatingRecord) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OptType

	// no validation rules for Miner

	// no validation rules for SenderId

	// no validation rules for ReceiverId

	// no validation rules for BatchId

	// no validation rules for TicketsStatus

	// no validation rules for OrderNumber

	// no validation rules for RefundNumber

	// no validation rules for TxHash

	// no validation rules for TriggerAt

	if len(errors) > 0 {
		return TicketOperatingRecordMultiError(errors)
	}

	return nil
}

// TicketOperatingRecordMultiError is an error wrapping multiple validation
// errors returned by TicketOperatingRecord.ValidateAll() if the designated
// constraints aren't met.
type TicketOperatingRecordMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TicketOperatingRecordMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TicketOperatingRecordMultiError) AllErrors() []error { return m }

// TicketOperatingRecordValidationError is the validation error returned by
// TicketOperatingRecord.Validate if the designated constraints aren't met.
type TicketOperatingRecordValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TicketOperatingRecordValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TicketOperatingRecordValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TicketOperatingRecordValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TicketOperatingRecordValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TicketOperatingRecordValidationError) ErrorName() string {
	return "TicketOperatingRecordValidationError"
}

// Error satisfies the builtin error interface
func (e TicketOperatingRecordValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTicketOperatingRecord.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TicketOperatingRecordValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TicketOperatingRecordValidationError{}

// Validate checks the field values on RepayRollBackRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RepayRollBackRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepayRollBackRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RepayRollBackRequestMultiError, or nil if none found.
func (m *RepayRollBackRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RepayRollBackRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RepayRollBackRequestValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RepayRollBackRequestValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RepayRollBackRequestValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RepayRollBackRequestMultiError(errors)
	}

	return nil
}

// RepayRollBackRequestMultiError is an error wrapping multiple validation
// errors returned by RepayRollBackRequest.ValidateAll() if the designated
// constraints aren't met.
type RepayRollBackRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepayRollBackRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepayRollBackRequestMultiError) AllErrors() []error { return m }

// RepayRollBackRequestValidationError is the validation error returned by
// RepayRollBackRequest.Validate if the designated constraints aren't met.
type RepayRollBackRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepayRollBackRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepayRollBackRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepayRollBackRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepayRollBackRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepayRollBackRequestValidationError) ErrorName() string {
	return "RepayRollBackRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RepayRollBackRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepayRollBackRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepayRollBackRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepayRollBackRequestValidationError{}

// Validate checks the field values on RepayRollBackResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RepayRollBackResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepayRollBackResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RepayRollBackResponseMultiError, or nil if none found.
func (m *RepayRollBackResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RepayRollBackResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RepayRollBackResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RepayRollBackResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RepayRollBackResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RepayRollBackResponseMultiError(errors)
	}

	return nil
}

// RepayRollBackResponseMultiError is an error wrapping multiple validation
// errors returned by RepayRollBackResponse.ValidateAll() if the designated
// constraints aren't met.
type RepayRollBackResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepayRollBackResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepayRollBackResponseMultiError) AllErrors() []error { return m }

// RepayRollBackResponseValidationError is the validation error returned by
// RepayRollBackResponse.Validate if the designated constraints aren't met.
type RepayRollBackResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepayRollBackResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepayRollBackResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepayRollBackResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepayRollBackResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepayRollBackResponseValidationError) ErrorName() string {
	return "RepayRollBackResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RepayRollBackResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepayRollBackResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepayRollBackResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepayRollBackResponseValidationError{}

// Validate checks the field values on StockBatchInfoUpdateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StockBatchInfoUpdateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StockBatchInfoUpdateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StockBatchInfoUpdateRequestMultiError, or nil if none found.
func (m *StockBatchInfoUpdateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StockBatchInfoUpdateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetStockBatchNumber()) < 0 {
		err := StockBatchInfoUpdateRequestValidationError{
			field:  "StockBatchNumber",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAccount()) != 42 {
		err := StockBatchInfoUpdateRequestValidationError{
			field:  "Account",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetOrg()) < 0 {
		err := StockBatchInfoUpdateRequestValidationError{
			field:  "Org",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PurchaseBeginTime

	// no validation rules for PurchaseEndTime

	// no validation rules for EnterBeginTime

	// no validation rules for EnterEndTime

	if len(errors) > 0 {
		return StockBatchInfoUpdateRequestMultiError(errors)
	}

	return nil
}

// StockBatchInfoUpdateRequestMultiError is an error wrapping multiple
// validation errors returned by StockBatchInfoUpdateRequest.ValidateAll() if
// the designated constraints aren't met.
type StockBatchInfoUpdateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StockBatchInfoUpdateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StockBatchInfoUpdateRequestMultiError) AllErrors() []error { return m }

// StockBatchInfoUpdateRequestValidationError is the validation error returned
// by StockBatchInfoUpdateRequest.Validate if the designated constraints
// aren't met.
type StockBatchInfoUpdateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StockBatchInfoUpdateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StockBatchInfoUpdateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StockBatchInfoUpdateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StockBatchInfoUpdateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StockBatchInfoUpdateRequestValidationError) ErrorName() string {
	return "StockBatchInfoUpdateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StockBatchInfoUpdateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStockBatchInfoUpdateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StockBatchInfoUpdateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StockBatchInfoUpdateRequestValidationError{}

// Validate checks the field values on StockBatchInfoUpdateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StockBatchInfoUpdateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StockBatchInfoUpdateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StockBatchInfoUpdateResponseMultiError, or nil if none found.
func (m *StockBatchInfoUpdateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StockBatchInfoUpdateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StockBatchInfoUpdateResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StockBatchInfoUpdateResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StockBatchInfoUpdateResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StockBatchInfoUpdateResponseMultiError(errors)
	}

	return nil
}

// StockBatchInfoUpdateResponseMultiError is an error wrapping multiple
// validation errors returned by StockBatchInfoUpdateResponse.ValidateAll() if
// the designated constraints aren't met.
type StockBatchInfoUpdateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StockBatchInfoUpdateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StockBatchInfoUpdateResponseMultiError) AllErrors() []error { return m }

// StockBatchInfoUpdateResponseValidationError is the validation error returned
// by StockBatchInfoUpdateResponse.Validate if the designated constraints
// aren't met.
type StockBatchInfoUpdateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StockBatchInfoUpdateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StockBatchInfoUpdateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StockBatchInfoUpdateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StockBatchInfoUpdateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StockBatchInfoUpdateResponseValidationError) ErrorName() string {
	return "StockBatchInfoUpdateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StockBatchInfoUpdateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStockBatchInfoUpdateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StockBatchInfoUpdateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StockBatchInfoUpdateResponseValidationError{}

// Validate checks the field values on QueryStockOptRecordsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryStockOptRecordsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryStockOptRecordsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryStockOptRecordsRequestMultiError, or nil if none found.
func (m *QueryStockOptRecordsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryStockOptRecordsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetStockBatchNumber()) < 0 {
		err := QueryStockOptRecordsRequestValidationError{
			field:  "StockBatchNumber",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAccount()) != 42 {
		err := QueryStockOptRecordsRequestValidationError{
			field:  "Account",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetOrg()) < 0 {
		err := QueryStockOptRecordsRequestValidationError{
			field:  "Org",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return QueryStockOptRecordsRequestMultiError(errors)
	}

	return nil
}

// QueryStockOptRecordsRequestMultiError is an error wrapping multiple
// validation errors returned by QueryStockOptRecordsRequest.ValidateAll() if
// the designated constraints aren't met.
type QueryStockOptRecordsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryStockOptRecordsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryStockOptRecordsRequestMultiError) AllErrors() []error { return m }

// QueryStockOptRecordsRequestValidationError is the validation error returned
// by QueryStockOptRecordsRequest.Validate if the designated constraints
// aren't met.
type QueryStockOptRecordsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryStockOptRecordsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryStockOptRecordsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryStockOptRecordsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryStockOptRecordsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryStockOptRecordsRequestValidationError) ErrorName() string {
	return "QueryStockOptRecordsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryStockOptRecordsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryStockOptRecordsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryStockOptRecordsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryStockOptRecordsRequestValidationError{}

// Validate checks the field values on QueryStockOptRecordsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryStockOptRecordsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryStockOptRecordsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryStockOptRecordsResponseMultiError, or nil if none found.
func (m *QueryStockOptRecordsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryStockOptRecordsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	for idx, item := range m.GetStockOperatingRecord() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryStockOptRecordsResponseValidationError{
						field:  fmt.Sprintf("StockOperatingRecord[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryStockOptRecordsResponseValidationError{
						field:  fmt.Sprintf("StockOperatingRecord[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryStockOptRecordsResponseValidationError{
					field:  fmt.Sprintf("StockOperatingRecord[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return QueryStockOptRecordsResponseMultiError(errors)
	}

	return nil
}

// QueryStockOptRecordsResponseMultiError is an error wrapping multiple
// validation errors returned by QueryStockOptRecordsResponse.ValidateAll() if
// the designated constraints aren't met.
type QueryStockOptRecordsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryStockOptRecordsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryStockOptRecordsResponseMultiError) AllErrors() []error { return m }

// QueryStockOptRecordsResponseValidationError is the validation error returned
// by QueryStockOptRecordsResponse.Validate if the designated constraints
// aren't met.
type QueryStockOptRecordsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryStockOptRecordsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryStockOptRecordsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryStockOptRecordsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryStockOptRecordsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryStockOptRecordsResponseValidationError) ErrorName() string {
	return "QueryStockOptRecordsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryStockOptRecordsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryStockOptRecordsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryStockOptRecordsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryStockOptRecordsResponseValidationError{}

// Validate checks the field values on StockOperatingRecord with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StockOperatingRecord) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StockOperatingRecord with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StockOperatingRecordMultiError, or nil if none found.
func (m *StockOperatingRecord) ValidateAll() error {
	return m.validate(true)
}

func (m *StockOperatingRecord) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OptType

	// no validation rules for TxHash

	// no validation rules for TriggerAt

	if len(errors) > 0 {
		return StockOperatingRecordMultiError(errors)
	}

	return nil
}

// StockOperatingRecordMultiError is an error wrapping multiple validation
// errors returned by StockOperatingRecord.ValidateAll() if the designated
// constraints aren't met.
type StockOperatingRecordMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StockOperatingRecordMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StockOperatingRecordMultiError) AllErrors() []error { return m }

// StockOperatingRecordValidationError is the validation error returned by
// StockOperatingRecord.Validate if the designated constraints aren't met.
type StockOperatingRecordValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StockOperatingRecordValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StockOperatingRecordValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StockOperatingRecordValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StockOperatingRecordValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StockOperatingRecordValidationError) ErrorName() string {
	return "StockOperatingRecordValidationError"
}

// Error satisfies the builtin error interface
func (e StockOperatingRecordValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStockOperatingRecord.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StockOperatingRecordValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StockOperatingRecordValidationError{}

// Validate checks the field values on ProjectBiddingResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProjectBiddingResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProjectBiddingResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProjectBiddingResponseMultiError, or nil if none found.
func (m *ProjectBiddingResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ProjectBiddingResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProjectBiddingResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProjectBiddingResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProjectBiddingResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProjectBiddingResponseMultiError(errors)
	}

	return nil
}

// ProjectBiddingResponseMultiError is an error wrapping multiple validation
// errors returned by ProjectBiddingResponse.ValidateAll() if the designated
// constraints aren't met.
type ProjectBiddingResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectBiddingResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectBiddingResponseMultiError) AllErrors() []error { return m }

// ProjectBiddingResponseValidationError is the validation error returned by
// ProjectBiddingResponse.Validate if the designated constraints aren't met.
type ProjectBiddingResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectBiddingResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectBiddingResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectBiddingResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectBiddingResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectBiddingResponseValidationError) ErrorName() string {
	return "ProjectBiddingResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ProjectBiddingResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProjectBiddingResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectBiddingResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectBiddingResponseValidationError{}

// Validate checks the field values on ProjectBiddingData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProjectBiddingData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProjectBiddingData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProjectBiddingDataMultiError, or nil if none found.
func (m *ProjectBiddingData) ValidateAll() error {
	return m.validate(true)
}

func (m *ProjectBiddingData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProjectBiddingHash()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProjectBiddingDataValidationError{
					field:  "ProjectBiddingHash",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProjectBiddingDataValidationError{
					field:  "ProjectBiddingHash",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProjectBiddingHash()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProjectBiddingDataValidationError{
				field:  "ProjectBiddingHash",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProjectBiddingDataMultiError(errors)
	}

	return nil
}

// ProjectBiddingDataMultiError is an error wrapping multiple validation errors
// returned by ProjectBiddingData.ValidateAll() if the designated constraints
// aren't met.
type ProjectBiddingDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectBiddingDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectBiddingDataMultiError) AllErrors() []error { return m }

// ProjectBiddingDataValidationError is the validation error returned by
// ProjectBiddingData.Validate if the designated constraints aren't met.
type ProjectBiddingDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectBiddingDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectBiddingDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectBiddingDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectBiddingDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectBiddingDataValidationError) ErrorName() string {
	return "ProjectBiddingDataValidationError"
}

// Error satisfies the builtin error interface
func (e ProjectBiddingDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProjectBiddingData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectBiddingDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectBiddingDataValidationError{}

// Validate checks the field values on ProjectBiddingHash with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProjectBiddingHash) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProjectBiddingHash with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProjectBiddingHashMultiError, or nil if none found.
func (m *ProjectBiddingHash) ValidateAll() error {
	return m.validate(true)
}

func (m *ProjectBiddingHash) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectId

	// no validation rules for TxHash

	if len(errors) > 0 {
		return ProjectBiddingHashMultiError(errors)
	}

	return nil
}

// ProjectBiddingHashMultiError is an error wrapping multiple validation errors
// returned by ProjectBiddingHash.ValidateAll() if the designated constraints
// aren't met.
type ProjectBiddingHashMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectBiddingHashMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectBiddingHashMultiError) AllErrors() []error { return m }

// ProjectBiddingHashValidationError is the validation error returned by
// ProjectBiddingHash.Validate if the designated constraints aren't met.
type ProjectBiddingHashValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectBiddingHashValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectBiddingHashValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectBiddingHashValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectBiddingHashValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectBiddingHashValidationError) ErrorName() string {
	return "ProjectBiddingHashValidationError"
}

// Error satisfies the builtin error interface
func (e ProjectBiddingHashValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProjectBiddingHash.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectBiddingHashValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectBiddingHashValidationError{}

// Validate checks the field values on InstrumentTicketResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstrumentTicketResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstrumentTicketResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstrumentTicketResponseMultiError, or nil if none found.
func (m *InstrumentTicketResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *InstrumentTicketResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentTicketResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentTicketResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentTicketResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InstrumentTicketResponseMultiError(errors)
	}

	return nil
}

// InstrumentTicketResponseMultiError is an error wrapping multiple validation
// errors returned by InstrumentTicketResponse.ValidateAll() if the designated
// constraints aren't met.
type InstrumentTicketResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstrumentTicketResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstrumentTicketResponseMultiError) AllErrors() []error { return m }

// InstrumentTicketResponseValidationError is the validation error returned by
// InstrumentTicketResponse.Validate if the designated constraints aren't met.
type InstrumentTicketResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstrumentTicketResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstrumentTicketResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstrumentTicketResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstrumentTicketResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstrumentTicketResponseValidationError) ErrorName() string {
	return "InstrumentTicketResponseValidationError"
}

// Error satisfies the builtin error interface
func (e InstrumentTicketResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstrumentTicketResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstrumentTicketResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstrumentTicketResponseValidationError{}

// Validate checks the field values on InstrumentTicketData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstrumentTicketData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstrumentTicketData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstrumentTicketDataMultiError, or nil if none found.
func (m *InstrumentTicketData) ValidateAll() error {
	return m.validate(true)
}

func (m *InstrumentTicketData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInstrumentTicketHash()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentTicketDataValidationError{
					field:  "InstrumentTicketHash",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentTicketDataValidationError{
					field:  "InstrumentTicketHash",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstrumentTicketHash()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentTicketDataValidationError{
				field:  "InstrumentTicketHash",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InstrumentTicketDataMultiError(errors)
	}

	return nil
}

// InstrumentTicketDataMultiError is an error wrapping multiple validation
// errors returned by InstrumentTicketData.ValidateAll() if the designated
// constraints aren't met.
type InstrumentTicketDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstrumentTicketDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstrumentTicketDataMultiError) AllErrors() []error { return m }

// InstrumentTicketDataValidationError is the validation error returned by
// InstrumentTicketData.Validate if the designated constraints aren't met.
type InstrumentTicketDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstrumentTicketDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstrumentTicketDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstrumentTicketDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstrumentTicketDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstrumentTicketDataValidationError) ErrorName() string {
	return "InstrumentTicketDataValidationError"
}

// Error satisfies the builtin error interface
func (e InstrumentTicketDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstrumentTicketData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstrumentTicketDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstrumentTicketDataValidationError{}

// Validate checks the field values on InstrumentTicketHash with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstrumentTicketHash) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstrumentTicketHash with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstrumentTicketHashMultiError, or nil if none found.
func (m *InstrumentTicketHash) ValidateAll() error {
	return m.validate(true)
}

func (m *InstrumentTicketHash) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstrumentId

	// no validation rules for TxHash

	// no validation rules for BlockHeight

	// no validation rules for OnChainTime

	// no validation rules for ChainName

	if len(errors) > 0 {
		return InstrumentTicketHashMultiError(errors)
	}

	return nil
}

// InstrumentTicketHashMultiError is an error wrapping multiple validation
// errors returned by InstrumentTicketHash.ValidateAll() if the designated
// constraints aren't met.
type InstrumentTicketHashMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstrumentTicketHashMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstrumentTicketHashMultiError) AllErrors() []error { return m }

// InstrumentTicketHashValidationError is the validation error returned by
// InstrumentTicketHash.Validate if the designated constraints aren't met.
type InstrumentTicketHashValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstrumentTicketHashValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstrumentTicketHashValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstrumentTicketHashValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstrumentTicketHashValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstrumentTicketHashValidationError) ErrorName() string {
	return "InstrumentTicketHashValidationError"
}

// Error satisfies the builtin error interface
func (e InstrumentTicketHashValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstrumentTicketHash.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstrumentTicketHashValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstrumentTicketHashValidationError{}

// Validate checks the field values on InstrumentBiddingRule with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstrumentBiddingRule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstrumentBiddingRule with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstrumentBiddingRuleMultiError, or nil if none found.
func (m *InstrumentBiddingRule) ValidateAll() error {
	return m.validate(true)
}

func (m *InstrumentBiddingRule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstrumentId

	// no validation rules for InstrumentGrade

	// no validation rules for BiddingStartTime

	// no validation rules for BiddingEndTime

	// no validation rules for BiddingDelayTime

	// no validation rules for BiddingType

	// no validation rules for BiddingStartPrice

	// no validation rules for BiddingDealRule

	// no validation rules for BiddingDeposit

	// no validation rules for BiddingChanges

	// no validation rules for InstrumentQuantity

	// no validation rules for BiddingDescription

	// no validation rules for MarketPrice

	// no validation rules for BiddingDepositRatio

	// no validation rules for LowestPrice

	if len(errors) > 0 {
		return InstrumentBiddingRuleMultiError(errors)
	}

	return nil
}

// InstrumentBiddingRuleMultiError is an error wrapping multiple validation
// errors returned by InstrumentBiddingRule.ValidateAll() if the designated
// constraints aren't met.
type InstrumentBiddingRuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstrumentBiddingRuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstrumentBiddingRuleMultiError) AllErrors() []error { return m }

// InstrumentBiddingRuleValidationError is the validation error returned by
// InstrumentBiddingRule.Validate if the designated constraints aren't met.
type InstrumentBiddingRuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstrumentBiddingRuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstrumentBiddingRuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstrumentBiddingRuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstrumentBiddingRuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstrumentBiddingRuleValidationError) ErrorName() string {
	return "InstrumentBiddingRuleValidationError"
}

// Error satisfies the builtin error interface
func (e InstrumentBiddingRuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstrumentBiddingRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstrumentBiddingRuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstrumentBiddingRuleValidationError{}

// Validate checks the field values on InstrumentBiddingSales with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstrumentBiddingSales) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstrumentBiddingSales with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstrumentBiddingSalesMultiError, or nil if none found.
func (m *InstrumentBiddingSales) ValidateAll() error {
	return m.validate(true)
}

func (m *InstrumentBiddingSales) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstrumentId

	// no validation rules for InstrumentViews

	// no validation rules for RegistrationQuantity

	// no validation rules for BidQuantity

	// no validation rules for CurrentPrice

	// no validation rules for CurrentRemainingQuantity

	// no validation rules for EstimatedStartTime

	// no validation rules for EstimatedEndTime

	if len(errors) > 0 {
		return InstrumentBiddingSalesMultiError(errors)
	}

	return nil
}

// InstrumentBiddingSalesMultiError is an error wrapping multiple validation
// errors returned by InstrumentBiddingSales.ValidateAll() if the designated
// constraints aren't met.
type InstrumentBiddingSalesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstrumentBiddingSalesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstrumentBiddingSalesMultiError) AllErrors() []error { return m }

// InstrumentBiddingSalesValidationError is the validation error returned by
// InstrumentBiddingSales.Validate if the designated constraints aren't met.
type InstrumentBiddingSalesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstrumentBiddingSalesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstrumentBiddingSalesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstrumentBiddingSalesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstrumentBiddingSalesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstrumentBiddingSalesValidationError) ErrorName() string {
	return "InstrumentBiddingSalesValidationError"
}

// Error satisfies the builtin error interface
func (e InstrumentBiddingSalesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstrumentBiddingSales.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstrumentBiddingSalesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstrumentBiddingSalesValidationError{}

// Validate checks the field values on Instrument with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Instrument) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Instrument with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InstrumentMultiError, or
// nil if none found.
func (m *Instrument) ValidateAll() error {
	return m.validate(true)
}

func (m *Instrument) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstrumentId

	// no validation rules for ProjectId

	// no validation rules for ParentInstrumentId

	// no validation rules for CompanyId

	// no validation rules for AssetType

	// no validation rules for InstrumentType

	// no validation rules for InstrumentName

	// no validation rules for InstrumentImages

	// no validation rules for InstrumentVideo

	// no validation rules for InstrumentDescription

	// no validation rules for InstrumentAnnex

	// no validation rules for ContactName

	// no validation rules for ContactPhone

	// no validation rules for InstrumentStatus

	if all {
		switch v := interface{}(m.GetInstrumentBiddingRule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "InstrumentBiddingRule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "InstrumentBiddingRule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstrumentBiddingRule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentValidationError{
				field:  "InstrumentBiddingRule",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInstrumentBiddingSales()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "InstrumentBiddingSales",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "InstrumentBiddingSales",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstrumentBiddingSales()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentValidationError{
				field:  "InstrumentBiddingSales",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InstrumentMultiError(errors)
	}

	return nil
}

// InstrumentMultiError is an error wrapping multiple validation errors
// returned by Instrument.ValidateAll() if the designated constraints aren't met.
type InstrumentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstrumentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstrumentMultiError) AllErrors() []error { return m }

// InstrumentValidationError is the validation error returned by
// Instrument.Validate if the designated constraints aren't met.
type InstrumentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstrumentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstrumentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstrumentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstrumentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstrumentValidationError) ErrorName() string { return "InstrumentValidationError" }

// Error satisfies the builtin error interface
func (e InstrumentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstrument.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstrumentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstrumentValidationError{}

// Validate checks the field values on InstrumentTicketRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstrumentTicketRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstrumentTicketRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstrumentTicketRequestMultiError, or nil if none found.
func (m *InstrumentTicketRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InstrumentTicketRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstrumentId

	// no validation rules for ScenicId

	// no validation rules for GoodsId

	// no validation rules for ProductType

	// no validation rules for TicketType

	// no validation rules for ScenicProvinceCode

	// no validation rules for ScenicCityCode

	// no validation rules for ScenicAreaCode

	// no validation rules for BuyStartDate

	// no validation rules for BuyEndDate

	// no validation rules for UseStartDate

	// no validation rules for UseEndDate

	if all {
		switch v := interface{}(m.GetInstrument()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentTicketRequestValidationError{
					field:  "Instrument",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentTicketRequestValidationError{
					field:  "Instrument",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstrument()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentTicketRequestValidationError{
				field:  "Instrument",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ProjectChainUniqueId

	if len(errors) > 0 {
		return InstrumentTicketRequestMultiError(errors)
	}

	return nil
}

// InstrumentTicketRequestMultiError is an error wrapping multiple validation
// errors returned by InstrumentTicketRequest.ValidateAll() if the designated
// constraints aren't met.
type InstrumentTicketRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstrumentTicketRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstrumentTicketRequestMultiError) AllErrors() []error { return m }

// InstrumentTicketRequestValidationError is the validation error returned by
// InstrumentTicketRequest.Validate if the designated constraints aren't met.
type InstrumentTicketRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstrumentTicketRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstrumentTicketRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstrumentTicketRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstrumentTicketRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstrumentTicketRequestValidationError) ErrorName() string {
	return "InstrumentTicketRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InstrumentTicketRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstrumentTicketRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstrumentTicketRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstrumentTicketRequestValidationError{}

// Validate checks the field values on ProjectBiddingRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProjectBiddingRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProjectBiddingRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProjectBiddingRequestMultiError, or nil if none found.
func (m *ProjectBiddingRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProjectBiddingRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectId

	// no validation rules for ParentProjectId

	// no validation rules for ProjectType

	// no validation rules for ProjectNumber

	// no validation rules for ExchangeId

	// no validation rules for CompanyId

	// no validation rules for ProjectName

	// no validation rules for ProjectGrade

	// no validation rules for ProjectDescription

	// no validation rules for ProjectAnnex

	// no validation rules for ProjectStatus

	// no validation rules for NodeDescription

	// no validation rules for ProjectChainUniqueId

	// no validation rules for ReviewTime

	if len(errors) > 0 {
		return ProjectBiddingRequestMultiError(errors)
	}

	return nil
}

// ProjectBiddingRequestMultiError is an error wrapping multiple validation
// errors returned by ProjectBiddingRequest.ValidateAll() if the designated
// constraints aren't met.
type ProjectBiddingRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectBiddingRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectBiddingRequestMultiError) AllErrors() []error { return m }

// ProjectBiddingRequestValidationError is the validation error returned by
// ProjectBiddingRequest.Validate if the designated constraints aren't met.
type ProjectBiddingRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectBiddingRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectBiddingRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectBiddingRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectBiddingRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectBiddingRequestValidationError) ErrorName() string {
	return "ProjectBiddingRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProjectBiddingRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProjectBiddingRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectBiddingRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectBiddingRequestValidationError{}

// Validate checks the field values on QueryAnnouncementOptRecordsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *QueryAnnouncementOptRecordsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryAnnouncementOptRecordsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// QueryAnnouncementOptRecordsRequestMultiError, or nil if none found.
func (m *QueryAnnouncementOptRecordsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryAnnouncementOptRecordsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectId

	if len(errors) > 0 {
		return QueryAnnouncementOptRecordsRequestMultiError(errors)
	}

	return nil
}

// QueryAnnouncementOptRecordsRequestMultiError is an error wrapping multiple
// validation errors returned by
// QueryAnnouncementOptRecordsRequest.ValidateAll() if the designated
// constraints aren't met.
type QueryAnnouncementOptRecordsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryAnnouncementOptRecordsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryAnnouncementOptRecordsRequestMultiError) AllErrors() []error { return m }

// QueryAnnouncementOptRecordsRequestValidationError is the validation error
// returned by QueryAnnouncementOptRecordsRequest.Validate if the designated
// constraints aren't met.
type QueryAnnouncementOptRecordsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryAnnouncementOptRecordsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryAnnouncementOptRecordsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryAnnouncementOptRecordsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryAnnouncementOptRecordsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryAnnouncementOptRecordsRequestValidationError) ErrorName() string {
	return "QueryAnnouncementOptRecordsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryAnnouncementOptRecordsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryAnnouncementOptRecordsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryAnnouncementOptRecordsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryAnnouncementOptRecordsRequestValidationError{}

// Validate checks the field values on QueryAnnouncementOptRecordsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *QueryAnnouncementOptRecordsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryAnnouncementOptRecordsResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// QueryAnnouncementOptRecordsResponseMultiError, or nil if none found.
func (m *QueryAnnouncementOptRecordsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryAnnouncementOptRecordsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryAnnouncementOptRecordsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryAnnouncementOptRecordsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryAnnouncementOptRecordsResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return QueryAnnouncementOptRecordsResponseMultiError(errors)
	}

	return nil
}

// QueryAnnouncementOptRecordsResponseMultiError is an error wrapping multiple
// validation errors returned by
// QueryAnnouncementOptRecordsResponse.ValidateAll() if the designated
// constraints aren't met.
type QueryAnnouncementOptRecordsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryAnnouncementOptRecordsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryAnnouncementOptRecordsResponseMultiError) AllErrors() []error { return m }

// QueryAnnouncementOptRecordsResponseValidationError is the validation error
// returned by QueryAnnouncementOptRecordsResponse.Validate if the designated
// constraints aren't met.
type QueryAnnouncementOptRecordsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryAnnouncementOptRecordsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryAnnouncementOptRecordsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryAnnouncementOptRecordsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryAnnouncementOptRecordsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryAnnouncementOptRecordsResponseValidationError) ErrorName() string {
	return "QueryAnnouncementOptRecordsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryAnnouncementOptRecordsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryAnnouncementOptRecordsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryAnnouncementOptRecordsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryAnnouncementOptRecordsResponseValidationError{}

// Validate checks the field values on AnnouncementOptData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AnnouncementOptData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AnnouncementOptData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AnnouncementOptDataMultiError, or nil if none found.
func (m *AnnouncementOptData) ValidateAll() error {
	return m.validate(true)
}

func (m *AnnouncementOptData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectId

	// no validation rules for ProjectName

	// no validation rules for ProjectStatus

	// no validation rules for ReviewTime

	// no validation rules for TxHash

	// no validation rules for NodeDescription

	for idx, item := range m.GetInstruments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AnnouncementOptDataValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AnnouncementOptDataValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AnnouncementOptDataValidationError{
					field:  fmt.Sprintf("Instruments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AnnouncementOptDataMultiError(errors)
	}

	return nil
}

// AnnouncementOptDataMultiError is an error wrapping multiple validation
// errors returned by AnnouncementOptData.ValidateAll() if the designated
// constraints aren't met.
type AnnouncementOptDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnnouncementOptDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnnouncementOptDataMultiError) AllErrors() []error { return m }

// AnnouncementOptDataValidationError is the validation error returned by
// AnnouncementOptData.Validate if the designated constraints aren't met.
type AnnouncementOptDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnnouncementOptDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnnouncementOptDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnnouncementOptDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnnouncementOptDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnnouncementOptDataValidationError) ErrorName() string {
	return "AnnouncementOptDataValidationError"
}

// Error satisfies the builtin error interface
func (e AnnouncementOptDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnnouncementOptData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnnouncementOptDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnnouncementOptDataValidationError{}

// Validate checks the field values on InstrumentInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InstrumentInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstrumentInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InstrumentInfoMultiError,
// or nil if none found.
func (m *InstrumentInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *InstrumentInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstrumentId

	// no validation rules for InstrumentName

	// no validation rules for TxHash

	if len(errors) > 0 {
		return InstrumentInfoMultiError(errors)
	}

	return nil
}

// InstrumentInfoMultiError is an error wrapping multiple validation errors
// returned by InstrumentInfo.ValidateAll() if the designated constraints
// aren't met.
type InstrumentInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstrumentInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstrumentInfoMultiError) AllErrors() []error { return m }

// InstrumentInfoValidationError is the validation error returned by
// InstrumentInfo.Validate if the designated constraints aren't met.
type InstrumentInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstrumentInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstrumentInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstrumentInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstrumentInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstrumentInfoValidationError) ErrorName() string { return "InstrumentInfoValidationError" }

// Error satisfies the builtin error interface
func (e InstrumentInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstrumentInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstrumentInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstrumentInfoValidationError{}

// Validate checks the field values on MarginOrderRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MarginOrderRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MarginOrderRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MarginOrderRequestMultiError, or nil if none found.
func (m *MarginOrderRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MarginOrderRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetExchangeId()) < 0 {
		err := MarginOrderRequestValidationError{
			field:  "ExchangeId",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetExchangeName()) < 0 {
		err := MarginOrderRequestValidationError{
			field:  "ExchangeName",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetInstrumentId()) < 0 {
		err := MarginOrderRequestValidationError{
			field:  "InstrumentId",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetInstrumentName()) < 0 {
		err := MarginOrderRequestValidationError{
			field:  "InstrumentName",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectId()) < 0 {
		err := MarginOrderRequestValidationError{
			field:  "ProjectId",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectName()) < 0 {
		err := MarginOrderRequestValidationError{
			field:  "ProjectName",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBidbondAmount()) < 0 {
		err := MarginOrderRequestValidationError{
			field:  "BidbondAmount",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetOutTradeNo()) < 0 {
		err := MarginOrderRequestValidationError{
			field:  "OutTradeNo",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTradeNo()) < 0 {
		err := MarginOrderRequestValidationError{
			field:  "TradeNo",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetSellerId()) < 0 {
		err := MarginOrderRequestValidationError{
			field:  "SellerId",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetSellerName()) < 0 {
		err := MarginOrderRequestValidationError{
			field:  "SellerName",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBuyerId()) < 0 {
		err := MarginOrderRequestValidationError{
			field:  "BuyerId",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBuyerName()) < 0 {
		err := MarginOrderRequestValidationError{
			field:  "BuyerName",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCreateTime()) < 0 {
		err := MarginOrderRequestValidationError{
			field:  "CreateTime",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetOrderId()) < 0 {
		err := MarginOrderRequestValidationError{
			field:  "OrderId",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MarginOrderRequestMultiError(errors)
	}

	return nil
}

// MarginOrderRequestMultiError is an error wrapping multiple validation errors
// returned by MarginOrderRequest.ValidateAll() if the designated constraints
// aren't met.
type MarginOrderRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MarginOrderRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MarginOrderRequestMultiError) AllErrors() []error { return m }

// MarginOrderRequestValidationError is the validation error returned by
// MarginOrderRequest.Validate if the designated constraints aren't met.
type MarginOrderRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MarginOrderRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MarginOrderRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MarginOrderRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MarginOrderRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MarginOrderRequestValidationError) ErrorName() string {
	return "MarginOrderRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MarginOrderRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMarginOrderRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MarginOrderRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MarginOrderRequestValidationError{}

// Validate checks the field values on MarginOrderResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MarginOrderResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MarginOrderResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MarginOrderResponseMultiError, or nil if none found.
func (m *MarginOrderResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MarginOrderResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MarginOrderResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MarginOrderResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MarginOrderResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MarginOrderResponseMultiError(errors)
	}

	return nil
}

// MarginOrderResponseMultiError is an error wrapping multiple validation
// errors returned by MarginOrderResponse.ValidateAll() if the designated
// constraints aren't met.
type MarginOrderResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MarginOrderResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MarginOrderResponseMultiError) AllErrors() []error { return m }

// MarginOrderResponseValidationError is the validation error returned by
// MarginOrderResponse.Validate if the designated constraints aren't met.
type MarginOrderResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MarginOrderResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MarginOrderResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MarginOrderResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MarginOrderResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MarginOrderResponseValidationError) ErrorName() string {
	return "MarginOrderResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MarginOrderResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMarginOrderResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MarginOrderResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MarginOrderResponseValidationError{}

// Validate checks the field values on MarginOrderOverRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MarginOrderOverRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MarginOrderOverRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MarginOrderOverRequestMultiError, or nil if none found.
func (m *MarginOrderOverRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MarginOrderOverRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetExchangeId()) < 0 {
		err := MarginOrderOverRequestValidationError{
			field:  "ExchangeId",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetExchangeName()) < 0 {
		err := MarginOrderOverRequestValidationError{
			field:  "ExchangeName",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetInstrumentId()) < 0 {
		err := MarginOrderOverRequestValidationError{
			field:  "InstrumentId",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetInstrumentName()) < 0 {
		err := MarginOrderOverRequestValidationError{
			field:  "InstrumentName",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectId()) < 0 {
		err := MarginOrderOverRequestValidationError{
			field:  "ProjectId",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectName()) < 0 {
		err := MarginOrderOverRequestValidationError{
			field:  "ProjectName",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBidbondAmount()) < 0 {
		err := MarginOrderOverRequestValidationError{
			field:  "BidbondAmount",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetOutTradeNo()) < 0 {
		err := MarginOrderOverRequestValidationError{
			field:  "OutTradeNo",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTradeNo()) < 0 {
		err := MarginOrderOverRequestValidationError{
			field:  "TradeNo",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetSellerId()) < 0 {
		err := MarginOrderOverRequestValidationError{
			field:  "SellerId",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetSellerName()) < 0 {
		err := MarginOrderOverRequestValidationError{
			field:  "SellerName",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBuyerId()) < 0 {
		err := MarginOrderOverRequestValidationError{
			field:  "BuyerId",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBuyerName()) < 0 {
		err := MarginOrderOverRequestValidationError{
			field:  "BuyerName",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBidNumber()) < 0 {
		err := MarginOrderOverRequestValidationError{
			field:  "BidNumber",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPaymentTradeNo()) < 0 {
		err := MarginOrderOverRequestValidationError{
			field:  "PaymentTradeNo",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPaymentTime()) < 0 {
		err := MarginOrderOverRequestValidationError{
			field:  "PaymentTime",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MarginOrderOverRequestMultiError(errors)
	}

	return nil
}

// MarginOrderOverRequestMultiError is an error wrapping multiple validation
// errors returned by MarginOrderOverRequest.ValidateAll() if the designated
// constraints aren't met.
type MarginOrderOverRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MarginOrderOverRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MarginOrderOverRequestMultiError) AllErrors() []error { return m }

// MarginOrderOverRequestValidationError is the validation error returned by
// MarginOrderOverRequest.Validate if the designated constraints aren't met.
type MarginOrderOverRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MarginOrderOverRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MarginOrderOverRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MarginOrderOverRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MarginOrderOverRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MarginOrderOverRequestValidationError) ErrorName() string {
	return "MarginOrderOverRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MarginOrderOverRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMarginOrderOverRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MarginOrderOverRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MarginOrderOverRequestValidationError{}

// Validate checks the field values on MarginOrderOverResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MarginOrderOverResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MarginOrderOverResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MarginOrderOverResponseMultiError, or nil if none found.
func (m *MarginOrderOverResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MarginOrderOverResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MarginOrderOverResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MarginOrderOverResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MarginOrderOverResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MarginOrderOverResponseMultiError(errors)
	}

	return nil
}

// MarginOrderOverResponseMultiError is an error wrapping multiple validation
// errors returned by MarginOrderOverResponse.ValidateAll() if the designated
// constraints aren't met.
type MarginOrderOverResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MarginOrderOverResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MarginOrderOverResponseMultiError) AllErrors() []error { return m }

// MarginOrderOverResponseValidationError is the validation error returned by
// MarginOrderOverResponse.Validate if the designated constraints aren't met.
type MarginOrderOverResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MarginOrderOverResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MarginOrderOverResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MarginOrderOverResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MarginOrderOverResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MarginOrderOverResponseValidationError) ErrorName() string {
	return "MarginOrderOverResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MarginOrderOverResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMarginOrderOverResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MarginOrderOverResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MarginOrderOverResponseValidationError{}

// Validate checks the field values on ExchangeTxData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExchangeTxData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExchangeTxData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExchangeTxDataMultiError,
// or nil if none found.
func (m *ExchangeTxData) ValidateAll() error {
	return m.validate(true)
}

func (m *ExchangeTxData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TxId

	if len(errors) > 0 {
		return ExchangeTxDataMultiError(errors)
	}

	return nil
}

// ExchangeTxDataMultiError is an error wrapping multiple validation errors
// returned by ExchangeTxData.ValidateAll() if the designated constraints
// aren't met.
type ExchangeTxDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExchangeTxDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExchangeTxDataMultiError) AllErrors() []error { return m }

// ExchangeTxDataValidationError is the validation error returned by
// ExchangeTxData.Validate if the designated constraints aren't met.
type ExchangeTxDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExchangeTxDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExchangeTxDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExchangeTxDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExchangeTxDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExchangeTxDataValidationError) ErrorName() string { return "ExchangeTxDataValidationError" }

// Error satisfies the builtin error interface
func (e ExchangeTxDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExchangeTxData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExchangeTxDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExchangeTxDataValidationError{}

// Validate checks the field values on CreditAssessmentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreditAssessmentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreditAssessmentRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreditAssessmentRequestMultiError, or nil if none found.
func (m *CreditAssessmentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreditAssessmentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LegalName

	// no validation rules for RegistrationNumber

	// no validation rules for Score

	// no validation rules for Level

	// no validation rules for AssessmentTime

	if len(errors) > 0 {
		return CreditAssessmentRequestMultiError(errors)
	}

	return nil
}

// CreditAssessmentRequestMultiError is an error wrapping multiple validation
// errors returned by CreditAssessmentRequest.ValidateAll() if the designated
// constraints aren't met.
type CreditAssessmentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreditAssessmentRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreditAssessmentRequestMultiError) AllErrors() []error { return m }

// CreditAssessmentRequestValidationError is the validation error returned by
// CreditAssessmentRequest.Validate if the designated constraints aren't met.
type CreditAssessmentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreditAssessmentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreditAssessmentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreditAssessmentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreditAssessmentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreditAssessmentRequestValidationError) ErrorName() string {
	return "CreditAssessmentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreditAssessmentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreditAssessmentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreditAssessmentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreditAssessmentRequestValidationError{}

// Validate checks the field values on LoanRequestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoanRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoanRequestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoanRequestRequestMultiError, or nil if none found.
func (m *LoanRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LoanRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ApplicationNo

	// no validation rules for LegalName

	// no validation rules for DebtorRegistrationNumber

	// no validation rules for OwnersEquity

	// no validation rules for BusinessScope

	// no validation rules for BusinessEconomicType

	// no validation rules for BusinessPhone

	// no validation rules for BusinessFax

	// no validation rules for BusinessEmail

	// no validation rules for CreditorName

	// no validation rules for CreditorRegistrationNumber

	// no validation rules for FinancingPurpose

	// no validation rules for Level

	// no validation rules for ProposedCreditLimit

	// no validation rules for CreateTime

	if len(errors) > 0 {
		return LoanRequestRequestMultiError(errors)
	}

	return nil
}

// LoanRequestRequestMultiError is an error wrapping multiple validation errors
// returned by LoanRequestRequest.ValidateAll() if the designated constraints
// aren't met.
type LoanRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoanRequestRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoanRequestRequestMultiError) AllErrors() []error { return m }

// LoanRequestRequestValidationError is the validation error returned by
// LoanRequestRequest.Validate if the designated constraints aren't met.
type LoanRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoanRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoanRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoanRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoanRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoanRequestRequestValidationError) ErrorName() string {
	return "LoanRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e LoanRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoanRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoanRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoanRequestRequestValidationError{}

// Validate checks the field values on LoanReviewDeniedRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoanReviewDeniedRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoanReviewDeniedRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoanReviewDeniedRequestMultiError, or nil if none found.
func (m *LoanReviewDeniedRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LoanReviewDeniedRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ApplicationNo

	// no validation rules for LegalName

	// no validation rules for DebtorRegistrationNumber

	// no validation rules for OwnersEquity

	// no validation rules for BusinessScope

	// no validation rules for BusinessEconomicType

	// no validation rules for BusinessPhone

	// no validation rules for BusinessFax

	// no validation rules for BusinessEmail

	// no validation rules for CreditorName

	// no validation rules for CreditorRegistrationNumber

	// no validation rules for FinancingPurpose

	// no validation rules for Level

	// no validation rules for ProposedCreditLimit

	// no validation rules for CreateTime

	// no validation rules for CreditStatus

	// no validation rules for CreditAuditRemark

	// no validation rules for ModifyTime

	if len(errors) > 0 {
		return LoanReviewDeniedRequestMultiError(errors)
	}

	return nil
}

// LoanReviewDeniedRequestMultiError is an error wrapping multiple validation
// errors returned by LoanReviewDeniedRequest.ValidateAll() if the designated
// constraints aren't met.
type LoanReviewDeniedRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoanReviewDeniedRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoanReviewDeniedRequestMultiError) AllErrors() []error { return m }

// LoanReviewDeniedRequestValidationError is the validation error returned by
// LoanReviewDeniedRequest.Validate if the designated constraints aren't met.
type LoanReviewDeniedRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoanReviewDeniedRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoanReviewDeniedRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoanReviewDeniedRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoanReviewDeniedRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoanReviewDeniedRequestValidationError) ErrorName() string {
	return "LoanReviewDeniedRequestValidationError"
}

// Error satisfies the builtin error interface
func (e LoanReviewDeniedRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoanReviewDeniedRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoanReviewDeniedRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoanReviewDeniedRequestValidationError{}

// Validate checks the field values on LoanReviewApprovedRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoanReviewApprovedRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoanReviewApprovedRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoanReviewApprovedRequestMultiError, or nil if none found.
func (m *LoanReviewApprovedRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LoanReviewApprovedRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ApplicationNo

	// no validation rules for LegalName

	// no validation rules for DebtorRegistrationNumber

	// no validation rules for OwnersEquity

	// no validation rules for BusinessScope

	// no validation rules for BusinessEconomicType

	// no validation rules for BusinessPhone

	// no validation rules for BusinessFax

	// no validation rules for BusinessEmail

	// no validation rules for CreditorName

	// no validation rules for CreditorRegistrationNumber

	// no validation rules for FinancingPurpose

	// no validation rules for Level

	// no validation rules for ProposedCreditLimit

	// no validation rules for CreateTime

	// no validation rules for CreditStatus

	// no validation rules for CreditLine

	// no validation rules for ExpiresTime

	// no validation rules for RepaymentType

	// no validation rules for Rate

	// no validation rules for Periods

	// no validation rules for MonthlyRepaymentDay

	// no validation rules for OverdueRate

	// no validation rules for RepaymentName

	// no validation rules for RepaymentBankAccount

	// no validation rules for RepaymentBankName

	// no validation rules for ModifyTime

	if len(errors) > 0 {
		return LoanReviewApprovedRequestMultiError(errors)
	}

	return nil
}

// LoanReviewApprovedRequestMultiError is an error wrapping multiple validation
// errors returned by LoanReviewApprovedRequest.ValidateAll() if the
// designated constraints aren't met.
type LoanReviewApprovedRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoanReviewApprovedRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoanReviewApprovedRequestMultiError) AllErrors() []error { return m }

// LoanReviewApprovedRequestValidationError is the validation error returned by
// LoanReviewApprovedRequest.Validate if the designated constraints aren't met.
type LoanReviewApprovedRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoanReviewApprovedRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoanReviewApprovedRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoanReviewApprovedRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoanReviewApprovedRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoanReviewApprovedRequestValidationError) ErrorName() string {
	return "LoanReviewApprovedRequestValidationError"
}

// Error satisfies the builtin error interface
func (e LoanReviewApprovedRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoanReviewApprovedRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoanReviewApprovedRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoanReviewApprovedRequestValidationError{}

// Validate checks the field values on LoanReapplyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoanReapplyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoanReapplyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoanReapplyRequestMultiError, or nil if none found.
func (m *LoanReapplyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LoanReapplyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ApplicationNo

	// no validation rules for LegalName

	// no validation rules for DebtorRegistrationNumber

	// no validation rules for OwnersEquity

	// no validation rules for BusinessScope

	// no validation rules for BusinessEconomicType

	// no validation rules for BusinessPhone

	// no validation rules for BusinessFax

	// no validation rules for BusinessEmail

	// no validation rules for CreditorName

	// no validation rules for CreditorRegistrationNumber

	// no validation rules for FinancingPurpose

	// no validation rules for Level

	// no validation rules for ProposedCreditLimit

	// no validation rules for CreateTime

	if len(errors) > 0 {
		return LoanReapplyRequestMultiError(errors)
	}

	return nil
}

// LoanReapplyRequestMultiError is an error wrapping multiple validation errors
// returned by LoanReapplyRequest.ValidateAll() if the designated constraints
// aren't met.
type LoanReapplyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoanReapplyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoanReapplyRequestMultiError) AllErrors() []error { return m }

// LoanReapplyRequestValidationError is the validation error returned by
// LoanReapplyRequest.Validate if the designated constraints aren't met.
type LoanReapplyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoanReapplyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoanReapplyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoanReapplyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoanReapplyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoanReapplyRequestValidationError) ErrorName() string {
	return "LoanReapplyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e LoanReapplyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoanReapplyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoanReapplyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoanReapplyRequestValidationError{}

// Validate checks the field values on LoanApplicationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoanApplicationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoanApplicationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoanApplicationRequestMultiError, or nil if none found.
func (m *LoanApplicationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LoanApplicationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OutTradeNo

	// no validation rules for LoanAmount

	// no validation rules for DebtorName

	// no validation rules for DebtorRegistrationNumber

	// no validation rules for CreditorName

	// no validation rules for CreditorRegistrationNumber

	// no validation rules for ExchangeName

	// no validation rules for ExchangeRegistrationNumber

	// no validation rules for ReceiverCorporateName

	// no validation rules for ReceiverBankAccountNo

	// no validation rules for ReceiverBankName

	// no validation rules for TradeOrderFileUrl

	// no validation rules for CautionMoneyFileUrl

	// no validation rules for PaymentBookFileUrl

	// no validation rules for ApplyTime

	if len(errors) > 0 {
		return LoanApplicationRequestMultiError(errors)
	}

	return nil
}

// LoanApplicationRequestMultiError is an error wrapping multiple validation
// errors returned by LoanApplicationRequest.ValidateAll() if the designated
// constraints aren't met.
type LoanApplicationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoanApplicationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoanApplicationRequestMultiError) AllErrors() []error { return m }

// LoanApplicationRequestValidationError is the validation error returned by
// LoanApplicationRequest.Validate if the designated constraints aren't met.
type LoanApplicationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoanApplicationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoanApplicationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoanApplicationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoanApplicationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoanApplicationRequestValidationError) ErrorName() string {
	return "LoanApplicationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e LoanApplicationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoanApplicationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoanApplicationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoanApplicationRequestValidationError{}

// Validate checks the field values on LoanApprovalPaymentRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoanApprovalPaymentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoanApprovalPaymentRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoanApprovalPaymentRequestMultiError, or nil if none found.
func (m *LoanApprovalPaymentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LoanApprovalPaymentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OutTradeNo

	// no validation rules for LoanAmount

	// no validation rules for DebtorName

	// no validation rules for DebtorRegistrationNumber

	// no validation rules for CreditorName

	// no validation rules for CreditorRegistrationNumber

	// no validation rules for ExchangeName

	// no validation rules for ExchangeRegistrationNumber

	// no validation rules for ReceiverCorporateName

	// no validation rules for ReceiverBankAccountNo

	// no validation rules for ReceiverBankName

	// no validation rules for TradeOrderFileUrl

	// no validation rules for CautionMoneyFileUrl

	// no validation rules for PaymentBookFileUrl

	// no validation rules for PayBankSlipFileUrl

	// no validation rules for PayBankTradeNo

	// no validation rules for PayCorporateName

	// no validation rules for PayBankAccountNo

	// no validation rules for PayBankName

	// no validation rules for PayAuditTime

	if len(errors) > 0 {
		return LoanApprovalPaymentRequestMultiError(errors)
	}

	return nil
}

// LoanApprovalPaymentRequestMultiError is an error wrapping multiple
// validation errors returned by LoanApprovalPaymentRequest.ValidateAll() if
// the designated constraints aren't met.
type LoanApprovalPaymentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoanApprovalPaymentRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoanApprovalPaymentRequestMultiError) AllErrors() []error { return m }

// LoanApprovalPaymentRequestValidationError is the validation error returned
// by LoanApprovalPaymentRequest.Validate if the designated constraints aren't met.
type LoanApprovalPaymentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoanApprovalPaymentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoanApprovalPaymentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoanApprovalPaymentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoanApprovalPaymentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoanApprovalPaymentRequestValidationError) ErrorName() string {
	return "LoanApprovalPaymentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e LoanApprovalPaymentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoanApprovalPaymentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoanApprovalPaymentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoanApprovalPaymentRequestValidationError{}

// Validate checks the field values on PaymentScheduleGenerationRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *PaymentScheduleGenerationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PaymentScheduleGenerationRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// PaymentScheduleGenerationRequestMultiError, or nil if none found.
func (m *PaymentScheduleGenerationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PaymentScheduleGenerationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OutTradeNo

	// no validation rules for DebtorName

	// no validation rules for DebtorRegistrationNumber

	// no validation rules for CreditorName

	// no validation rules for CreditorRegistrationNumber

	// no validation rules for Amount

	// no validation rules for RepaymentType

	// no validation rules for Rate

	// no validation rules for CreateTime

	if len(errors) > 0 {
		return PaymentScheduleGenerationRequestMultiError(errors)
	}

	return nil
}

// PaymentScheduleGenerationRequestMultiError is an error wrapping multiple
// validation errors returned by
// PaymentScheduleGenerationRequest.ValidateAll() if the designated
// constraints aren't met.
type PaymentScheduleGenerationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentScheduleGenerationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentScheduleGenerationRequestMultiError) AllErrors() []error { return m }

// PaymentScheduleGenerationRequestValidationError is the validation error
// returned by PaymentScheduleGenerationRequest.Validate if the designated
// constraints aren't met.
type PaymentScheduleGenerationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentScheduleGenerationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentScheduleGenerationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentScheduleGenerationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentScheduleGenerationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentScheduleGenerationRequestValidationError) ErrorName() string {
	return "PaymentScheduleGenerationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PaymentScheduleGenerationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaymentScheduleGenerationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentScheduleGenerationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentScheduleGenerationRequestValidationError{}

// Validate checks the field values on RepaymentApplicationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RepaymentApplicationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepaymentApplicationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RepaymentApplicationRequestMultiError, or nil if none found.
func (m *RepaymentApplicationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RepaymentApplicationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OutTradeNo

	// no validation rules for DebtorName

	// no validation rules for DebtorRegistrationNumber

	// no validation rules for CreditorName

	// no validation rules for CreditorRegistrationNumber

	// no validation rules for Amount

	// no validation rules for Principal

	// no validation rules for RepaymentType

	// no validation rules for Rate

	// no validation rules for Periods

	// no validation rules for RepaymentDate

	// no validation rules for IsOverdue

	// no validation rules for PenaltyInterest

	// no validation rules for RepaymentAmount

	// no validation rules for BankSlip

	// no validation rules for PayBankTradeNo

	// no validation rules for PayUnitName

	// no validation rules for PayBankAccountNo

	// no validation rules for PayBankName

	// no validation rules for RepaymentName

	// no validation rules for RepaymentBankAccount

	// no validation rules for RepaymentBankName

	// no validation rules for ApplyTime

	if len(errors) > 0 {
		return RepaymentApplicationRequestMultiError(errors)
	}

	return nil
}

// RepaymentApplicationRequestMultiError is an error wrapping multiple
// validation errors returned by RepaymentApplicationRequest.ValidateAll() if
// the designated constraints aren't met.
type RepaymentApplicationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepaymentApplicationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepaymentApplicationRequestMultiError) AllErrors() []error { return m }

// RepaymentApplicationRequestValidationError is the validation error returned
// by RepaymentApplicationRequest.Validate if the designated constraints
// aren't met.
type RepaymentApplicationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepaymentApplicationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepaymentApplicationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepaymentApplicationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepaymentApplicationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepaymentApplicationRequestValidationError) ErrorName() string {
	return "RepaymentApplicationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RepaymentApplicationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepaymentApplicationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepaymentApplicationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepaymentApplicationRequestValidationError{}

// Validate checks the field values on RepaymentApprovedRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RepaymentApprovedRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepaymentApprovedRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RepaymentApprovedRequestMultiError, or nil if none found.
func (m *RepaymentApprovedRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RepaymentApprovedRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OutTradeNo

	// no validation rules for DebtorName

	// no validation rules for DebtorRegistrationNumber

	// no validation rules for CreditorName

	// no validation rules for CreditorRegistrationNumber

	// no validation rules for Amount

	// no validation rules for Principal

	// no validation rules for RepaymentType

	// no validation rules for Rate

	// no validation rules for Periods

	// no validation rules for RepaymentDate

	// no validation rules for IsOverdue

	// no validation rules for PenaltyInterest

	// no validation rules for RepaymentAmount

	// no validation rules for BankSlip

	// no validation rules for PayBankTradeNo

	// no validation rules for PayUnitName

	// no validation rules for PayBankAccountNo

	// no validation rules for PayBankName

	// no validation rules for RepaymentName

	// no validation rules for RepaymentBankAccount

	// no validation rules for RepaymentBankName

	// no validation rules for ApprovalResult

	// no validation rules for ApprovalTime

	if len(errors) > 0 {
		return RepaymentApprovedRequestMultiError(errors)
	}

	return nil
}

// RepaymentApprovedRequestMultiError is an error wrapping multiple validation
// errors returned by RepaymentApprovedRequest.ValidateAll() if the designated
// constraints aren't met.
type RepaymentApprovedRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepaymentApprovedRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepaymentApprovedRequestMultiError) AllErrors() []error { return m }

// RepaymentApprovedRequestValidationError is the validation error returned by
// RepaymentApprovedRequest.Validate if the designated constraints aren't met.
type RepaymentApprovedRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepaymentApprovedRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepaymentApprovedRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepaymentApprovedRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepaymentApprovedRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepaymentApprovedRequestValidationError) ErrorName() string {
	return "RepaymentApprovedRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RepaymentApprovedRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepaymentApprovedRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepaymentApprovedRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepaymentApprovedRequestValidationError{}

// Validate checks the field values on RepaymentDeniedRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RepaymentDeniedRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepaymentDeniedRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RepaymentDeniedRequestMultiError, or nil if none found.
func (m *RepaymentDeniedRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RepaymentDeniedRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OutTradeNo

	// no validation rules for DebtorName

	// no validation rules for DebtorRegistrationNumber

	// no validation rules for CreditorName

	// no validation rules for CreditorRegistrationNumber

	// no validation rules for Amount

	// no validation rules for Principal

	// no validation rules for RepaymentType

	// no validation rules for Rate

	// no validation rules for Periods

	// no validation rules for RepaymentDate

	// no validation rules for IsOverdue

	// no validation rules for PenaltyInterest

	// no validation rules for RepaymentAmount

	// no validation rules for BankSlip

	// no validation rules for PayBankTradeNo

	// no validation rules for PayUnitName

	// no validation rules for PayBankAccountNo

	// no validation rules for PayBankName

	// no validation rules for RepaymentName

	// no validation rules for RepaymentBankAccount

	// no validation rules for RepaymentBankName

	// no validation rules for ApprovalResult

	// no validation rules for RejectionReason

	// no validation rules for ApprovalTime

	if len(errors) > 0 {
		return RepaymentDeniedRequestMultiError(errors)
	}

	return nil
}

// RepaymentDeniedRequestMultiError is an error wrapping multiple validation
// errors returned by RepaymentDeniedRequest.ValidateAll() if the designated
// constraints aren't met.
type RepaymentDeniedRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepaymentDeniedRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepaymentDeniedRequestMultiError) AllErrors() []error { return m }

// RepaymentDeniedRequestValidationError is the validation error returned by
// RepaymentDeniedRequest.Validate if the designated constraints aren't met.
type RepaymentDeniedRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepaymentDeniedRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepaymentDeniedRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepaymentDeniedRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepaymentDeniedRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepaymentDeniedRequestValidationError) ErrorName() string {
	return "RepaymentDeniedRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RepaymentDeniedRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepaymentDeniedRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepaymentDeniedRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepaymentDeniedRequestValidationError{}

// Validate checks the field values on RepaymentReapplyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RepaymentReapplyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepaymentReapplyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RepaymentReapplyRequestMultiError, or nil if none found.
func (m *RepaymentReapplyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RepaymentReapplyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OutTradeNo

	// no validation rules for DebtorName

	// no validation rules for DebtorRegistrationNumber

	// no validation rules for CreditorName

	// no validation rules for CreditorRegistrationNumber

	// no validation rules for Amount

	// no validation rules for Principal

	// no validation rules for RepaymentType

	// no validation rules for Rate

	// no validation rules for Periods

	// no validation rules for RepaymentDate

	// no validation rules for IsOverdue

	// no validation rules for PenaltyInterest

	// no validation rules for RepaymentAmount

	// no validation rules for BankSlip

	// no validation rules for PayBankTradeNo

	// no validation rules for PayUnitName

	// no validation rules for PayBankAccountNo

	// no validation rules for PayBankName

	// no validation rules for RepaymentName

	// no validation rules for RepaymentBankAccount

	// no validation rules for RepaymentBankName

	// no validation rules for ApplyTime

	if len(errors) > 0 {
		return RepaymentReapplyRequestMultiError(errors)
	}

	return nil
}

// RepaymentReapplyRequestMultiError is an error wrapping multiple validation
// errors returned by RepaymentReapplyRequest.ValidateAll() if the designated
// constraints aren't met.
type RepaymentReapplyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepaymentReapplyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepaymentReapplyRequestMultiError) AllErrors() []error { return m }

// RepaymentReapplyRequestValidationError is the validation error returned by
// RepaymentReapplyRequest.Validate if the designated constraints aren't met.
type RepaymentReapplyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepaymentReapplyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepaymentReapplyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepaymentReapplyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepaymentReapplyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepaymentReapplyRequestValidationError) ErrorName() string {
	return "RepaymentReapplyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RepaymentReapplyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepaymentReapplyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepaymentReapplyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepaymentReapplyRequestValidationError{}

// Validate checks the field values on FinancialResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *FinancialResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinancialResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FinancialResponseMultiError, or nil if none found.
func (m *FinancialResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FinancialResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FinancialResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FinancialResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FinancialResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FinancialResponseMultiError(errors)
	}

	return nil
}

// FinancialResponseMultiError is an error wrapping multiple validation errors
// returned by FinancialResponse.ValidateAll() if the designated constraints
// aren't met.
type FinancialResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinancialResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinancialResponseMultiError) AllErrors() []error { return m }

// FinancialResponseValidationError is the validation error returned by
// FinancialResponse.Validate if the designated constraints aren't met.
type FinancialResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinancialResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinancialResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinancialResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinancialResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinancialResponseValidationError) ErrorName() string {
	return "FinancialResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FinancialResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinancialResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinancialResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinancialResponseValidationError{}

// Validate checks the field values on InstrumentOrderRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstrumentOrderRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstrumentOrderRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstrumentOrderRequestMultiError, or nil if none found.
func (m *InstrumentOrderRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InstrumentOrderRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TradeId

	// no validation rules for ExchangeId

	// no validation rules for SellerId

	// no validation rules for BuyerId

	// no validation rules for TradeAmount

	// no validation rules for TradeType

	// no validation rules for TradeStatus

	// no validation rules for TradeDatetime

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	// no validation rules for CompanyId

	// no validation rules for CompanyName

	// no validation rules for ProjectId

	// no validation rules for ProjectName

	// no validation rules for ExchangeName

	// no validation rules for InstrumentId

	// no validation rules for InstrumentName

	// no validation rules for SettlementType

	// no validation rules for SettlementId

	if len(errors) > 0 {
		return InstrumentOrderRequestMultiError(errors)
	}

	return nil
}

// InstrumentOrderRequestMultiError is an error wrapping multiple validation
// errors returned by InstrumentOrderRequest.ValidateAll() if the designated
// constraints aren't met.
type InstrumentOrderRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstrumentOrderRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstrumentOrderRequestMultiError) AllErrors() []error { return m }

// InstrumentOrderRequestValidationError is the validation error returned by
// InstrumentOrderRequest.Validate if the designated constraints aren't met.
type InstrumentOrderRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstrumentOrderRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstrumentOrderRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstrumentOrderRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstrumentOrderRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstrumentOrderRequestValidationError) ErrorName() string {
	return "InstrumentOrderRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InstrumentOrderRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstrumentOrderRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstrumentOrderRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstrumentOrderRequestValidationError{}

// Validate checks the field values on InstrumentOrderResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstrumentOrderResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstrumentOrderResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstrumentOrderResponseMultiError, or nil if none found.
func (m *InstrumentOrderResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *InstrumentOrderResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentOrderResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentOrderResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentOrderResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InstrumentOrderResponseMultiError(errors)
	}

	return nil
}

// InstrumentOrderResponseMultiError is an error wrapping multiple validation
// errors returned by InstrumentOrderResponse.ValidateAll() if the designated
// constraints aren't met.
type InstrumentOrderResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstrumentOrderResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstrumentOrderResponseMultiError) AllErrors() []error { return m }

// InstrumentOrderResponseValidationError is the validation error returned by
// InstrumentOrderResponse.Validate if the designated constraints aren't met.
type InstrumentOrderResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstrumentOrderResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstrumentOrderResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstrumentOrderResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstrumentOrderResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstrumentOrderResponseValidationError) ErrorName() string {
	return "InstrumentOrderResponseValidationError"
}

// Error satisfies the builtin error interface
func (e InstrumentOrderResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstrumentOrderResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstrumentOrderResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstrumentOrderResponseValidationError{}

// Validate checks the field values on InstrumentOrderData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstrumentOrderData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstrumentOrderData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstrumentOrderDataMultiError, or nil if none found.
func (m *InstrumentOrderData) ValidateAll() error {
	return m.validate(true)
}

func (m *InstrumentOrderData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInstrumentOrderHash()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentOrderDataValidationError{
					field:  "InstrumentOrderHash",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentOrderDataValidationError{
					field:  "InstrumentOrderHash",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstrumentOrderHash()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentOrderDataValidationError{
				field:  "InstrumentOrderHash",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InstrumentOrderDataMultiError(errors)
	}

	return nil
}

// InstrumentOrderDataMultiError is an error wrapping multiple validation
// errors returned by InstrumentOrderData.ValidateAll() if the designated
// constraints aren't met.
type InstrumentOrderDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstrumentOrderDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstrumentOrderDataMultiError) AllErrors() []error { return m }

// InstrumentOrderDataValidationError is the validation error returned by
// InstrumentOrderData.Validate if the designated constraints aren't met.
type InstrumentOrderDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstrumentOrderDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstrumentOrderDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstrumentOrderDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstrumentOrderDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstrumentOrderDataValidationError) ErrorName() string {
	return "InstrumentOrderDataValidationError"
}

// Error satisfies the builtin error interface
func (e InstrumentOrderDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstrumentOrderData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstrumentOrderDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstrumentOrderDataValidationError{}

// Validate checks the field values on InstrumentOrderHash with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstrumentOrderHash) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstrumentOrderHash with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstrumentOrderHashMultiError, or nil if none found.
func (m *InstrumentOrderHash) ValidateAll() error {
	return m.validate(true)
}

func (m *InstrumentOrderHash) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TradeId

	// no validation rules for TxHash

	if len(errors) > 0 {
		return InstrumentOrderHashMultiError(errors)
	}

	return nil
}

// InstrumentOrderHashMultiError is an error wrapping multiple validation
// errors returned by InstrumentOrderHash.ValidateAll() if the designated
// constraints aren't met.
type InstrumentOrderHashMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstrumentOrderHashMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstrumentOrderHashMultiError) AllErrors() []error { return m }

// InstrumentOrderHashValidationError is the validation error returned by
// InstrumentOrderHash.Validate if the designated constraints aren't met.
type InstrumentOrderHashValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstrumentOrderHashValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstrumentOrderHashValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstrumentOrderHashValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstrumentOrderHashValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstrumentOrderHashValidationError) ErrorName() string {
	return "InstrumentOrderHashValidationError"
}

// Error satisfies the builtin error interface
func (e InstrumentOrderHashValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstrumentOrderHash.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstrumentOrderHashValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstrumentOrderHashValidationError{}

// Validate checks the field values on QueryInstrumentOrderRecordRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *QueryInstrumentOrderRecordRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryInstrumentOrderRecordRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// QueryInstrumentOrderRecordRequestMultiError, or nil if none found.
func (m *QueryInstrumentOrderRecordRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryInstrumentOrderRecordRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TradeId

	if len(errors) > 0 {
		return QueryInstrumentOrderRecordRequestMultiError(errors)
	}

	return nil
}

// QueryInstrumentOrderRecordRequestMultiError is an error wrapping multiple
// validation errors returned by
// QueryInstrumentOrderRecordRequest.ValidateAll() if the designated
// constraints aren't met.
type QueryInstrumentOrderRecordRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryInstrumentOrderRecordRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryInstrumentOrderRecordRequestMultiError) AllErrors() []error { return m }

// QueryInstrumentOrderRecordRequestValidationError is the validation error
// returned by QueryInstrumentOrderRecordRequest.Validate if the designated
// constraints aren't met.
type QueryInstrumentOrderRecordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryInstrumentOrderRecordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryInstrumentOrderRecordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryInstrumentOrderRecordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryInstrumentOrderRecordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryInstrumentOrderRecordRequestValidationError) ErrorName() string {
	return "QueryInstrumentOrderRecordRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryInstrumentOrderRecordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryInstrumentOrderRecordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryInstrumentOrderRecordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryInstrumentOrderRecordRequestValidationError{}

// Validate checks the field values on QueryInstrumentOrderRecordResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *QueryInstrumentOrderRecordResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryInstrumentOrderRecordResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// QueryInstrumentOrderRecordResponseMultiError, or nil if none found.
func (m *QueryInstrumentOrderRecordResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryInstrumentOrderRecordResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryInstrumentOrderRecordResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryInstrumentOrderRecordResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryInstrumentOrderRecordResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return QueryInstrumentOrderRecordResponseMultiError(errors)
	}

	return nil
}

// QueryInstrumentOrderRecordResponseMultiError is an error wrapping multiple
// validation errors returned by
// QueryInstrumentOrderRecordResponse.ValidateAll() if the designated
// constraints aren't met.
type QueryInstrumentOrderRecordResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryInstrumentOrderRecordResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryInstrumentOrderRecordResponseMultiError) AllErrors() []error { return m }

// QueryInstrumentOrderRecordResponseValidationError is the validation error
// returned by QueryInstrumentOrderRecordResponse.Validate if the designated
// constraints aren't met.
type QueryInstrumentOrderRecordResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryInstrumentOrderRecordResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryInstrumentOrderRecordResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryInstrumentOrderRecordResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryInstrumentOrderRecordResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryInstrumentOrderRecordResponseValidationError) ErrorName() string {
	return "QueryInstrumentOrderRecordResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryInstrumentOrderRecordResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryInstrumentOrderRecordResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryInstrumentOrderRecordResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryInstrumentOrderRecordResponseValidationError{}

// Validate checks the field values on InstrumentOrderRecord with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstrumentOrderRecord) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstrumentOrderRecord with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstrumentOrderRecordMultiError, or nil if none found.
func (m *InstrumentOrderRecord) ValidateAll() error {
	return m.validate(true)
}

func (m *InstrumentOrderRecord) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TradeId

	// no validation rules for TxHash

	// no validation rules for TradeType

	// no validation rules for CreateTime

	if len(errors) > 0 {
		return InstrumentOrderRecordMultiError(errors)
	}

	return nil
}

// InstrumentOrderRecordMultiError is an error wrapping multiple validation
// errors returned by InstrumentOrderRecord.ValidateAll() if the designated
// constraints aren't met.
type InstrumentOrderRecordMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstrumentOrderRecordMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstrumentOrderRecordMultiError) AllErrors() []error { return m }

// InstrumentOrderRecordValidationError is the validation error returned by
// InstrumentOrderRecord.Validate if the designated constraints aren't met.
type InstrumentOrderRecordValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstrumentOrderRecordValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstrumentOrderRecordValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstrumentOrderRecordValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstrumentOrderRecordValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstrumentOrderRecordValidationError) ErrorName() string {
	return "InstrumentOrderRecordValidationError"
}

// Error satisfies the builtin error interface
func (e InstrumentOrderRecordValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstrumentOrderRecord.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstrumentOrderRecordValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstrumentOrderRecordValidationError{}

// Validate checks the field values on ConvertToInvoiceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConvertToInvoiceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConvertToInvoiceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConvertToInvoiceRequestMultiError, or nil if none found.
func (m *ConvertToInvoiceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ConvertToInvoiceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectId

	// no validation rules for ProjectName

	// no validation rules for ExchangeId

	// no validation rules for ExchangeName

	// no validation rules for SellerId

	// no validation rules for SellerName

	// no validation rules for InstrumentId

	// no validation rules for InstrumentName

	// no validation rules for BuyerId

	// no validation rules for BuyerName

	// no validation rules for BidbondAmount

	// no validation rules for TransactionAmount

	// no validation rules for ConvertedAmount

	// no validation rules for Status

	// no validation rules for UpdateTime

	if len(errors) > 0 {
		return ConvertToInvoiceRequestMultiError(errors)
	}

	return nil
}

// ConvertToInvoiceRequestMultiError is an error wrapping multiple validation
// errors returned by ConvertToInvoiceRequest.ValidateAll() if the designated
// constraints aren't met.
type ConvertToInvoiceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConvertToInvoiceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConvertToInvoiceRequestMultiError) AllErrors() []error { return m }

// ConvertToInvoiceRequestValidationError is the validation error returned by
// ConvertToInvoiceRequest.Validate if the designated constraints aren't met.
type ConvertToInvoiceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConvertToInvoiceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConvertToInvoiceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConvertToInvoiceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConvertToInvoiceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConvertToInvoiceRequestValidationError) ErrorName() string {
	return "ConvertToInvoiceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ConvertToInvoiceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConvertToInvoiceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConvertToInvoiceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConvertToInvoiceRequestValidationError{}

// Validate checks the field values on RefundBalanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefundBalanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefundBalanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefundBalanceRequestMultiError, or nil if none found.
func (m *RefundBalanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RefundBalanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectId

	// no validation rules for ProjectName

	// no validation rules for ExchangeId

	// no validation rules for ExchangeName

	// no validation rules for SellerId

	// no validation rules for SellerName

	// no validation rules for InstrumentId

	// no validation rules for InstrumentName

	// no validation rules for BuyerId

	// no validation rules for BuyerName

	// no validation rules for BidbondAmount

	// no validation rules for TransactionAmount

	// no validation rules for ConvertedAmount

	// no validation rules for RefundAmount

	// no validation rules for Status

	// no validation rules for UpdateTime

	if len(errors) > 0 {
		return RefundBalanceRequestMultiError(errors)
	}

	return nil
}

// RefundBalanceRequestMultiError is an error wrapping multiple validation
// errors returned by RefundBalanceRequest.ValidateAll() if the designated
// constraints aren't met.
type RefundBalanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefundBalanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefundBalanceRequestMultiError) AllErrors() []error { return m }

// RefundBalanceRequestValidationError is the validation error returned by
// RefundBalanceRequest.Validate if the designated constraints aren't met.
type RefundBalanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefundBalanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefundBalanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefundBalanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefundBalanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefundBalanceRequestValidationError) ErrorName() string {
	return "RefundBalanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RefundBalanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefundBalanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefundBalanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefundBalanceRequestValidationError{}

// Validate checks the field values on FullRefundRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *FullRefundRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FullRefundRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FullRefundRequestMultiError, or nil if none found.
func (m *FullRefundRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FullRefundRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectId

	// no validation rules for ProjectName

	// no validation rules for ExchangeId

	// no validation rules for ExchangeName

	// no validation rules for SellerId

	// no validation rules for SellerName

	// no validation rules for InstrumentId

	// no validation rules for InstrumentName

	// no validation rules for BuyerId

	// no validation rules for BuyerName

	// no validation rules for BidbondAmount

	// no validation rules for RefundAmount

	// no validation rules for Status

	// no validation rules for UpdateTime

	if len(errors) > 0 {
		return FullRefundRequestMultiError(errors)
	}

	return nil
}

// FullRefundRequestMultiError is an error wrapping multiple validation errors
// returned by FullRefundRequest.ValidateAll() if the designated constraints
// aren't met.
type FullRefundRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FullRefundRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FullRefundRequestMultiError) AllErrors() []error { return m }

// FullRefundRequestValidationError is the validation error returned by
// FullRefundRequest.Validate if the designated constraints aren't met.
type FullRefundRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FullRefundRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FullRefundRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FullRefundRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FullRefundRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FullRefundRequestValidationError) ErrorName() string {
	return "FullRefundRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FullRefundRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFullRefundRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FullRefundRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FullRefundRequestValidationError{}

// Validate checks the field values on TradeResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TradeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TradeResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TradeResponseMultiError, or
// nil if none found.
func (m *TradeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TradeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradeResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TradeResponseMultiError(errors)
	}

	return nil
}

// TradeResponseMultiError is an error wrapping multiple validation errors
// returned by TradeResponse.ValidateAll() if the designated constraints
// aren't met.
type TradeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TradeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TradeResponseMultiError) AllErrors() []error { return m }

// TradeResponseValidationError is the validation error returned by
// TradeResponse.Validate if the designated constraints aren't met.
type TradeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TradeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TradeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TradeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TradeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TradeResponseValidationError) ErrorName() string { return "TradeResponseValidationError" }

// Error satisfies the builtin error interface
func (e TradeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTradeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TradeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TradeResponseValidationError{}

// Validate checks the field values on TradeChargeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TradeChargeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TradeChargeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TradeChargeRequestMultiError, or nil if none found.
func (m *TradeChargeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TradeChargeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TradeChargeId

	// no validation rules for TradeId

	// no validation rules for ChargeObject

	// no validation rules for CompanyName

	// no validation rules for ChargeAmount

	// no validation rules for PaymentStatus

	// no validation rules for CreateTime

	// no validation rules for ExpiryDatetime

	// no validation rules for PayeeAccountName

	// no validation rules for PayeeAccountNumber

	// no validation rules for PayeeBankName

	// no validation rules for TransactionFlowId

	// no validation rules for PayerAccountName

	// no validation rules for PayerAccountNumber

	// no validation rules for PayerBankName

	// no validation rules for FileUrl

	// no validation rules for SubmitTime

	// no validation rules for AuditResult

	// no validation rules for Remark

	// no validation rules for AuditTime

	if len(errors) > 0 {
		return TradeChargeRequestMultiError(errors)
	}

	return nil
}

// TradeChargeRequestMultiError is an error wrapping multiple validation errors
// returned by TradeChargeRequest.ValidateAll() if the designated constraints
// aren't met.
type TradeChargeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TradeChargeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TradeChargeRequestMultiError) AllErrors() []error { return m }

// TradeChargeRequestValidationError is the validation error returned by
// TradeChargeRequest.Validate if the designated constraints aren't met.
type TradeChargeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TradeChargeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TradeChargeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TradeChargeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TradeChargeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TradeChargeRequestValidationError) ErrorName() string {
	return "TradeChargeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TradeChargeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTradeChargeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TradeChargeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TradeChargeRequestValidationError{}

// Validate checks the field values on TradeChargeRecordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TradeChargeRecordRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TradeChargeRecordRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TradeChargeRecordRequestMultiError, or nil if none found.
func (m *TradeChargeRecordRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TradeChargeRecordRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TradeId

	if len(errors) > 0 {
		return TradeChargeRecordRequestMultiError(errors)
	}

	return nil
}

// TradeChargeRecordRequestMultiError is an error wrapping multiple validation
// errors returned by TradeChargeRecordRequest.ValidateAll() if the designated
// constraints aren't met.
type TradeChargeRecordRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TradeChargeRecordRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TradeChargeRecordRequestMultiError) AllErrors() []error { return m }

// TradeChargeRecordRequestValidationError is the validation error returned by
// TradeChargeRecordRequest.Validate if the designated constraints aren't met.
type TradeChargeRecordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TradeChargeRecordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TradeChargeRecordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TradeChargeRecordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TradeChargeRecordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TradeChargeRecordRequestValidationError) ErrorName() string {
	return "TradeChargeRecordRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TradeChargeRecordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTradeChargeRecordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TradeChargeRecordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TradeChargeRecordRequestValidationError{}

// Validate checks the field values on TradeChargeRecordResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TradeChargeRecordResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TradeChargeRecordResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TradeChargeRecordResponseMultiError, or nil if none found.
func (m *TradeChargeRecordResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TradeChargeRecordResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TradeChargeRecordResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TradeChargeRecordResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TradeChargeRecordResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TradeChargeRecordResponseMultiError(errors)
	}

	return nil
}

// TradeChargeRecordResponseMultiError is an error wrapping multiple validation
// errors returned by TradeChargeRecordResponse.ValidateAll() if the
// designated constraints aren't met.
type TradeChargeRecordResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TradeChargeRecordResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TradeChargeRecordResponseMultiError) AllErrors() []error { return m }

// TradeChargeRecordResponseValidationError is the validation error returned by
// TradeChargeRecordResponse.Validate if the designated constraints aren't met.
type TradeChargeRecordResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TradeChargeRecordResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TradeChargeRecordResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TradeChargeRecordResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TradeChargeRecordResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TradeChargeRecordResponseValidationError) ErrorName() string {
	return "TradeChargeRecordResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TradeChargeRecordResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTradeChargeRecordResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TradeChargeRecordResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TradeChargeRecordResponseValidationError{}

// Validate checks the field values on TradeChargeRecord with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TradeChargeRecord) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TradeChargeRecord with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TradeChargeRecordMultiError, or nil if none found.
func (m *TradeChargeRecord) ValidateAll() error {
	return m.validate(true)
}

func (m *TradeChargeRecord) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TradeId

	// no validation rules for TxHash

	// no validation rules for TradeType

	// no validation rules for CreateTime

	if len(errors) > 0 {
		return TradeChargeRecordMultiError(errors)
	}

	return nil
}

// TradeChargeRecordMultiError is an error wrapping multiple validation errors
// returned by TradeChargeRecord.ValidateAll() if the designated constraints
// aren't met.
type TradeChargeRecordMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TradeChargeRecordMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TradeChargeRecordMultiError) AllErrors() []error { return m }

// TradeChargeRecordValidationError is the validation error returned by
// TradeChargeRecord.Validate if the designated constraints aren't met.
type TradeChargeRecordValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TradeChargeRecordValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TradeChargeRecordValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TradeChargeRecordValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TradeChargeRecordValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TradeChargeRecordValidationError) ErrorName() string {
	return "TradeChargeRecordValidationError"
}

// Error satisfies the builtin error interface
func (e TradeChargeRecordValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTradeChargeRecord.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TradeChargeRecordValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TradeChargeRecordValidationError{}

// Validate checks the field values on VoucherBlockchainRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VoucherBlockchainRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VoucherBlockchainRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VoucherBlockchainRequestMultiError, or nil if none found.
func (m *VoucherBlockchainRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *VoucherBlockchainRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for VoucherFile

	if len(errors) > 0 {
		return VoucherBlockchainRequestMultiError(errors)
	}

	return nil
}

// VoucherBlockchainRequestMultiError is an error wrapping multiple validation
// errors returned by VoucherBlockchainRequest.ValidateAll() if the designated
// constraints aren't met.
type VoucherBlockchainRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VoucherBlockchainRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VoucherBlockchainRequestMultiError) AllErrors() []error { return m }

// VoucherBlockchainRequestValidationError is the validation error returned by
// VoucherBlockchainRequest.Validate if the designated constraints aren't met.
type VoucherBlockchainRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VoucherBlockchainRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VoucherBlockchainRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VoucherBlockchainRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VoucherBlockchainRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VoucherBlockchainRequestValidationError) ErrorName() string {
	return "VoucherBlockchainRequestValidationError"
}

// Error satisfies the builtin error interface
func (e VoucherBlockchainRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVoucherBlockchainRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VoucherBlockchainRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VoucherBlockchainRequestValidationError{}

// Validate checks the field values on VoucherBlockchainResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VoucherBlockchainResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VoucherBlockchainResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VoucherBlockchainResponseMultiError, or nil if none found.
func (m *VoucherBlockchainResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *VoucherBlockchainResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VoucherBlockchainResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VoucherBlockchainResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VoucherBlockchainResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return VoucherBlockchainResponseMultiError(errors)
	}

	return nil
}

// VoucherBlockchainResponseMultiError is an error wrapping multiple validation
// errors returned by VoucherBlockchainResponse.ValidateAll() if the
// designated constraints aren't met.
type VoucherBlockchainResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VoucherBlockchainResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VoucherBlockchainResponseMultiError) AllErrors() []error { return m }

// VoucherBlockchainResponseValidationError is the validation error returned by
// VoucherBlockchainResponse.Validate if the designated constraints aren't met.
type VoucherBlockchainResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VoucherBlockchainResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VoucherBlockchainResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VoucherBlockchainResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VoucherBlockchainResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VoucherBlockchainResponseValidationError) ErrorName() string {
	return "VoucherBlockchainResponseValidationError"
}

// Error satisfies the builtin error interface
func (e VoucherBlockchainResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVoucherBlockchainResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VoucherBlockchainResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VoucherBlockchainResponseValidationError{}

// Validate checks the field values on
// BlockChainTicketCheckRequest_TicketCheckData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BlockChainTicketCheckRequest_TicketCheckData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// BlockChainTicketCheckRequest_TicketCheckData with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// BlockChainTicketCheckRequest_TicketCheckDataMultiError, or nil if none found.
func (m *BlockChainTicketCheckRequest_TicketCheckData) ValidateAll() error {
	return m.validate(true)
}

func (m *BlockChainTicketCheckRequest_TicketCheckData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TicketNumber

	if utf8.RuneCountInString(m.GetStockBatchNumber()) < 0 {
		err := BlockChainTicketCheckRequest_TicketCheckDataValidationError{
			field:  "StockBatchNumber",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for EnterTime

	// no validation rules for CheckNumber

	// no validation rules for ScenicId

	// no validation rules for IdCard

	// no validation rules for QrCode

	// no validation rules for OtherWay

	// no validation rules for PointName

	// no validation rules for PointId

	// no validation rules for EquipmentName

	// no validation rules for EquipmentId

	// no validation rules for EquipmentType

	// no validation rules for IdName

	// no validation rules for UserId

	// no validation rules for Username

	if all {
		switch v := interface{}(m.GetTicketStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockChainTicketCheckRequest_TicketCheckDataValidationError{
					field:  "TicketStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockChainTicketCheckRequest_TicketCheckDataValidationError{
					field:  "TicketStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTicketStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockChainTicketCheckRequest_TicketCheckDataValidationError{
				field:  "TicketStatus",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BlockChainTicketCheckRequest_TicketCheckDataMultiError(errors)
	}

	return nil
}

// BlockChainTicketCheckRequest_TicketCheckDataMultiError is an error wrapping
// multiple validation errors returned by
// BlockChainTicketCheckRequest_TicketCheckData.ValidateAll() if the
// designated constraints aren't met.
type BlockChainTicketCheckRequest_TicketCheckDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlockChainTicketCheckRequest_TicketCheckDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlockChainTicketCheckRequest_TicketCheckDataMultiError) AllErrors() []error { return m }

// BlockChainTicketCheckRequest_TicketCheckDataValidationError is the
// validation error returned by
// BlockChainTicketCheckRequest_TicketCheckData.Validate if the designated
// constraints aren't met.
type BlockChainTicketCheckRequest_TicketCheckDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlockChainTicketCheckRequest_TicketCheckDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlockChainTicketCheckRequest_TicketCheckDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlockChainTicketCheckRequest_TicketCheckDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlockChainTicketCheckRequest_TicketCheckDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlockChainTicketCheckRequest_TicketCheckDataValidationError) ErrorName() string {
	return "BlockChainTicketCheckRequest_TicketCheckDataValidationError"
}

// Error satisfies the builtin error interface
func (e BlockChainTicketCheckRequest_TicketCheckDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlockChainTicketCheckRequest_TicketCheckData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlockChainTicketCheckRequest_TicketCheckDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlockChainTicketCheckRequest_TicketCheckDataValidationError{}

// Validate checks the field values on BlockChainTicketCheckResponse_TxData
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *BlockChainTicketCheckResponse_TxData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlockChainTicketCheckResponse_TxData
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// BlockChainTicketCheckResponse_TxDataMultiError, or nil if none found.
func (m *BlockChainTicketCheckResponse_TxData) ValidateAll() error {
	return m.validate(true)
}

func (m *BlockChainTicketCheckResponse_TxData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TxId

	if len(errors) > 0 {
		return BlockChainTicketCheckResponse_TxDataMultiError(errors)
	}

	return nil
}

// BlockChainTicketCheckResponse_TxDataMultiError is an error wrapping multiple
// validation errors returned by
// BlockChainTicketCheckResponse_TxData.ValidateAll() if the designated
// constraints aren't met.
type BlockChainTicketCheckResponse_TxDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlockChainTicketCheckResponse_TxDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlockChainTicketCheckResponse_TxDataMultiError) AllErrors() []error { return m }

// BlockChainTicketCheckResponse_TxDataValidationError is the validation error
// returned by BlockChainTicketCheckResponse_TxData.Validate if the designated
// constraints aren't met.
type BlockChainTicketCheckResponse_TxDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlockChainTicketCheckResponse_TxDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlockChainTicketCheckResponse_TxDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlockChainTicketCheckResponse_TxDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlockChainTicketCheckResponse_TxDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlockChainTicketCheckResponse_TxDataValidationError) ErrorName() string {
	return "BlockChainTicketCheckResponse_TxDataValidationError"
}

// Error satisfies the builtin error interface
func (e BlockChainTicketCheckResponse_TxDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlockChainTicketCheckResponse_TxData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlockChainTicketCheckResponse_TxDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlockChainTicketCheckResponse_TxDataValidationError{}

// Validate checks the field values on TicketData_BuyerInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TicketData_BuyerInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TicketData_BuyerInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TicketData_BuyerInfoMultiError, or nil if none found.
func (m *TicketData_BuyerInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *TicketData_BuyerInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IdName

	// no validation rules for IdNumber

	if len(errors) > 0 {
		return TicketData_BuyerInfoMultiError(errors)
	}

	return nil
}

// TicketData_BuyerInfoMultiError is an error wrapping multiple validation
// errors returned by TicketData_BuyerInfo.ValidateAll() if the designated
// constraints aren't met.
type TicketData_BuyerInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TicketData_BuyerInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TicketData_BuyerInfoMultiError) AllErrors() []error { return m }

// TicketData_BuyerInfoValidationError is the validation error returned by
// TicketData_BuyerInfo.Validate if the designated constraints aren't met.
type TicketData_BuyerInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TicketData_BuyerInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TicketData_BuyerInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TicketData_BuyerInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TicketData_BuyerInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TicketData_BuyerInfoValidationError) ErrorName() string {
	return "TicketData_BuyerInfoValidationError"
}

// Error satisfies the builtin error interface
func (e TicketData_BuyerInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTicketData_BuyerInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TicketData_BuyerInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TicketData_BuyerInfoValidationError{}

// Validate checks the field values on TicketData_TicketIssuanceSubInfo with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *TicketData_TicketIssuanceSubInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TicketData_TicketIssuanceSubInfo with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// TicketData_TicketIssuanceSubInfoMultiError, or nil if none found.
func (m *TicketData_TicketIssuanceSubInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *TicketData_TicketIssuanceSubInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TicketIssuanceId

	// no validation rules for TicketTypeId

	// no validation rules for TicketTypeSubId

	if all {
		switch v := interface{}(m.GetGoodsType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketData_TicketIssuanceSubInfoValidationError{
					field:  "GoodsType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketData_TicketIssuanceSubInfoValidationError{
					field:  "GoodsType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGoodsType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketData_TicketIssuanceSubInfoValidationError{
				field:  "GoodsType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPassTimes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketData_TicketIssuanceSubInfoValidationError{
					field:  "PassTimes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketData_TicketIssuanceSubInfoValidationError{
					field:  "PassTimes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPassTimes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketData_TicketIssuanceSubInfoValidationError{
				field:  "PassTimes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPassedTimes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketData_TicketIssuanceSubInfoValidationError{
					field:  "PassedTimes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketData_TicketIssuanceSubInfoValidationError{
					field:  "PassedTimes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPassedTimes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketData_TicketIssuanceSubInfoValidationError{
				field:  "PassedTimes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSinglePerTimes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketData_TicketIssuanceSubInfoValidationError{
					field:  "SinglePerTimes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketData_TicketIssuanceSubInfoValidationError{
					field:  "SinglePerTimes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSinglePerTimes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketData_TicketIssuanceSubInfoValidationError{
				field:  "SinglePerTimes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIsValid()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketData_TicketIssuanceSubInfoValidationError{
					field:  "IsValid",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketData_TicketIssuanceSubInfoValidationError{
					field:  "IsValid",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsValid()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketData_TicketIssuanceSubInfoValidationError{
				field:  "IsValid",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for EnterBeginTime

	// no validation rules for EnterEndTime

	// no validation rules for OverdueTime

	if all {
		switch v := interface{}(m.GetValidityDay()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketData_TicketIssuanceSubInfoValidationError{
					field:  "ValidityDay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketData_TicketIssuanceSubInfoValidationError{
					field:  "ValidityDay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValidityDay()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketData_TicketIssuanceSubInfoValidationError{
				field:  "ValidityDay",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRulePassedTimes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketData_TicketIssuanceSubInfoValidationError{
					field:  "RulePassedTimes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketData_TicketIssuanceSubInfoValidationError{
					field:  "RulePassedTimes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRulePassedTimes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketData_TicketIssuanceSubInfoValidationError{
				field:  "RulePassedTimes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for GoodsId

	// no validation rules for ScenicId

	if len(errors) > 0 {
		return TicketData_TicketIssuanceSubInfoMultiError(errors)
	}

	return nil
}

// TicketData_TicketIssuanceSubInfoMultiError is an error wrapping multiple
// validation errors returned by
// TicketData_TicketIssuanceSubInfo.ValidateAll() if the designated
// constraints aren't met.
type TicketData_TicketIssuanceSubInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TicketData_TicketIssuanceSubInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TicketData_TicketIssuanceSubInfoMultiError) AllErrors() []error { return m }

// TicketData_TicketIssuanceSubInfoValidationError is the validation error
// returned by TicketData_TicketIssuanceSubInfo.Validate if the designated
// constraints aren't met.
type TicketData_TicketIssuanceSubInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TicketData_TicketIssuanceSubInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TicketData_TicketIssuanceSubInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TicketData_TicketIssuanceSubInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TicketData_TicketIssuanceSubInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TicketData_TicketIssuanceSubInfoValidationError) ErrorName() string {
	return "TicketData_TicketIssuanceSubInfoValidationError"
}

// Error satisfies the builtin error interface
func (e TicketData_TicketIssuanceSubInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTicketData_TicketIssuanceSubInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TicketData_TicketIssuanceSubInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TicketData_TicketIssuanceSubInfoValidationError{}

// Validate checks the field values on TicketDataAlone_BuyerInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TicketDataAlone_BuyerInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TicketDataAlone_BuyerInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TicketDataAlone_BuyerInfoMultiError, or nil if none found.
func (m *TicketDataAlone_BuyerInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *TicketDataAlone_BuyerInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IdName

	// no validation rules for IdNumber

	if len(errors) > 0 {
		return TicketDataAlone_BuyerInfoMultiError(errors)
	}

	return nil
}

// TicketDataAlone_BuyerInfoMultiError is an error wrapping multiple validation
// errors returned by TicketDataAlone_BuyerInfo.ValidateAll() if the
// designated constraints aren't met.
type TicketDataAlone_BuyerInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TicketDataAlone_BuyerInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TicketDataAlone_BuyerInfoMultiError) AllErrors() []error { return m }

// TicketDataAlone_BuyerInfoValidationError is the validation error returned by
// TicketDataAlone_BuyerInfo.Validate if the designated constraints aren't met.
type TicketDataAlone_BuyerInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TicketDataAlone_BuyerInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TicketDataAlone_BuyerInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TicketDataAlone_BuyerInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TicketDataAlone_BuyerInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TicketDataAlone_BuyerInfoValidationError) ErrorName() string {
	return "TicketDataAlone_BuyerInfoValidationError"
}

// Error satisfies the builtin error interface
func (e TicketDataAlone_BuyerInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTicketDataAlone_BuyerInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TicketDataAlone_BuyerInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TicketDataAlone_BuyerInfoValidationError{}

// Validate checks the field values on TicketDataAlone_TicketIssuanceSubInfo
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *TicketDataAlone_TicketIssuanceSubInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TicketDataAlone_TicketIssuanceSubInfo
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// TicketDataAlone_TicketIssuanceSubInfoMultiError, or nil if none found.
func (m *TicketDataAlone_TicketIssuanceSubInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *TicketDataAlone_TicketIssuanceSubInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TicketIssuanceId

	// no validation rules for TicketTypeId

	// no validation rules for TicketTypeSubId

	if all {
		switch v := interface{}(m.GetGoodsType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataAlone_TicketIssuanceSubInfoValidationError{
					field:  "GoodsType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataAlone_TicketIssuanceSubInfoValidationError{
					field:  "GoodsType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGoodsType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataAlone_TicketIssuanceSubInfoValidationError{
				field:  "GoodsType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPassTimes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataAlone_TicketIssuanceSubInfoValidationError{
					field:  "PassTimes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataAlone_TicketIssuanceSubInfoValidationError{
					field:  "PassTimes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPassTimes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataAlone_TicketIssuanceSubInfoValidationError{
				field:  "PassTimes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPassedTimes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataAlone_TicketIssuanceSubInfoValidationError{
					field:  "PassedTimes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataAlone_TicketIssuanceSubInfoValidationError{
					field:  "PassedTimes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPassedTimes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataAlone_TicketIssuanceSubInfoValidationError{
				field:  "PassedTimes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSinglePerTimes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataAlone_TicketIssuanceSubInfoValidationError{
					field:  "SinglePerTimes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataAlone_TicketIssuanceSubInfoValidationError{
					field:  "SinglePerTimes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSinglePerTimes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataAlone_TicketIssuanceSubInfoValidationError{
				field:  "SinglePerTimes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIsValid()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataAlone_TicketIssuanceSubInfoValidationError{
					field:  "IsValid",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataAlone_TicketIssuanceSubInfoValidationError{
					field:  "IsValid",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIsValid()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataAlone_TicketIssuanceSubInfoValidationError{
				field:  "IsValid",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for EnterBeginTime

	// no validation rules for EnterEndTime

	// no validation rules for OverdueTime

	if all {
		switch v := interface{}(m.GetValidityDay()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataAlone_TicketIssuanceSubInfoValidationError{
					field:  "ValidityDay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataAlone_TicketIssuanceSubInfoValidationError{
					field:  "ValidityDay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValidityDay()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataAlone_TicketIssuanceSubInfoValidationError{
				field:  "ValidityDay",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRulePassedTimes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TicketDataAlone_TicketIssuanceSubInfoValidationError{
					field:  "RulePassedTimes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TicketDataAlone_TicketIssuanceSubInfoValidationError{
					field:  "RulePassedTimes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRulePassedTimes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TicketDataAlone_TicketIssuanceSubInfoValidationError{
				field:  "RulePassedTimes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for GoodsId

	// no validation rules for ScenicId

	if len(errors) > 0 {
		return TicketDataAlone_TicketIssuanceSubInfoMultiError(errors)
	}

	return nil
}

// TicketDataAlone_TicketIssuanceSubInfoMultiError is an error wrapping
// multiple validation errors returned by
// TicketDataAlone_TicketIssuanceSubInfo.ValidateAll() if the designated
// constraints aren't met.
type TicketDataAlone_TicketIssuanceSubInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TicketDataAlone_TicketIssuanceSubInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TicketDataAlone_TicketIssuanceSubInfoMultiError) AllErrors() []error { return m }

// TicketDataAlone_TicketIssuanceSubInfoValidationError is the validation error
// returned by TicketDataAlone_TicketIssuanceSubInfo.Validate if the
// designated constraints aren't met.
type TicketDataAlone_TicketIssuanceSubInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TicketDataAlone_TicketIssuanceSubInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TicketDataAlone_TicketIssuanceSubInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TicketDataAlone_TicketIssuanceSubInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TicketDataAlone_TicketIssuanceSubInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TicketDataAlone_TicketIssuanceSubInfoValidationError) ErrorName() string {
	return "TicketDataAlone_TicketIssuanceSubInfoValidationError"
}

// Error satisfies the builtin error interface
func (e TicketDataAlone_TicketIssuanceSubInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTicketDataAlone_TicketIssuanceSubInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TicketDataAlone_TicketIssuanceSubInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TicketDataAlone_TicketIssuanceSubInfoValidationError{}

// Validate checks the field values on
// GenerateTicketIssuanceResponse_GenerateData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GenerateTicketIssuanceResponse_GenerateData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GenerateTicketIssuanceResponse_GenerateData with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GenerateTicketIssuanceResponse_GenerateDataMultiError, or nil if none found.
func (m *GenerateTicketIssuanceResponse_GenerateData) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateTicketIssuanceResponse_GenerateData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TxId

	for idx, item := range m.GetGenerateTicketIssuanceData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GenerateTicketIssuanceResponse_GenerateDataValidationError{
						field:  fmt.Sprintf("GenerateTicketIssuanceData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GenerateTicketIssuanceResponse_GenerateDataValidationError{
						field:  fmt.Sprintf("GenerateTicketIssuanceData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GenerateTicketIssuanceResponse_GenerateDataValidationError{
					field:  fmt.Sprintf("GenerateTicketIssuanceData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GenerateTicketIssuanceResponse_GenerateDataMultiError(errors)
	}

	return nil
}

// GenerateTicketIssuanceResponse_GenerateDataMultiError is an error wrapping
// multiple validation errors returned by
// GenerateTicketIssuanceResponse_GenerateData.ValidateAll() if the designated
// constraints aren't met.
type GenerateTicketIssuanceResponse_GenerateDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateTicketIssuanceResponse_GenerateDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateTicketIssuanceResponse_GenerateDataMultiError) AllErrors() []error { return m }

// GenerateTicketIssuanceResponse_GenerateDataValidationError is the validation
// error returned by GenerateTicketIssuanceResponse_GenerateData.Validate if
// the designated constraints aren't met.
type GenerateTicketIssuanceResponse_GenerateDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateTicketIssuanceResponse_GenerateDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateTicketIssuanceResponse_GenerateDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateTicketIssuanceResponse_GenerateDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateTicketIssuanceResponse_GenerateDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateTicketIssuanceResponse_GenerateDataValidationError) ErrorName() string {
	return "GenerateTicketIssuanceResponse_GenerateDataValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateTicketIssuanceResponse_GenerateDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateTicketIssuanceResponse_GenerateData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateTicketIssuanceResponse_GenerateDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateTicketIssuanceResponse_GenerateDataValidationError{}

// Validate checks the field values on RepayRollBackRequest_RepayRollBackInfo
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *RepayRollBackRequest_RepayRollBackInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// RepayRollBackRequest_RepayRollBackInfo with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// RepayRollBackRequest_RepayRollBackInfoMultiError, or nil if none found.
func (m *RepayRollBackRequest_RepayRollBackInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *RepayRollBackRequest_RepayRollBackInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetBatchId()) < 0 {
		err := RepayRollBackRequest_RepayRollBackInfoValidationError{
			field:  "BatchId",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetStockBatchNumber()) < 0 {
		err := RepayRollBackRequest_RepayRollBackInfoValidationError{
			field:  "StockBatchNumber",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAccount()) != 42 {
		err := RepayRollBackRequest_RepayRollBackInfoValidationError{
			field:  "Account",
			reason: "value length must be 42 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetOrg()) < 0 {
		err := RepayRollBackRequest_RepayRollBackInfoValidationError{
			field:  "Org",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAvailableTotalNum()) < 0 {
		err := RepayRollBackRequest_RepayRollBackInfoValidationError{
			field:  "AvailableTotalNum",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetOrderGroupId()) < 0 {
		err := RepayRollBackRequest_RepayRollBackInfoValidationError{
			field:  "OrderGroupId",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPeriods()) < 0 {
		err := RepayRollBackRequest_RepayRollBackInfoValidationError{
			field:  "Periods",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTotalPeriods()) < 0 {
		err := RepayRollBackRequest_RepayRollBackInfoValidationError{
			field:  "TotalPeriods",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTradeNo()) < 0 {
		err := RepayRollBackRequest_RepayRollBackInfoValidationError{
			field:  "TradeNo",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAmount()) < 0 {
		err := RepayRollBackRequest_RepayRollBackInfoValidationError{
			field:  "Amount",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTotalRepayment()) < 0 {
		err := RepayRollBackRequest_RepayRollBackInfoValidationError{
			field:  "TotalRepayment",
			reason: "value length must be at least 0 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RepayRollBackRequest_RepayRollBackInfoMultiError(errors)
	}

	return nil
}

// RepayRollBackRequest_RepayRollBackInfoMultiError is an error wrapping
// multiple validation errors returned by
// RepayRollBackRequest_RepayRollBackInfo.ValidateAll() if the designated
// constraints aren't met.
type RepayRollBackRequest_RepayRollBackInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepayRollBackRequest_RepayRollBackInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepayRollBackRequest_RepayRollBackInfoMultiError) AllErrors() []error { return m }

// RepayRollBackRequest_RepayRollBackInfoValidationError is the validation
// error returned by RepayRollBackRequest_RepayRollBackInfo.Validate if the
// designated constraints aren't met.
type RepayRollBackRequest_RepayRollBackInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepayRollBackRequest_RepayRollBackInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepayRollBackRequest_RepayRollBackInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepayRollBackRequest_RepayRollBackInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepayRollBackRequest_RepayRollBackInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepayRollBackRequest_RepayRollBackInfoValidationError) ErrorName() string {
	return "RepayRollBackRequest_RepayRollBackInfoValidationError"
}

// Error satisfies the builtin error interface
func (e RepayRollBackRequest_RepayRollBackInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepayRollBackRequest_RepayRollBackInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepayRollBackRequest_RepayRollBackInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepayRollBackRequest_RepayRollBackInfoValidationError{}
