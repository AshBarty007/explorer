// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v5.26.0
// source: pkg/pb/tickets.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	TicketsV1_TransferToken_FullMethodName      = "/TicketsV1/TransferToken"
	TicketsV1_MintToken_FullMethodName          = "/TicketsV1/MintToken"
	TicketsV1_OwnerOf_FullMethodName            = "/TicketsV1/OwnerOf"
	TicketsV1_GetNtfInfo_FullMethodName         = "/TicketsV1/GetNtfInfo"
	TicketsV1_BatchMintToken_FullMethodName     = "/TicketsV1/BatchMintToken"
	TicketsV1_VerifyTicket_FullMethodName       = "/TicketsV1/VerifyTicket"
	TicketsV1_UpdateTicketStatus_FullMethodName = "/TicketsV1/UpdateTicketStatus"
)

// TicketsV1Client is the client API for TicketsV1 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TicketsV1Client interface {
	//  rpc BalanceOf(BalanceOfReq) returns (BalanceOfResp) {} // 查询余额
	//  rpc OwnerOf(OwnerOfReq) returns (OwnerOfResp) {} // 查询资产拥有者
	TransferToken(ctx context.Context, in *TransferTokenReq, opts ...grpc.CallOption) (*TransferTokenResp, error)
	//  rpc Approve(ApproveReq) returns (ApproveResp) {} // 授权指定资产
	//  rpc SetApprovalForAll(SetApprovalForAllReq) returns (SetApprovalForAllResp) {} // 托管所有资产
	//  rpc GetApproved(GetApprovedReq) returns (GetApprovedResp) {} // 查询资产托管client
	//  rpc IsApprovedForAll(IsApprovedForAllReq) returns (IsApprovedForAllResp) {} // 查询资产托管状态
	//  rpc Name(google.protobuf.Empty) returns (NameResp) {} // 查询NFT-Name
	//  rpc Symbol(google.protobuf.Empty) returns (SymbolResp) {} // 查询NFT-Symbol
	//  rpc SetOption(SetOptionReq) returns (SetOptionResp) {} // 设置NFT合约信息
	//  rpc TokenUri(TokenUriReq) returns (TokenUriResp) {} // 查询Token-Uri
	//  rpc TotalSupply(google.protobuf.Empty) returns (TotalSupplyResp) {} // 查询发行总量
	MintToken(ctx context.Context, in *MintTokenReq, opts ...grpc.CallOption) (*MintTokenResp, error)
	OwnerOf(ctx context.Context, in *OwnerOfReq, opts ...grpc.CallOption) (*OwnerOfResp, error)
	GetNtfInfo(ctx context.Context, in *GetTokenInfoReq, opts ...grpc.CallOption) (*GetTokenInfoResp, error)
	BatchMintToken(ctx context.Context, in *BatchMintTokenReq, opts ...grpc.CallOption) (*BatchMintTokenResp, error)
	VerifyTicket(ctx context.Context, in *VerifyTicketReq, opts ...grpc.CallOption) (*VerifyTicketResp, error)
	UpdateTicketStatus(ctx context.Context, in *UpdateTicketStatusReq, opts ...grpc.CallOption) (*UpdateTicketStatusResp, error)
}

type ticketsV1Client struct {
	cc grpc.ClientConnInterface
}

func NewTicketsV1Client(cc grpc.ClientConnInterface) TicketsV1Client {
	return &ticketsV1Client{cc}
}

func (c *ticketsV1Client) TransferToken(ctx context.Context, in *TransferTokenReq, opts ...grpc.CallOption) (*TransferTokenResp, error) {
	out := new(TransferTokenResp)
	err := c.cc.Invoke(ctx, TicketsV1_TransferToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketsV1Client) MintToken(ctx context.Context, in *MintTokenReq, opts ...grpc.CallOption) (*MintTokenResp, error) {
	out := new(MintTokenResp)
	err := c.cc.Invoke(ctx, TicketsV1_MintToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketsV1Client) OwnerOf(ctx context.Context, in *OwnerOfReq, opts ...grpc.CallOption) (*OwnerOfResp, error) {
	out := new(OwnerOfResp)
	err := c.cc.Invoke(ctx, TicketsV1_OwnerOf_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketsV1Client) GetNtfInfo(ctx context.Context, in *GetTokenInfoReq, opts ...grpc.CallOption) (*GetTokenInfoResp, error) {
	out := new(GetTokenInfoResp)
	err := c.cc.Invoke(ctx, TicketsV1_GetNtfInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketsV1Client) BatchMintToken(ctx context.Context, in *BatchMintTokenReq, opts ...grpc.CallOption) (*BatchMintTokenResp, error) {
	out := new(BatchMintTokenResp)
	err := c.cc.Invoke(ctx, TicketsV1_BatchMintToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketsV1Client) VerifyTicket(ctx context.Context, in *VerifyTicketReq, opts ...grpc.CallOption) (*VerifyTicketResp, error) {
	out := new(VerifyTicketResp)
	err := c.cc.Invoke(ctx, TicketsV1_VerifyTicket_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketsV1Client) UpdateTicketStatus(ctx context.Context, in *UpdateTicketStatusReq, opts ...grpc.CallOption) (*UpdateTicketStatusResp, error) {
	out := new(UpdateTicketStatusResp)
	err := c.cc.Invoke(ctx, TicketsV1_UpdateTicketStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TicketsV1Server is the server API for TicketsV1 service.
// All implementations must embed UnimplementedTicketsV1Server
// for forward compatibility
type TicketsV1Server interface {
	//  rpc BalanceOf(BalanceOfReq) returns (BalanceOfResp) {} // 查询余额
	//  rpc OwnerOf(OwnerOfReq) returns (OwnerOfResp) {} // 查询资产拥有者
	TransferToken(context.Context, *TransferTokenReq) (*TransferTokenResp, error)
	//  rpc Approve(ApproveReq) returns (ApproveResp) {} // 授权指定资产
	//  rpc SetApprovalForAll(SetApprovalForAllReq) returns (SetApprovalForAllResp) {} // 托管所有资产
	//  rpc GetApproved(GetApprovedReq) returns (GetApprovedResp) {} // 查询资产托管client
	//  rpc IsApprovedForAll(IsApprovedForAllReq) returns (IsApprovedForAllResp) {} // 查询资产托管状态
	//  rpc Name(google.protobuf.Empty) returns (NameResp) {} // 查询NFT-Name
	//  rpc Symbol(google.protobuf.Empty) returns (SymbolResp) {} // 查询NFT-Symbol
	//  rpc SetOption(SetOptionReq) returns (SetOptionResp) {} // 设置NFT合约信息
	//  rpc TokenUri(TokenUriReq) returns (TokenUriResp) {} // 查询Token-Uri
	//  rpc TotalSupply(google.protobuf.Empty) returns (TotalSupplyResp) {} // 查询发行总量
	MintToken(context.Context, *MintTokenReq) (*MintTokenResp, error)
	OwnerOf(context.Context, *OwnerOfReq) (*OwnerOfResp, error)
	GetNtfInfo(context.Context, *GetTokenInfoReq) (*GetTokenInfoResp, error)
	BatchMintToken(context.Context, *BatchMintTokenReq) (*BatchMintTokenResp, error)
	VerifyTicket(context.Context, *VerifyTicketReq) (*VerifyTicketResp, error)
	UpdateTicketStatus(context.Context, *UpdateTicketStatusReq) (*UpdateTicketStatusResp, error)
}

// UnimplementedTicketsV1Server must be embedded to have forward compatible implementations.
type UnimplementedTicketsV1Server struct {
}

func (UnimplementedTicketsV1Server) TransferToken(context.Context, *TransferTokenReq) (*TransferTokenResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferToken not implemented")
}
func (UnimplementedTicketsV1Server) MintToken(context.Context, *MintTokenReq) (*MintTokenResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MintToken not implemented")
}
func (UnimplementedTicketsV1Server) OwnerOf(context.Context, *OwnerOfReq) (*OwnerOfResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OwnerOf not implemented")
}
func (UnimplementedTicketsV1Server) GetNtfInfo(context.Context, *GetTokenInfoReq) (*GetTokenInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNtfInfo not implemented")
}
func (UnimplementedTicketsV1Server) BatchMintToken(context.Context, *BatchMintTokenReq) (*BatchMintTokenResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchMintToken not implemented")
}
func (UnimplementedTicketsV1Server) VerifyTicket(context.Context, *VerifyTicketReq) (*VerifyTicketResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyTicket not implemented")
}
func (UnimplementedTicketsV1Server) UpdateTicketStatus(context.Context, *UpdateTicketStatusReq) (*UpdateTicketStatusResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTicketStatus not implemented")
}
func (UnimplementedTicketsV1Server) mustEmbedUnimplementedTicketsV1Server() {}

// UnsafeTicketsV1Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TicketsV1Server will
// result in compilation errors.
type UnsafeTicketsV1Server interface {
	mustEmbedUnimplementedTicketsV1Server()
}

func RegisterTicketsV1Server(s grpc.ServiceRegistrar, srv TicketsV1Server) {
	s.RegisterService(&TicketsV1_ServiceDesc, srv)
}

func _TicketsV1_TransferToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketsV1Server).TransferToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketsV1_TransferToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketsV1Server).TransferToken(ctx, req.(*TransferTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketsV1_MintToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MintTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketsV1Server).MintToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketsV1_MintToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketsV1Server).MintToken(ctx, req.(*MintTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketsV1_OwnerOf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OwnerOfReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketsV1Server).OwnerOf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketsV1_OwnerOf_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketsV1Server).OwnerOf(ctx, req.(*OwnerOfReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketsV1_GetNtfInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketsV1Server).GetNtfInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketsV1_GetNtfInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketsV1Server).GetNtfInfo(ctx, req.(*GetTokenInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketsV1_BatchMintToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchMintTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketsV1Server).BatchMintToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketsV1_BatchMintToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketsV1Server).BatchMintToken(ctx, req.(*BatchMintTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketsV1_VerifyTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyTicketReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketsV1Server).VerifyTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketsV1_VerifyTicket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketsV1Server).VerifyTicket(ctx, req.(*VerifyTicketReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketsV1_UpdateTicketStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTicketStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketsV1Server).UpdateTicketStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TicketsV1_UpdateTicketStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketsV1Server).UpdateTicketStatus(ctx, req.(*UpdateTicketStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

// TicketsV1_ServiceDesc is the grpc.ServiceDesc for TicketsV1 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TicketsV1_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "TicketsV1",
	HandlerType: (*TicketsV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TransferToken",
			Handler:    _TicketsV1_TransferToken_Handler,
		},
		{
			MethodName: "MintToken",
			Handler:    _TicketsV1_MintToken_Handler,
		},
		{
			MethodName: "OwnerOf",
			Handler:    _TicketsV1_OwnerOf_Handler,
		},
		{
			MethodName: "GetNtfInfo",
			Handler:    _TicketsV1_GetNtfInfo_Handler,
		},
		{
			MethodName: "BatchMintToken",
			Handler:    _TicketsV1_BatchMintToken_Handler,
		},
		{
			MethodName: "VerifyTicket",
			Handler:    _TicketsV1_VerifyTicket_Handler,
		},
		{
			MethodName: "UpdateTicketStatus",
			Handler:    _TicketsV1_UpdateTicketStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/pb/tickets.proto",
}
